
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model ScheduleSlot
 * 
 */
export type ScheduleSlot = $Result.DefaultSelection<Prisma.$ScheduleSlotPayload>
/**
 * Model ActivitySchedule
 * 
 */
export type ActivitySchedule = $Result.DefaultSelection<Prisma.$ActivitySchedulePayload>
/**
 * Model ActivityScheduleWeekday
 * 
 */
export type ActivityScheduleWeekday = $Result.DefaultSelection<Prisma.$ActivityScheduleWeekdayPayload>
/**
 * Model ActivityScheduleDate
 * 
 */
export type ActivityScheduleDate = $Result.DefaultSelection<Prisma.$ActivityScheduleDatePayload>
/**
 * Model ActivityOccurrence
 * 
 */
export type ActivityOccurrence = $Result.DefaultSelection<Prisma.$ActivityOccurrencePayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model ExpenseAccount
 * 
 */
export type ExpenseAccount = $Result.DefaultSelection<Prisma.$ExpenseAccountPayload>
/**
 * Model ExpenseCategory
 * 
 */
export type ExpenseCategory = $Result.DefaultSelection<Prisma.$ExpenseCategoryPayload>
/**
 * Model ExpenseSubcategory
 * 
 */
export type ExpenseSubcategory = $Result.DefaultSelection<Prisma.$ExpenseSubcategoryPayload>
/**
 * Model ExpenseEntry
 * 
 */
export type ExpenseEntry = $Result.DefaultSelection<Prisma.$ExpenseEntryPayload>
/**
 * Model ExpenseStore
 * 
 */
export type ExpenseStore = $Result.DefaultSelection<Prisma.$ExpenseStorePayload>
/**
 * Model ExpenseReceipt
 * 
 */
export type ExpenseReceipt = $Result.DefaultSelection<Prisma.$ExpenseReceiptPayload>
/**
 * Model ExpenseProduct
 * 
 */
export type ExpenseProduct = $Result.DefaultSelection<Prisma.$ExpenseProductPayload>
/**
 * Model ExpenseReceiptItem
 * 
 */
export type ExpenseReceiptItem = $Result.DefaultSelection<Prisma.$ExpenseReceiptItemPayload>
/**
 * Model MuscleGroup
 * 
 */
export type MuscleGroup = $Result.DefaultSelection<Prisma.$MuscleGroupPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model Workout
 * 
 */
export type Workout = $Result.DefaultSelection<Prisma.$WorkoutPayload>
/**
 * Model WorkoutEntry
 * 
 */
export type WorkoutEntry = $Result.DefaultSelection<Prisma.$WorkoutEntryPayload>
/**
 * Model WorkoutSet
 * 
 */
export type WorkoutSet = $Result.DefaultSelection<Prisma.$WorkoutSetPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN',
  SUPPORT: 'SUPPORT'
};

export type AuthRole = (typeof AuthRole)[keyof typeof AuthRole]


export const ScheduleDay: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type ScheduleDay = (typeof ScheduleDay)[keyof typeof ScheduleDay]


export const ExpenseEntryType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE',
  TRANSFER: 'TRANSFER'
};

export type ExpenseEntryType = (typeof ExpenseEntryType)[keyof typeof ExpenseEntryType]


export const ExerciseType: {
  REPS: 'REPS',
  TIME: 'TIME'
};

export type ExerciseType = (typeof ExerciseType)[keyof typeof ExerciseType]


export const ActivityRepeatType: {
  DAILY: 'DAILY',
  WEEKDAYS: 'WEEKDAYS',
  INTERVAL: 'INTERVAL',
  DATES: 'DATES',
  FREQUENCY: 'FREQUENCY'
};

export type ActivityRepeatType = (typeof ActivityRepeatType)[keyof typeof ActivityRepeatType]


export const ActivityTargetType: {
  BOOLEAN: 'BOOLEAN',
  QUANTITY: 'QUANTITY'
};

export type ActivityTargetType = (typeof ActivityTargetType)[keyof typeof ActivityTargetType]


export const ActivityTargetUnit: {
  PAGES: 'PAGES',
  MINUTES: 'MINUTES',
  KM: 'KM',
  TIMES: 'TIMES',
  CUSTOM: 'CUSTOM'
};

export type ActivityTargetUnit = (typeof ActivityTargetUnit)[keyof typeof ActivityTargetUnit]


export const FrequencyPeriod: {
  WEEK: 'WEEK',
  MONTH: 'MONTH'
};

export type FrequencyPeriod = (typeof FrequencyPeriod)[keyof typeof FrequencyPeriod]


export const OccurrenceStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  SKIPPED: 'SKIPPED',
  FAILED: 'FAILED'
};

export type OccurrenceStatus = (typeof OccurrenceStatus)[keyof typeof OccurrenceStatus]

}

export type AuthRole = $Enums.AuthRole

export const AuthRole: typeof $Enums.AuthRole

export type ScheduleDay = $Enums.ScheduleDay

export const ScheduleDay: typeof $Enums.ScheduleDay

export type ExpenseEntryType = $Enums.ExpenseEntryType

export const ExpenseEntryType: typeof $Enums.ExpenseEntryType

export type ExerciseType = $Enums.ExerciseType

export const ExerciseType: typeof $Enums.ExerciseType

export type ActivityRepeatType = $Enums.ActivityRepeatType

export const ActivityRepeatType: typeof $Enums.ActivityRepeatType

export type ActivityTargetType = $Enums.ActivityTargetType

export const ActivityTargetType: typeof $Enums.ActivityTargetType

export type ActivityTargetUnit = $Enums.ActivityTargetUnit

export const ActivityTargetUnit: typeof $Enums.ActivityTargetUnit

export type FrequencyPeriod = $Enums.FrequencyPeriod

export const FrequencyPeriod: typeof $Enums.FrequencyPeriod

export type OccurrenceStatus = $Enums.OccurrenceStatus

export const OccurrenceStatus: typeof $Enums.OccurrenceStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleSlot`: Exposes CRUD operations for the **ScheduleSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleSlots
    * const scheduleSlots = await prisma.scheduleSlot.findMany()
    * ```
    */
  get scheduleSlot(): Prisma.ScheduleSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activitySchedule`: Exposes CRUD operations for the **ActivitySchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivitySchedules
    * const activitySchedules = await prisma.activitySchedule.findMany()
    * ```
    */
  get activitySchedule(): Prisma.ActivityScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityScheduleWeekday`: Exposes CRUD operations for the **ActivityScheduleWeekday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityScheduleWeekdays
    * const activityScheduleWeekdays = await prisma.activityScheduleWeekday.findMany()
    * ```
    */
  get activityScheduleWeekday(): Prisma.ActivityScheduleWeekdayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityScheduleDate`: Exposes CRUD operations for the **ActivityScheduleDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityScheduleDates
    * const activityScheduleDates = await prisma.activityScheduleDate.findMany()
    * ```
    */
  get activityScheduleDate(): Prisma.ActivityScheduleDateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityOccurrence`: Exposes CRUD operations for the **ActivityOccurrence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityOccurrences
    * const activityOccurrences = await prisma.activityOccurrence.findMany()
    * ```
    */
  get activityOccurrence(): Prisma.ActivityOccurrenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseAccount`: Exposes CRUD operations for the **ExpenseAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseAccounts
    * const expenseAccounts = await prisma.expenseAccount.findMany()
    * ```
    */
  get expenseAccount(): Prisma.ExpenseAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseCategory`: Exposes CRUD operations for the **ExpenseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseCategories
    * const expenseCategories = await prisma.expenseCategory.findMany()
    * ```
    */
  get expenseCategory(): Prisma.ExpenseCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseSubcategory`: Exposes CRUD operations for the **ExpenseSubcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseSubcategories
    * const expenseSubcategories = await prisma.expenseSubcategory.findMany()
    * ```
    */
  get expenseSubcategory(): Prisma.ExpenseSubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseEntry`: Exposes CRUD operations for the **ExpenseEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseEntries
    * const expenseEntries = await prisma.expenseEntry.findMany()
    * ```
    */
  get expenseEntry(): Prisma.ExpenseEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseStore`: Exposes CRUD operations for the **ExpenseStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseStores
    * const expenseStores = await prisma.expenseStore.findMany()
    * ```
    */
  get expenseStore(): Prisma.ExpenseStoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseReceipt`: Exposes CRUD operations for the **ExpenseReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseReceipts
    * const expenseReceipts = await prisma.expenseReceipt.findMany()
    * ```
    */
  get expenseReceipt(): Prisma.ExpenseReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseProduct`: Exposes CRUD operations for the **ExpenseProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseProducts
    * const expenseProducts = await prisma.expenseProduct.findMany()
    * ```
    */
  get expenseProduct(): Prisma.ExpenseProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseReceiptItem`: Exposes CRUD operations for the **ExpenseReceiptItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseReceiptItems
    * const expenseReceiptItems = await prisma.expenseReceiptItem.findMany()
    * ```
    */
  get expenseReceiptItem(): Prisma.ExpenseReceiptItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.muscleGroup`: Exposes CRUD operations for the **MuscleGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MuscleGroups
    * const muscleGroups = await prisma.muscleGroup.findMany()
    * ```
    */
  get muscleGroup(): Prisma.MuscleGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workout`: Exposes CRUD operations for the **Workout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workouts
    * const workouts = await prisma.workout.findMany()
    * ```
    */
  get workout(): Prisma.WorkoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workoutEntry`: Exposes CRUD operations for the **WorkoutEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutEntries
    * const workoutEntries = await prisma.workoutEntry.findMany()
    * ```
    */
  get workoutEntry(): Prisma.WorkoutEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workoutSet`: Exposes CRUD operations for the **WorkoutSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutSets
    * const workoutSets = await prisma.workoutSet.findMany()
    * ```
    */
  get workoutSet(): Prisma.WorkoutSetDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Activity: 'Activity',
    ScheduleSlot: 'ScheduleSlot',
    ActivitySchedule: 'ActivitySchedule',
    ActivityScheduleWeekday: 'ActivityScheduleWeekday',
    ActivityScheduleDate: 'ActivityScheduleDate',
    ActivityOccurrence: 'ActivityOccurrence',
    ActivityLog: 'ActivityLog',
    ExpenseAccount: 'ExpenseAccount',
    ExpenseCategory: 'ExpenseCategory',
    ExpenseSubcategory: 'ExpenseSubcategory',
    ExpenseEntry: 'ExpenseEntry',
    ExpenseStore: 'ExpenseStore',
    ExpenseReceipt: 'ExpenseReceipt',
    ExpenseProduct: 'ExpenseProduct',
    ExpenseReceiptItem: 'ExpenseReceiptItem',
    MuscleGroup: 'MuscleGroup',
    Exercise: 'Exercise',
    Workout: 'Workout',
    WorkoutEntry: 'WorkoutEntry',
    WorkoutSet: 'WorkoutSet'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "activity" | "scheduleSlot" | "activitySchedule" | "activityScheduleWeekday" | "activityScheduleDate" | "activityOccurrence" | "activityLog" | "expenseAccount" | "expenseCategory" | "expenseSubcategory" | "expenseEntry" | "expenseStore" | "expenseReceipt" | "expenseProduct" | "expenseReceiptItem" | "muscleGroup" | "exercise" | "workout" | "workoutEntry" | "workoutSet"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      ScheduleSlot: {
        payload: Prisma.$ScheduleSlotPayload<ExtArgs>
        fields: Prisma.ScheduleSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>
          }
          findFirst: {
            args: Prisma.ScheduleSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>
          }
          findMany: {
            args: Prisma.ScheduleSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>[]
          }
          create: {
            args: Prisma.ScheduleSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>
          }
          createMany: {
            args: Prisma.ScheduleSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>[]
          }
          delete: {
            args: Prisma.ScheduleSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>
          }
          update: {
            args: Prisma.ScheduleSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleSlotPayload>
          }
          aggregate: {
            args: Prisma.ScheduleSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleSlot>
          }
          groupBy: {
            args: Prisma.ScheduleSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleSlotCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleSlotCountAggregateOutputType> | number
          }
        }
      }
      ActivitySchedule: {
        payload: Prisma.$ActivitySchedulePayload<ExtArgs>
        fields: Prisma.ActivityScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>
          }
          findFirst: {
            args: Prisma.ActivityScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>
          }
          findMany: {
            args: Prisma.ActivityScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>[]
          }
          create: {
            args: Prisma.ActivityScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>
          }
          createMany: {
            args: Prisma.ActivityScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>[]
          }
          delete: {
            args: Prisma.ActivityScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>
          }
          update: {
            args: Prisma.ActivityScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>
          }
          deleteMany: {
            args: Prisma.ActivityScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>[]
          }
          upsert: {
            args: Prisma.ActivityScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivitySchedulePayload>
          }
          aggregate: {
            args: Prisma.ActivityScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivitySchedule>
          }
          groupBy: {
            args: Prisma.ActivityScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityScheduleCountAggregateOutputType> | number
          }
        }
      }
      ActivityScheduleWeekday: {
        payload: Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>
        fields: Prisma.ActivityScheduleWeekdayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityScheduleWeekdayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityScheduleWeekdayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>
          }
          findFirst: {
            args: Prisma.ActivityScheduleWeekdayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityScheduleWeekdayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>
          }
          findMany: {
            args: Prisma.ActivityScheduleWeekdayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>[]
          }
          create: {
            args: Prisma.ActivityScheduleWeekdayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>
          }
          createMany: {
            args: Prisma.ActivityScheduleWeekdayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityScheduleWeekdayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>[]
          }
          delete: {
            args: Prisma.ActivityScheduleWeekdayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>
          }
          update: {
            args: Prisma.ActivityScheduleWeekdayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>
          }
          deleteMany: {
            args: Prisma.ActivityScheduleWeekdayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityScheduleWeekdayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityScheduleWeekdayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>[]
          }
          upsert: {
            args: Prisma.ActivityScheduleWeekdayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleWeekdayPayload>
          }
          aggregate: {
            args: Prisma.ActivityScheduleWeekdayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityScheduleWeekday>
          }
          groupBy: {
            args: Prisma.ActivityScheduleWeekdayGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityScheduleWeekdayGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityScheduleWeekdayCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityScheduleWeekdayCountAggregateOutputType> | number
          }
        }
      }
      ActivityScheduleDate: {
        payload: Prisma.$ActivityScheduleDatePayload<ExtArgs>
        fields: Prisma.ActivityScheduleDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityScheduleDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityScheduleDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>
          }
          findFirst: {
            args: Prisma.ActivityScheduleDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityScheduleDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>
          }
          findMany: {
            args: Prisma.ActivityScheduleDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>[]
          }
          create: {
            args: Prisma.ActivityScheduleDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>
          }
          createMany: {
            args: Prisma.ActivityScheduleDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityScheduleDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>[]
          }
          delete: {
            args: Prisma.ActivityScheduleDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>
          }
          update: {
            args: Prisma.ActivityScheduleDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>
          }
          deleteMany: {
            args: Prisma.ActivityScheduleDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityScheduleDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityScheduleDateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>[]
          }
          upsert: {
            args: Prisma.ActivityScheduleDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityScheduleDatePayload>
          }
          aggregate: {
            args: Prisma.ActivityScheduleDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityScheduleDate>
          }
          groupBy: {
            args: Prisma.ActivityScheduleDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityScheduleDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityScheduleDateCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityScheduleDateCountAggregateOutputType> | number
          }
        }
      }
      ActivityOccurrence: {
        payload: Prisma.$ActivityOccurrencePayload<ExtArgs>
        fields: Prisma.ActivityOccurrenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityOccurrenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityOccurrenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>
          }
          findFirst: {
            args: Prisma.ActivityOccurrenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityOccurrenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>
          }
          findMany: {
            args: Prisma.ActivityOccurrenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>[]
          }
          create: {
            args: Prisma.ActivityOccurrenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>
          }
          createMany: {
            args: Prisma.ActivityOccurrenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityOccurrenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>[]
          }
          delete: {
            args: Prisma.ActivityOccurrenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>
          }
          update: {
            args: Prisma.ActivityOccurrenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>
          }
          deleteMany: {
            args: Prisma.ActivityOccurrenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityOccurrenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityOccurrenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>[]
          }
          upsert: {
            args: Prisma.ActivityOccurrenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityOccurrencePayload>
          }
          aggregate: {
            args: Prisma.ActivityOccurrenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityOccurrence>
          }
          groupBy: {
            args: Prisma.ActivityOccurrenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityOccurrenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityOccurrenceCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityOccurrenceCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      ExpenseAccount: {
        payload: Prisma.$ExpenseAccountPayload<ExtArgs>
        fields: Prisma.ExpenseAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>
          }
          findFirst: {
            args: Prisma.ExpenseAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>
          }
          findMany: {
            args: Prisma.ExpenseAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>[]
          }
          create: {
            args: Prisma.ExpenseAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>
          }
          createMany: {
            args: Prisma.ExpenseAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>[]
          }
          delete: {
            args: Prisma.ExpenseAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>
          }
          update: {
            args: Prisma.ExpenseAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseAccountPayload>
          }
          aggregate: {
            args: Prisma.ExpenseAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseAccount>
          }
          groupBy: {
            args: Prisma.ExpenseAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseAccountCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseAccountCountAggregateOutputType> | number
          }
        }
      }
      ExpenseCategory: {
        payload: Prisma.$ExpenseCategoryPayload<ExtArgs>
        fields: Prisma.ExpenseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          update: {
            args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseCategory>
          }
          groupBy: {
            args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryCountAggregateOutputType> | number
          }
        }
      }
      ExpenseSubcategory: {
        payload: Prisma.$ExpenseSubcategoryPayload<ExtArgs>
        fields: Prisma.ExpenseSubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseSubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseSubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseSubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseSubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseSubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseSubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseSubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseSubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseSubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>
          }
          update: {
            args: Prisma.ExpenseSubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseSubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseSubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseSubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseSubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSubcategoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseSubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseSubcategory>
          }
          groupBy: {
            args: Prisma.ExpenseSubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseSubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseSubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseSubcategoryCountAggregateOutputType> | number
          }
        }
      }
      ExpenseEntry: {
        payload: Prisma.$ExpenseEntryPayload<ExtArgs>
        fields: Prisma.ExpenseEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>
          }
          findMany: {
            args: Prisma.ExpenseEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>[]
          }
          create: {
            args: Prisma.ExpenseEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>
          }
          createMany: {
            args: Prisma.ExpenseEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>
          }
          update: {
            args: Prisma.ExpenseEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseEntryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseEntry>
          }
          groupBy: {
            args: Prisma.ExpenseEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseEntryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseEntryCountAggregateOutputType> | number
          }
        }
      }
      ExpenseStore: {
        payload: Prisma.$ExpenseStorePayload<ExtArgs>
        fields: Prisma.ExpenseStoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseStoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseStoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>
          }
          findFirst: {
            args: Prisma.ExpenseStoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseStoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>
          }
          findMany: {
            args: Prisma.ExpenseStoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>[]
          }
          create: {
            args: Prisma.ExpenseStoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>
          }
          createMany: {
            args: Prisma.ExpenseStoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseStoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>[]
          }
          delete: {
            args: Prisma.ExpenseStoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>
          }
          update: {
            args: Prisma.ExpenseStoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseStoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseStoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseStoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseStoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseStorePayload>
          }
          aggregate: {
            args: Prisma.ExpenseStoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseStore>
          }
          groupBy: {
            args: Prisma.ExpenseStoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseStoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseStoreCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseStoreCountAggregateOutputType> | number
          }
        }
      }
      ExpenseReceipt: {
        payload: Prisma.$ExpenseReceiptPayload<ExtArgs>
        fields: Prisma.ExpenseReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>
          }
          findFirst: {
            args: Prisma.ExpenseReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>
          }
          findMany: {
            args: Prisma.ExpenseReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>[]
          }
          create: {
            args: Prisma.ExpenseReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>
          }
          createMany: {
            args: Prisma.ExpenseReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>[]
          }
          delete: {
            args: Prisma.ExpenseReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>
          }
          update: {
            args: Prisma.ExpenseReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptPayload>
          }
          aggregate: {
            args: Prisma.ExpenseReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseReceipt>
          }
          groupBy: {
            args: Prisma.ExpenseReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseReceiptCountAggregateOutputType> | number
          }
        }
      }
      ExpenseProduct: {
        payload: Prisma.$ExpenseProductPayload<ExtArgs>
        fields: Prisma.ExpenseProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>
          }
          findFirst: {
            args: Prisma.ExpenseProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>
          }
          findMany: {
            args: Prisma.ExpenseProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>[]
          }
          create: {
            args: Prisma.ExpenseProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>
          }
          createMany: {
            args: Prisma.ExpenseProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>[]
          }
          delete: {
            args: Prisma.ExpenseProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>
          }
          update: {
            args: Prisma.ExpenseProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseProductPayload>
          }
          aggregate: {
            args: Prisma.ExpenseProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseProduct>
          }
          groupBy: {
            args: Prisma.ExpenseProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseProductCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseProductCountAggregateOutputType> | number
          }
        }
      }
      ExpenseReceiptItem: {
        payload: Prisma.$ExpenseReceiptItemPayload<ExtArgs>
        fields: Prisma.ExpenseReceiptItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseReceiptItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseReceiptItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>
          }
          findFirst: {
            args: Prisma.ExpenseReceiptItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseReceiptItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>
          }
          findMany: {
            args: Prisma.ExpenseReceiptItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>[]
          }
          create: {
            args: Prisma.ExpenseReceiptItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>
          }
          createMany: {
            args: Prisma.ExpenseReceiptItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseReceiptItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>[]
          }
          delete: {
            args: Prisma.ExpenseReceiptItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>
          }
          update: {
            args: Prisma.ExpenseReceiptItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseReceiptItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseReceiptItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseReceiptItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseReceiptItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseReceiptItemPayload>
          }
          aggregate: {
            args: Prisma.ExpenseReceiptItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseReceiptItem>
          }
          groupBy: {
            args: Prisma.ExpenseReceiptItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseReceiptItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseReceiptItemCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseReceiptItemCountAggregateOutputType> | number
          }
        }
      }
      MuscleGroup: {
        payload: Prisma.$MuscleGroupPayload<ExtArgs>
        fields: Prisma.MuscleGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MuscleGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MuscleGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>
          }
          findFirst: {
            args: Prisma.MuscleGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MuscleGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>
          }
          findMany: {
            args: Prisma.MuscleGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>[]
          }
          create: {
            args: Prisma.MuscleGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>
          }
          createMany: {
            args: Prisma.MuscleGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MuscleGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>[]
          }
          delete: {
            args: Prisma.MuscleGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>
          }
          update: {
            args: Prisma.MuscleGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>
          }
          deleteMany: {
            args: Prisma.MuscleGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MuscleGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MuscleGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>[]
          }
          upsert: {
            args: Prisma.MuscleGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuscleGroupPayload>
          }
          aggregate: {
            args: Prisma.MuscleGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMuscleGroup>
          }
          groupBy: {
            args: Prisma.MuscleGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<MuscleGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.MuscleGroupCountArgs<ExtArgs>
            result: $Utils.Optional<MuscleGroupCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      Workout: {
        payload: Prisma.$WorkoutPayload<ExtArgs>
        fields: Prisma.WorkoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          findFirst: {
            args: Prisma.WorkoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          findMany: {
            args: Prisma.WorkoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>[]
          }
          create: {
            args: Prisma.WorkoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          createMany: {
            args: Prisma.WorkoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>[]
          }
          delete: {
            args: Prisma.WorkoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          update: {
            args: Prisma.WorkoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>[]
          }
          upsert: {
            args: Prisma.WorkoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          aggregate: {
            args: Prisma.WorkoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkout>
          }
          groupBy: {
            args: Prisma.WorkoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutCountAggregateOutputType> | number
          }
        }
      }
      WorkoutEntry: {
        payload: Prisma.$WorkoutEntryPayload<ExtArgs>
        fields: Prisma.WorkoutEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>
          }
          findFirst: {
            args: Prisma.WorkoutEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>
          }
          findMany: {
            args: Prisma.WorkoutEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>[]
          }
          create: {
            args: Prisma.WorkoutEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>
          }
          createMany: {
            args: Prisma.WorkoutEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>[]
          }
          delete: {
            args: Prisma.WorkoutEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>
          }
          update: {
            args: Prisma.WorkoutEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>[]
          }
          upsert: {
            args: Prisma.WorkoutEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutEntryPayload>
          }
          aggregate: {
            args: Prisma.WorkoutEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutEntry>
          }
          groupBy: {
            args: Prisma.WorkoutEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutEntryCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutEntryCountAggregateOutputType> | number
          }
        }
      }
      WorkoutSet: {
        payload: Prisma.$WorkoutSetPayload<ExtArgs>
        fields: Prisma.WorkoutSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutSetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutSetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          findFirst: {
            args: Prisma.WorkoutSetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutSetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          findMany: {
            args: Prisma.WorkoutSetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>[]
          }
          create: {
            args: Prisma.WorkoutSetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          createMany: {
            args: Prisma.WorkoutSetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutSetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>[]
          }
          delete: {
            args: Prisma.WorkoutSetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          update: {
            args: Prisma.WorkoutSetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutSetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutSetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutSetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>[]
          }
          upsert: {
            args: Prisma.WorkoutSetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          aggregate: {
            args: Prisma.WorkoutSetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutSet>
          }
          groupBy: {
            args: Prisma.WorkoutSetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutSetCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutSetCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    activity?: ActivityOmit
    scheduleSlot?: ScheduleSlotOmit
    activitySchedule?: ActivityScheduleOmit
    activityScheduleWeekday?: ActivityScheduleWeekdayOmit
    activityScheduleDate?: ActivityScheduleDateOmit
    activityOccurrence?: ActivityOccurrenceOmit
    activityLog?: ActivityLogOmit
    expenseAccount?: ExpenseAccountOmit
    expenseCategory?: ExpenseCategoryOmit
    expenseSubcategory?: ExpenseSubcategoryOmit
    expenseEntry?: ExpenseEntryOmit
    expenseStore?: ExpenseStoreOmit
    expenseReceipt?: ExpenseReceiptOmit
    expenseProduct?: ExpenseProductOmit
    expenseReceiptItem?: ExpenseReceiptItemOmit
    muscleGroup?: MuscleGroupOmit
    exercise?: ExerciseOmit
    workout?: WorkoutOmit
    workoutEntry?: WorkoutEntryOmit
    workoutSet?: WorkoutSetOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    activities: number
    schedule_slots: number
    activity_schedules: number
    activity_logs: number
    activity_occurrences: number
    expense_accounts: number
    expense_entries: number
    categories: number
    subcategories: number
    expense_receipts: number
    expense_stores: number
    expense_products: number
    muscle_groups: number
    exercises: number
    workouts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    schedule_slots?: boolean | UserCountOutputTypeCountSchedule_slotsArgs
    activity_schedules?: boolean | UserCountOutputTypeCountActivity_schedulesArgs
    activity_logs?: boolean | UserCountOutputTypeCountActivity_logsArgs
    activity_occurrences?: boolean | UserCountOutputTypeCountActivity_occurrencesArgs
    expense_accounts?: boolean | UserCountOutputTypeCountExpense_accountsArgs
    expense_entries?: boolean | UserCountOutputTypeCountExpense_entriesArgs
    categories?: boolean | UserCountOutputTypeCountCategoriesArgs
    subcategories?: boolean | UserCountOutputTypeCountSubcategoriesArgs
    expense_receipts?: boolean | UserCountOutputTypeCountExpense_receiptsArgs
    expense_stores?: boolean | UserCountOutputTypeCountExpense_storesArgs
    expense_products?: boolean | UserCountOutputTypeCountExpense_productsArgs
    muscle_groups?: boolean | UserCountOutputTypeCountMuscle_groupsArgs
    exercises?: boolean | UserCountOutputTypeCountExercisesArgs
    workouts?: boolean | UserCountOutputTypeCountWorkoutsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSchedule_slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleSlotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivity_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivity_occurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityOccurrenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpense_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpense_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseSubcategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpense_receiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseReceiptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpense_storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseStoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpense_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMuscle_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuscleGroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    schedule_slots: number
    activity_schedules: number
    activity_logs: number
    activity_occurrences: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule_slots?: boolean | ActivityCountOutputTypeCountSchedule_slotsArgs
    activity_schedules?: boolean | ActivityCountOutputTypeCountActivity_schedulesArgs
    activity_logs?: boolean | ActivityCountOutputTypeCountActivity_logsArgs
    activity_occurrences?: boolean | ActivityCountOutputTypeCountActivity_occurrencesArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountSchedule_slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleSlotWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountActivity_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityScheduleWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountActivity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountActivity_occurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityOccurrenceWhereInput
  }


  /**
   * Count Type ActivityScheduleCountOutputType
   */

  export type ActivityScheduleCountOutputType = {
    weekdays: number
    specific_dates: number
    occurrences: number
    logs: number
  }

  export type ActivityScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weekdays?: boolean | ActivityScheduleCountOutputTypeCountWeekdaysArgs
    specific_dates?: boolean | ActivityScheduleCountOutputTypeCountSpecific_datesArgs
    occurrences?: boolean | ActivityScheduleCountOutputTypeCountOccurrencesArgs
    logs?: boolean | ActivityScheduleCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * ActivityScheduleCountOutputType without action
   */
  export type ActivityScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleCountOutputType
     */
    select?: ActivityScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityScheduleCountOutputType without action
   */
  export type ActivityScheduleCountOutputTypeCountWeekdaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityScheduleWeekdayWhereInput
  }

  /**
   * ActivityScheduleCountOutputType without action
   */
  export type ActivityScheduleCountOutputTypeCountSpecific_datesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityScheduleDateWhereInput
  }

  /**
   * ActivityScheduleCountOutputType without action
   */
  export type ActivityScheduleCountOutputTypeCountOccurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityOccurrenceWhereInput
  }

  /**
   * ActivityScheduleCountOutputType without action
   */
  export type ActivityScheduleCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type ExpenseAccountCountOutputType
   */

  export type ExpenseAccountCountOutputType = {
    entries_from: number
    entries_to: number
  }

  export type ExpenseAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries_from?: boolean | ExpenseAccountCountOutputTypeCountEntries_fromArgs
    entries_to?: boolean | ExpenseAccountCountOutputTypeCountEntries_toArgs
  }

  // Custom InputTypes
  /**
   * ExpenseAccountCountOutputType without action
   */
  export type ExpenseAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccountCountOutputType
     */
    select?: ExpenseAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseAccountCountOutputType without action
   */
  export type ExpenseAccountCountOutputTypeCountEntries_fromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseEntryWhereInput
  }

  /**
   * ExpenseAccountCountOutputType without action
   */
  export type ExpenseAccountCountOutputTypeCountEntries_toArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseEntryWhereInput
  }


  /**
   * Count Type ExpenseCategoryCountOutputType
   */

  export type ExpenseCategoryCountOutputType = {
    subcategories: number
    entries: number
    products: number
  }

  export type ExpenseCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subcategories?: boolean | ExpenseCategoryCountOutputTypeCountSubcategoriesArgs
    entries?: boolean | ExpenseCategoryCountOutputTypeCountEntriesArgs
    products?: boolean | ExpenseCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategoryCountOutputType
     */
    select?: ExpenseCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseSubcategoryWhereInput
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseEntryWhereInput
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseProductWhereInput
  }


  /**
   * Count Type ExpenseSubcategoryCountOutputType
   */

  export type ExpenseSubcategoryCountOutputType = {
    entries: number
    products: number
  }

  export type ExpenseSubcategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | ExpenseSubcategoryCountOutputTypeCountEntriesArgs
    products?: boolean | ExpenseSubcategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ExpenseSubcategoryCountOutputType without action
   */
  export type ExpenseSubcategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategoryCountOutputType
     */
    select?: ExpenseSubcategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseSubcategoryCountOutputType without action
   */
  export type ExpenseSubcategoryCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseEntryWhereInput
  }

  /**
   * ExpenseSubcategoryCountOutputType without action
   */
  export type ExpenseSubcategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseProductWhereInput
  }


  /**
   * Count Type ExpenseStoreCountOutputType
   */

  export type ExpenseStoreCountOutputType = {
    receipts: number
  }

  export type ExpenseStoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipts?: boolean | ExpenseStoreCountOutputTypeCountReceiptsArgs
  }

  // Custom InputTypes
  /**
   * ExpenseStoreCountOutputType without action
   */
  export type ExpenseStoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStoreCountOutputType
     */
    select?: ExpenseStoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseStoreCountOutputType without action
   */
  export type ExpenseStoreCountOutputTypeCountReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseReceiptWhereInput
  }


  /**
   * Count Type ExpenseReceiptCountOutputType
   */

  export type ExpenseReceiptCountOutputType = {
    items: number
  }

  export type ExpenseReceiptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ExpenseReceiptCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ExpenseReceiptCountOutputType without action
   */
  export type ExpenseReceiptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptCountOutputType
     */
    select?: ExpenseReceiptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseReceiptCountOutputType without action
   */
  export type ExpenseReceiptCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseReceiptItemWhereInput
  }


  /**
   * Count Type ExpenseProductCountOutputType
   */

  export type ExpenseProductCountOutputType = {
    receipt_items: number
  }

  export type ExpenseProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt_items?: boolean | ExpenseProductCountOutputTypeCountReceipt_itemsArgs
  }

  // Custom InputTypes
  /**
   * ExpenseProductCountOutputType without action
   */
  export type ExpenseProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProductCountOutputType
     */
    select?: ExpenseProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseProductCountOutputType without action
   */
  export type ExpenseProductCountOutputTypeCountReceipt_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseReceiptItemWhereInput
  }


  /**
   * Count Type MuscleGroupCountOutputType
   */

  export type MuscleGroupCountOutputType = {
    exercises: number
  }

  export type MuscleGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | MuscleGroupCountOutputTypeCountExercisesArgs
  }

  // Custom InputTypes
  /**
   * MuscleGroupCountOutputType without action
   */
  export type MuscleGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroupCountOutputType
     */
    select?: MuscleGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MuscleGroupCountOutputType without action
   */
  export type MuscleGroupCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    entries: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | ExerciseCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutEntryWhereInput
  }


  /**
   * Count Type WorkoutCountOutputType
   */

  export type WorkoutCountOutputType = {
    entries: number
  }

  export type WorkoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | WorkoutCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutCountOutputType
     */
    select?: WorkoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutEntryWhereInput
  }


  /**
   * Count Type WorkoutEntryCountOutputType
   */

  export type WorkoutEntryCountOutputType = {
    sets: number
  }

  export type WorkoutEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sets?: boolean | WorkoutEntryCountOutputTypeCountSetsArgs
  }

  // Custom InputTypes
  /**
   * WorkoutEntryCountOutputType without action
   */
  export type WorkoutEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntryCountOutputType
     */
    select?: WorkoutEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkoutEntryCountOutputType without action
   */
  export type WorkoutEntryCountOutputTypeCountSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutSetWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    phone: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    role: $Enums.AuthRole | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    phone: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    role: $Enums.AuthRole | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    uuid: number
    email: number
    phone: number
    password: number
    first_name: number
    last_name: number
    role: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phone?: true
    password?: true
    first_name?: true
    last_name?: true
    role?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phone?: true
    password?: true
    first_name?: true
    last_name?: true
    role?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phone?: true
    password?: true
    first_name?: true
    last_name?: true
    role?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    uuid: string
    email: string
    phone: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    activities?: boolean | User$activitiesArgs<ExtArgs>
    schedule_slots?: boolean | User$schedule_slotsArgs<ExtArgs>
    activity_schedules?: boolean | User$activity_schedulesArgs<ExtArgs>
    activity_logs?: boolean | User$activity_logsArgs<ExtArgs>
    activity_occurrences?: boolean | User$activity_occurrencesArgs<ExtArgs>
    expense_accounts?: boolean | User$expense_accountsArgs<ExtArgs>
    expense_entries?: boolean | User$expense_entriesArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    subcategories?: boolean | User$subcategoriesArgs<ExtArgs>
    expense_receipts?: boolean | User$expense_receiptsArgs<ExtArgs>
    expense_stores?: boolean | User$expense_storesArgs<ExtArgs>
    expense_products?: boolean | User$expense_productsArgs<ExtArgs>
    muscle_groups?: boolean | User$muscle_groupsArgs<ExtArgs>
    exercises?: boolean | User$exercisesArgs<ExtArgs>
    workouts?: boolean | User$workoutsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    uuid?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "email" | "phone" | "password" | "first_name" | "last_name" | "role" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | User$activitiesArgs<ExtArgs>
    schedule_slots?: boolean | User$schedule_slotsArgs<ExtArgs>
    activity_schedules?: boolean | User$activity_schedulesArgs<ExtArgs>
    activity_logs?: boolean | User$activity_logsArgs<ExtArgs>
    activity_occurrences?: boolean | User$activity_occurrencesArgs<ExtArgs>
    expense_accounts?: boolean | User$expense_accountsArgs<ExtArgs>
    expense_entries?: boolean | User$expense_entriesArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    subcategories?: boolean | User$subcategoriesArgs<ExtArgs>
    expense_receipts?: boolean | User$expense_receiptsArgs<ExtArgs>
    expense_stores?: boolean | User$expense_storesArgs<ExtArgs>
    expense_products?: boolean | User$expense_productsArgs<ExtArgs>
    muscle_groups?: boolean | User$muscle_groupsArgs<ExtArgs>
    exercises?: boolean | User$exercisesArgs<ExtArgs>
    workouts?: boolean | User$workoutsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      schedule_slots: Prisma.$ScheduleSlotPayload<ExtArgs>[]
      activity_schedules: Prisma.$ActivitySchedulePayload<ExtArgs>[]
      activity_logs: Prisma.$ActivityLogPayload<ExtArgs>[]
      activity_occurrences: Prisma.$ActivityOccurrencePayload<ExtArgs>[]
      expense_accounts: Prisma.$ExpenseAccountPayload<ExtArgs>[]
      expense_entries: Prisma.$ExpenseEntryPayload<ExtArgs>[]
      categories: Prisma.$ExpenseCategoryPayload<ExtArgs>[]
      subcategories: Prisma.$ExpenseSubcategoryPayload<ExtArgs>[]
      expense_receipts: Prisma.$ExpenseReceiptPayload<ExtArgs>[]
      expense_stores: Prisma.$ExpenseStorePayload<ExtArgs>[]
      expense_products: Prisma.$ExpenseProductPayload<ExtArgs>[]
      muscle_groups: Prisma.$MuscleGroupPayload<ExtArgs>[]
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
      workouts: Prisma.$WorkoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      email: string
      phone: string | null
      password: string
      first_name: string
      last_name: string
      role: $Enums.AuthRole
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedule_slots<T extends User$schedule_slotsArgs<ExtArgs> = {}>(args?: Subset<T, User$schedule_slotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activity_schedules<T extends User$activity_schedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$activity_schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activity_logs<T extends User$activity_logsArgs<ExtArgs> = {}>(args?: Subset<T, User$activity_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activity_occurrences<T extends User$activity_occurrencesArgs<ExtArgs> = {}>(args?: Subset<T, User$activity_occurrencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expense_accounts<T extends User$expense_accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$expense_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expense_entries<T extends User$expense_entriesArgs<ExtArgs> = {}>(args?: Subset<T, User$expense_entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends User$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends User$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expense_receipts<T extends User$expense_receiptsArgs<ExtArgs> = {}>(args?: Subset<T, User$expense_receiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expense_stores<T extends User$expense_storesArgs<ExtArgs> = {}>(args?: Subset<T, User$expense_storesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expense_products<T extends User$expense_productsArgs<ExtArgs> = {}>(args?: Subset<T, User$expense_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    muscle_groups<T extends User$muscle_groupsArgs<ExtArgs> = {}>(args?: Subset<T, User$muscle_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exercises<T extends User$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, User$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workouts<T extends User$workoutsArgs<ExtArgs> = {}>(args?: Subset<T, User$workoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly uuid: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'AuthRole'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.schedule_slots
   */
  export type User$schedule_slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    where?: ScheduleSlotWhereInput
    orderBy?: ScheduleSlotOrderByWithRelationInput | ScheduleSlotOrderByWithRelationInput[]
    cursor?: ScheduleSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleSlotScalarFieldEnum | ScheduleSlotScalarFieldEnum[]
  }

  /**
   * User.activity_schedules
   */
  export type User$activity_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    where?: ActivityScheduleWhereInput
    orderBy?: ActivityScheduleOrderByWithRelationInput | ActivityScheduleOrderByWithRelationInput[]
    cursor?: ActivityScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScheduleScalarFieldEnum | ActivityScheduleScalarFieldEnum[]
  }

  /**
   * User.activity_logs
   */
  export type User$activity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.activity_occurrences
   */
  export type User$activity_occurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    where?: ActivityOccurrenceWhereInput
    orderBy?: ActivityOccurrenceOrderByWithRelationInput | ActivityOccurrenceOrderByWithRelationInput[]
    cursor?: ActivityOccurrenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityOccurrenceScalarFieldEnum | ActivityOccurrenceScalarFieldEnum[]
  }

  /**
   * User.expense_accounts
   */
  export type User$expense_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    where?: ExpenseAccountWhereInput
    orderBy?: ExpenseAccountOrderByWithRelationInput | ExpenseAccountOrderByWithRelationInput[]
    cursor?: ExpenseAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseAccountScalarFieldEnum | ExpenseAccountScalarFieldEnum[]
  }

  /**
   * User.expense_entries
   */
  export type User$expense_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    where?: ExpenseEntryWhereInput
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    cursor?: ExpenseEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseEntryScalarFieldEnum | ExpenseEntryScalarFieldEnum[]
  }

  /**
   * User.categories
   */
  export type User$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    cursor?: ExpenseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * User.subcategories
   */
  export type User$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    where?: ExpenseSubcategoryWhereInput
    orderBy?: ExpenseSubcategoryOrderByWithRelationInput | ExpenseSubcategoryOrderByWithRelationInput[]
    cursor?: ExpenseSubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseSubcategoryScalarFieldEnum | ExpenseSubcategoryScalarFieldEnum[]
  }

  /**
   * User.expense_receipts
   */
  export type User$expense_receiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    where?: ExpenseReceiptWhereInput
    orderBy?: ExpenseReceiptOrderByWithRelationInput | ExpenseReceiptOrderByWithRelationInput[]
    cursor?: ExpenseReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseReceiptScalarFieldEnum | ExpenseReceiptScalarFieldEnum[]
  }

  /**
   * User.expense_stores
   */
  export type User$expense_storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    where?: ExpenseStoreWhereInput
    orderBy?: ExpenseStoreOrderByWithRelationInput | ExpenseStoreOrderByWithRelationInput[]
    cursor?: ExpenseStoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseStoreScalarFieldEnum | ExpenseStoreScalarFieldEnum[]
  }

  /**
   * User.expense_products
   */
  export type User$expense_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    where?: ExpenseProductWhereInput
    orderBy?: ExpenseProductOrderByWithRelationInput | ExpenseProductOrderByWithRelationInput[]
    cursor?: ExpenseProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseProductScalarFieldEnum | ExpenseProductScalarFieldEnum[]
  }

  /**
   * User.muscle_groups
   */
  export type User$muscle_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    where?: MuscleGroupWhereInput
    orderBy?: MuscleGroupOrderByWithRelationInput | MuscleGroupOrderByWithRelationInput[]
    cursor?: MuscleGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MuscleGroupScalarFieldEnum | MuscleGroupScalarFieldEnum[]
  }

  /**
   * User.exercises
   */
  export type User$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * User.workouts
   */
  export type User$workoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    where?: WorkoutWhereInput
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    cursor?: WorkoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    id: number | null
  }

  export type ActivitySumAggregateOutputType = {
    id: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    visible: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    visible: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    name: number
    description: number
    icon: number
    color: number
    visible: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    id?: true
  }

  export type ActivitySumAggregateInputType = {
    id?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    visible?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    visible?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    visible?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string
    name: string
    description: string | null
    icon: string | null
    color: string | null
    visible: boolean
    created_at: Date
    updated_at: Date
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    visible?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule_slots?: boolean | Activity$schedule_slotsArgs<ExtArgs>
    activity_schedules?: boolean | Activity$activity_schedulesArgs<ExtArgs>
    activity_logs?: boolean | Activity$activity_logsArgs<ExtArgs>
    activity_occurrences?: boolean | Activity$activity_occurrencesArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    visible?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    visible?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    visible?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "name" | "description" | "icon" | "color" | "visible" | "created_at" | "updated_at", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule_slots?: boolean | Activity$schedule_slotsArgs<ExtArgs>
    activity_schedules?: boolean | Activity$activity_schedulesArgs<ExtArgs>
    activity_logs?: boolean | Activity$activity_logsArgs<ExtArgs>
    activity_occurrences?: boolean | Activity$activity_occurrencesArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      schedule_slots: Prisma.$ScheduleSlotPayload<ExtArgs>[]
      activity_schedules: Prisma.$ActivitySchedulePayload<ExtArgs>[]
      activity_logs: Prisma.$ActivityLogPayload<ExtArgs>[]
      activity_occurrences: Prisma.$ActivityOccurrencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string
      name: string
      description: string | null
      icon: string | null
      color: string | null
      visible: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedule_slots<T extends Activity$schedule_slotsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$schedule_slotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activity_schedules<T extends Activity$activity_schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Activity$activity_schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activity_logs<T extends Activity$activity_logsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$activity_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activity_occurrences<T extends Activity$activity_occurrencesArgs<ExtArgs> = {}>(args?: Subset<T, Activity$activity_occurrencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'Int'>
    readonly uuid: FieldRef<"Activity", 'String'>
    readonly user_uuid: FieldRef<"Activity", 'String'>
    readonly name: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly icon: FieldRef<"Activity", 'String'>
    readonly color: FieldRef<"Activity", 'String'>
    readonly visible: FieldRef<"Activity", 'Boolean'>
    readonly created_at: FieldRef<"Activity", 'DateTime'>
    readonly updated_at: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.schedule_slots
   */
  export type Activity$schedule_slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    where?: ScheduleSlotWhereInput
    orderBy?: ScheduleSlotOrderByWithRelationInput | ScheduleSlotOrderByWithRelationInput[]
    cursor?: ScheduleSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleSlotScalarFieldEnum | ScheduleSlotScalarFieldEnum[]
  }

  /**
   * Activity.activity_schedules
   */
  export type Activity$activity_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    where?: ActivityScheduleWhereInput
    orderBy?: ActivityScheduleOrderByWithRelationInput | ActivityScheduleOrderByWithRelationInput[]
    cursor?: ActivityScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScheduleScalarFieldEnum | ActivityScheduleScalarFieldEnum[]
  }

  /**
   * Activity.activity_logs
   */
  export type Activity$activity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Activity.activity_occurrences
   */
  export type Activity$activity_occurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    where?: ActivityOccurrenceWhereInput
    orderBy?: ActivityOccurrenceOrderByWithRelationInput | ActivityOccurrenceOrderByWithRelationInput[]
    cursor?: ActivityOccurrenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityOccurrenceScalarFieldEnum | ActivityOccurrenceScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleSlot
   */

  export type AggregateScheduleSlot = {
    _count: ScheduleSlotCountAggregateOutputType | null
    _avg: ScheduleSlotAvgAggregateOutputType | null
    _sum: ScheduleSlotSumAggregateOutputType | null
    _min: ScheduleSlotMinAggregateOutputType | null
    _max: ScheduleSlotMaxAggregateOutputType | null
  }

  export type ScheduleSlotAvgAggregateOutputType = {
    id: number | null
  }

  export type ScheduleSlotSumAggregateOutputType = {
    id: number | null
  }

  export type ScheduleSlotMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    activity_uuid: string | null
    day: $Enums.ScheduleDay | null
    start_time: string | null
    end_time: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ScheduleSlotMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    activity_uuid: string | null
    day: $Enums.ScheduleDay | null
    start_time: string | null
    end_time: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ScheduleSlotCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    activity_uuid: number
    day: number
    start_time: number
    end_time: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ScheduleSlotAvgAggregateInputType = {
    id?: true
  }

  export type ScheduleSlotSumAggregateInputType = {
    id?: true
  }

  export type ScheduleSlotMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    day?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
  }

  export type ScheduleSlotMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    day?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
  }

  export type ScheduleSlotCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    day?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ScheduleSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleSlot to aggregate.
     */
    where?: ScheduleSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleSlots to fetch.
     */
    orderBy?: ScheduleSlotOrderByWithRelationInput | ScheduleSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleSlots
    **/
    _count?: true | ScheduleSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleSlotMaxAggregateInputType
  }

  export type GetScheduleSlotAggregateType<T extends ScheduleSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleSlot[P]>
      : GetScalarType<T[P], AggregateScheduleSlot[P]>
  }




  export type ScheduleSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleSlotWhereInput
    orderBy?: ScheduleSlotOrderByWithAggregationInput | ScheduleSlotOrderByWithAggregationInput[]
    by: ScheduleSlotScalarFieldEnum[] | ScheduleSlotScalarFieldEnum
    having?: ScheduleSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleSlotCountAggregateInputType | true
    _avg?: ScheduleSlotAvgAggregateInputType
    _sum?: ScheduleSlotSumAggregateInputType
    _min?: ScheduleSlotMinAggregateInputType
    _max?: ScheduleSlotMaxAggregateInputType
  }

  export type ScheduleSlotGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string
    activity_uuid: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at: Date
    updated_at: Date
    _count: ScheduleSlotCountAggregateOutputType | null
    _avg: ScheduleSlotAvgAggregateOutputType | null
    _sum: ScheduleSlotSumAggregateOutputType | null
    _min: ScheduleSlotMinAggregateOutputType | null
    _max: ScheduleSlotMaxAggregateOutputType | null
  }

  type GetScheduleSlotGroupByPayload<T extends ScheduleSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleSlotGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleSlotGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    day?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleSlot"]>

  export type ScheduleSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    day?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleSlot"]>

  export type ScheduleSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    day?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleSlot"]>

  export type ScheduleSlotSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    day?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ScheduleSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "activity_uuid" | "day" | "start_time" | "end_time" | "created_at" | "updated_at", ExtArgs["result"]["scheduleSlot"]>
  export type ScheduleSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }
  export type ScheduleSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }
  export type ScheduleSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }

  export type $ScheduleSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleSlot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      activity: Prisma.$ActivityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string
      activity_uuid: string
      day: $Enums.ScheduleDay
      start_time: string
      end_time: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["scheduleSlot"]>
    composites: {}
  }

  type ScheduleSlotGetPayload<S extends boolean | null | undefined | ScheduleSlotDefaultArgs> = $Result.GetResult<Prisma.$ScheduleSlotPayload, S>

  type ScheduleSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleSlotCountAggregateInputType | true
    }

  export interface ScheduleSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleSlot'], meta: { name: 'ScheduleSlot' } }
    /**
     * Find zero or one ScheduleSlot that matches the filter.
     * @param {ScheduleSlotFindUniqueArgs} args - Arguments to find a ScheduleSlot
     * @example
     * // Get one ScheduleSlot
     * const scheduleSlot = await prisma.scheduleSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleSlotFindUniqueArgs>(args: SelectSubset<T, ScheduleSlotFindUniqueArgs<ExtArgs>>): Prisma__ScheduleSlotClient<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleSlotFindUniqueOrThrowArgs} args - Arguments to find a ScheduleSlot
     * @example
     * // Get one ScheduleSlot
     * const scheduleSlot = await prisma.scheduleSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleSlotClient<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleSlotFindFirstArgs} args - Arguments to find a ScheduleSlot
     * @example
     * // Get one ScheduleSlot
     * const scheduleSlot = await prisma.scheduleSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleSlotFindFirstArgs>(args?: SelectSubset<T, ScheduleSlotFindFirstArgs<ExtArgs>>): Prisma__ScheduleSlotClient<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleSlotFindFirstOrThrowArgs} args - Arguments to find a ScheduleSlot
     * @example
     * // Get one ScheduleSlot
     * const scheduleSlot = await prisma.scheduleSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleSlotClient<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleSlots
     * const scheduleSlots = await prisma.scheduleSlot.findMany()
     * 
     * // Get first 10 ScheduleSlots
     * const scheduleSlots = await prisma.scheduleSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleSlotWithIdOnly = await prisma.scheduleSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleSlotFindManyArgs>(args?: SelectSubset<T, ScheduleSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleSlot.
     * @param {ScheduleSlotCreateArgs} args - Arguments to create a ScheduleSlot.
     * @example
     * // Create one ScheduleSlot
     * const ScheduleSlot = await prisma.scheduleSlot.create({
     *   data: {
     *     // ... data to create a ScheduleSlot
     *   }
     * })
     * 
     */
    create<T extends ScheduleSlotCreateArgs>(args: SelectSubset<T, ScheduleSlotCreateArgs<ExtArgs>>): Prisma__ScheduleSlotClient<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleSlots.
     * @param {ScheduleSlotCreateManyArgs} args - Arguments to create many ScheduleSlots.
     * @example
     * // Create many ScheduleSlots
     * const scheduleSlot = await prisma.scheduleSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleSlotCreateManyArgs>(args?: SelectSubset<T, ScheduleSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleSlots and returns the data saved in the database.
     * @param {ScheduleSlotCreateManyAndReturnArgs} args - Arguments to create many ScheduleSlots.
     * @example
     * // Create many ScheduleSlots
     * const scheduleSlot = await prisma.scheduleSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleSlots and only return the `id`
     * const scheduleSlotWithIdOnly = await prisma.scheduleSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleSlot.
     * @param {ScheduleSlotDeleteArgs} args - Arguments to delete one ScheduleSlot.
     * @example
     * // Delete one ScheduleSlot
     * const ScheduleSlot = await prisma.scheduleSlot.delete({
     *   where: {
     *     // ... filter to delete one ScheduleSlot
     *   }
     * })
     * 
     */
    delete<T extends ScheduleSlotDeleteArgs>(args: SelectSubset<T, ScheduleSlotDeleteArgs<ExtArgs>>): Prisma__ScheduleSlotClient<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleSlot.
     * @param {ScheduleSlotUpdateArgs} args - Arguments to update one ScheduleSlot.
     * @example
     * // Update one ScheduleSlot
     * const scheduleSlot = await prisma.scheduleSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleSlotUpdateArgs>(args: SelectSubset<T, ScheduleSlotUpdateArgs<ExtArgs>>): Prisma__ScheduleSlotClient<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleSlots.
     * @param {ScheduleSlotDeleteManyArgs} args - Arguments to filter ScheduleSlots to delete.
     * @example
     * // Delete a few ScheduleSlots
     * const { count } = await prisma.scheduleSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleSlotDeleteManyArgs>(args?: SelectSubset<T, ScheduleSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleSlots
     * const scheduleSlot = await prisma.scheduleSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleSlotUpdateManyArgs>(args: SelectSubset<T, ScheduleSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleSlots and returns the data updated in the database.
     * @param {ScheduleSlotUpdateManyAndReturnArgs} args - Arguments to update many ScheduleSlots.
     * @example
     * // Update many ScheduleSlots
     * const scheduleSlot = await prisma.scheduleSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleSlots and only return the `id`
     * const scheduleSlotWithIdOnly = await prisma.scheduleSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleSlot.
     * @param {ScheduleSlotUpsertArgs} args - Arguments to update or create a ScheduleSlot.
     * @example
     * // Update or create a ScheduleSlot
     * const scheduleSlot = await prisma.scheduleSlot.upsert({
     *   create: {
     *     // ... data to create a ScheduleSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleSlot we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleSlotUpsertArgs>(args: SelectSubset<T, ScheduleSlotUpsertArgs<ExtArgs>>): Prisma__ScheduleSlotClient<$Result.GetResult<Prisma.$ScheduleSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleSlotCountArgs} args - Arguments to filter ScheduleSlots to count.
     * @example
     * // Count the number of ScheduleSlots
     * const count = await prisma.scheduleSlot.count({
     *   where: {
     *     // ... the filter for the ScheduleSlots we want to count
     *   }
     * })
    **/
    count<T extends ScheduleSlotCountArgs>(
      args?: Subset<T, ScheduleSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleSlotAggregateArgs>(args: Subset<T, ScheduleSlotAggregateArgs>): Prisma.PrismaPromise<GetScheduleSlotAggregateType<T>>

    /**
     * Group by ScheduleSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleSlotGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleSlot model
   */
  readonly fields: ScheduleSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleSlot model
   */
  interface ScheduleSlotFieldRefs {
    readonly id: FieldRef<"ScheduleSlot", 'Int'>
    readonly uuid: FieldRef<"ScheduleSlot", 'String'>
    readonly user_uuid: FieldRef<"ScheduleSlot", 'String'>
    readonly activity_uuid: FieldRef<"ScheduleSlot", 'String'>
    readonly day: FieldRef<"ScheduleSlot", 'ScheduleDay'>
    readonly start_time: FieldRef<"ScheduleSlot", 'String'>
    readonly end_time: FieldRef<"ScheduleSlot", 'String'>
    readonly created_at: FieldRef<"ScheduleSlot", 'DateTime'>
    readonly updated_at: FieldRef<"ScheduleSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleSlot findUnique
   */
  export type ScheduleSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleSlot to fetch.
     */
    where: ScheduleSlotWhereUniqueInput
  }

  /**
   * ScheduleSlot findUniqueOrThrow
   */
  export type ScheduleSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleSlot to fetch.
     */
    where: ScheduleSlotWhereUniqueInput
  }

  /**
   * ScheduleSlot findFirst
   */
  export type ScheduleSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleSlot to fetch.
     */
    where?: ScheduleSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleSlots to fetch.
     */
    orderBy?: ScheduleSlotOrderByWithRelationInput | ScheduleSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleSlots.
     */
    cursor?: ScheduleSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleSlots.
     */
    distinct?: ScheduleSlotScalarFieldEnum | ScheduleSlotScalarFieldEnum[]
  }

  /**
   * ScheduleSlot findFirstOrThrow
   */
  export type ScheduleSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleSlot to fetch.
     */
    where?: ScheduleSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleSlots to fetch.
     */
    orderBy?: ScheduleSlotOrderByWithRelationInput | ScheduleSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleSlots.
     */
    cursor?: ScheduleSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleSlots.
     */
    distinct?: ScheduleSlotScalarFieldEnum | ScheduleSlotScalarFieldEnum[]
  }

  /**
   * ScheduleSlot findMany
   */
  export type ScheduleSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleSlots to fetch.
     */
    where?: ScheduleSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleSlots to fetch.
     */
    orderBy?: ScheduleSlotOrderByWithRelationInput | ScheduleSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleSlots.
     */
    cursor?: ScheduleSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleSlots.
     */
    skip?: number
    distinct?: ScheduleSlotScalarFieldEnum | ScheduleSlotScalarFieldEnum[]
  }

  /**
   * ScheduleSlot create
   */
  export type ScheduleSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleSlot.
     */
    data: XOR<ScheduleSlotCreateInput, ScheduleSlotUncheckedCreateInput>
  }

  /**
   * ScheduleSlot createMany
   */
  export type ScheduleSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleSlots.
     */
    data: ScheduleSlotCreateManyInput | ScheduleSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleSlot createManyAndReturn
   */
  export type ScheduleSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleSlots.
     */
    data: ScheduleSlotCreateManyInput | ScheduleSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleSlot update
   */
  export type ScheduleSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleSlot.
     */
    data: XOR<ScheduleSlotUpdateInput, ScheduleSlotUncheckedUpdateInput>
    /**
     * Choose, which ScheduleSlot to update.
     */
    where: ScheduleSlotWhereUniqueInput
  }

  /**
   * ScheduleSlot updateMany
   */
  export type ScheduleSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleSlots.
     */
    data: XOR<ScheduleSlotUpdateManyMutationInput, ScheduleSlotUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleSlots to update
     */
    where?: ScheduleSlotWhereInput
    /**
     * Limit how many ScheduleSlots to update.
     */
    limit?: number
  }

  /**
   * ScheduleSlot updateManyAndReturn
   */
  export type ScheduleSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleSlots.
     */
    data: XOR<ScheduleSlotUpdateManyMutationInput, ScheduleSlotUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleSlots to update
     */
    where?: ScheduleSlotWhereInput
    /**
     * Limit how many ScheduleSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleSlot upsert
   */
  export type ScheduleSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleSlot to update in case it exists.
     */
    where: ScheduleSlotWhereUniqueInput
    /**
     * In case the ScheduleSlot found by the `where` argument doesn't exist, create a new ScheduleSlot with this data.
     */
    create: XOR<ScheduleSlotCreateInput, ScheduleSlotUncheckedCreateInput>
    /**
     * In case the ScheduleSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleSlotUpdateInput, ScheduleSlotUncheckedUpdateInput>
  }

  /**
   * ScheduleSlot delete
   */
  export type ScheduleSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
    /**
     * Filter which ScheduleSlot to delete.
     */
    where: ScheduleSlotWhereUniqueInput
  }

  /**
   * ScheduleSlot deleteMany
   */
  export type ScheduleSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleSlots to delete
     */
    where?: ScheduleSlotWhereInput
    /**
     * Limit how many ScheduleSlots to delete.
     */
    limit?: number
  }

  /**
   * ScheduleSlot without action
   */
  export type ScheduleSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleSlot
     */
    select?: ScheduleSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleSlot
     */
    omit?: ScheduleSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleSlotInclude<ExtArgs> | null
  }


  /**
   * Model ActivitySchedule
   */

  export type AggregateActivitySchedule = {
    _count: ActivityScheduleCountAggregateOutputType | null
    _avg: ActivityScheduleAvgAggregateOutputType | null
    _sum: ActivityScheduleSumAggregateOutputType | null
    _min: ActivityScheduleMinAggregateOutputType | null
    _max: ActivityScheduleMaxAggregateOutputType | null
  }

  export type ActivityScheduleAvgAggregateOutputType = {
    id: number | null
    interval_days: number | null
    frequency_value: number | null
    target_value: number | null
  }

  export type ActivityScheduleSumAggregateOutputType = {
    id: number | null
    interval_days: number | null
    frequency_value: number | null
    target_value: number | null
  }

  export type ActivityScheduleMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    activity_uuid: string | null
    valid_from: Date | null
    valid_until: Date | null
    repeat_type: $Enums.ActivityRepeatType | null
    interval_days: number | null
    time_of_day: string | null
    frequency_value: number | null
    frequency_period: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType | null
    target_value: number | null
    target_unit: $Enums.ActivityTargetUnit | null
    target_unit_label: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityScheduleMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    activity_uuid: string | null
    valid_from: Date | null
    valid_until: Date | null
    repeat_type: $Enums.ActivityRepeatType | null
    interval_days: number | null
    time_of_day: string | null
    frequency_value: number | null
    frequency_period: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType | null
    target_value: number | null
    target_unit: $Enums.ActivityTargetUnit | null
    target_unit_label: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityScheduleCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    activity_uuid: number
    valid_from: number
    valid_until: number
    repeat_type: number
    interval_days: number
    time_of_day: number
    frequency_value: number
    frequency_period: number
    target_type: number
    target_value: number
    target_unit: number
    target_unit_label: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivityScheduleAvgAggregateInputType = {
    id?: true
    interval_days?: true
    frequency_value?: true
    target_value?: true
  }

  export type ActivityScheduleSumAggregateInputType = {
    id?: true
    interval_days?: true
    frequency_value?: true
    target_value?: true
  }

  export type ActivityScheduleMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    valid_from?: true
    valid_until?: true
    repeat_type?: true
    interval_days?: true
    time_of_day?: true
    frequency_value?: true
    frequency_period?: true
    target_type?: true
    target_value?: true
    target_unit?: true
    target_unit_label?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityScheduleMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    valid_from?: true
    valid_until?: true
    repeat_type?: true
    interval_days?: true
    time_of_day?: true
    frequency_value?: true
    frequency_period?: true
    target_type?: true
    target_value?: true
    target_unit?: true
    target_unit_label?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityScheduleCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    valid_from?: true
    valid_until?: true
    repeat_type?: true
    interval_days?: true
    time_of_day?: true
    frequency_value?: true
    frequency_period?: true
    target_type?: true
    target_value?: true
    target_unit?: true
    target_unit_label?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivityScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivitySchedule to aggregate.
     */
    where?: ActivityScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivitySchedules to fetch.
     */
    orderBy?: ActivityScheduleOrderByWithRelationInput | ActivityScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivitySchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivitySchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivitySchedules
    **/
    _count?: true | ActivityScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityScheduleMaxAggregateInputType
  }

  export type GetActivityScheduleAggregateType<T extends ActivityScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateActivitySchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivitySchedule[P]>
      : GetScalarType<T[P], AggregateActivitySchedule[P]>
  }




  export type ActivityScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityScheduleWhereInput
    orderBy?: ActivityScheduleOrderByWithAggregationInput | ActivityScheduleOrderByWithAggregationInput[]
    by: ActivityScheduleScalarFieldEnum[] | ActivityScheduleScalarFieldEnum
    having?: ActivityScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityScheduleCountAggregateInputType | true
    _avg?: ActivityScheduleAvgAggregateInputType
    _sum?: ActivityScheduleSumAggregateInputType
    _min?: ActivityScheduleMinAggregateInputType
    _max?: ActivityScheduleMaxAggregateInputType
  }

  export type ActivityScheduleGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string
    activity_uuid: string
    valid_from: Date
    valid_until: Date | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days: number | null
    time_of_day: string | null
    frequency_value: number | null
    frequency_period: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value: number | null
    target_unit: $Enums.ActivityTargetUnit | null
    target_unit_label: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ActivityScheduleCountAggregateOutputType | null
    _avg: ActivityScheduleAvgAggregateOutputType | null
    _sum: ActivityScheduleSumAggregateOutputType | null
    _min: ActivityScheduleMinAggregateOutputType | null
    _max: ActivityScheduleMaxAggregateOutputType | null
  }

  type GetActivityScheduleGroupByPayload<T extends ActivityScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ActivityScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    valid_from?: boolean
    valid_until?: boolean
    repeat_type?: boolean
    interval_days?: boolean
    time_of_day?: boolean
    frequency_value?: boolean
    frequency_period?: boolean
    target_type?: boolean
    target_value?: boolean
    target_unit?: boolean
    target_unit_label?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    weekdays?: boolean | ActivitySchedule$weekdaysArgs<ExtArgs>
    specific_dates?: boolean | ActivitySchedule$specific_datesArgs<ExtArgs>
    occurrences?: boolean | ActivitySchedule$occurrencesArgs<ExtArgs>
    logs?: boolean | ActivitySchedule$logsArgs<ExtArgs>
    _count?: boolean | ActivityScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activitySchedule"]>

  export type ActivityScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    valid_from?: boolean
    valid_until?: boolean
    repeat_type?: boolean
    interval_days?: boolean
    time_of_day?: boolean
    frequency_value?: boolean
    frequency_period?: boolean
    target_type?: boolean
    target_value?: boolean
    target_unit?: boolean
    target_unit_label?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activitySchedule"]>

  export type ActivityScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    valid_from?: boolean
    valid_until?: boolean
    repeat_type?: boolean
    interval_days?: boolean
    time_of_day?: boolean
    frequency_value?: boolean
    frequency_period?: boolean
    target_type?: boolean
    target_value?: boolean
    target_unit?: boolean
    target_unit_label?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activitySchedule"]>

  export type ActivityScheduleSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    valid_from?: boolean
    valid_until?: boolean
    repeat_type?: boolean
    interval_days?: boolean
    time_of_day?: boolean
    frequency_value?: boolean
    frequency_period?: boolean
    target_type?: boolean
    target_value?: boolean
    target_unit?: boolean
    target_unit_label?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ActivityScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "activity_uuid" | "valid_from" | "valid_until" | "repeat_type" | "interval_days" | "time_of_day" | "frequency_value" | "frequency_period" | "target_type" | "target_value" | "target_unit" | "target_unit_label" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["activitySchedule"]>
  export type ActivityScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    weekdays?: boolean | ActivitySchedule$weekdaysArgs<ExtArgs>
    specific_dates?: boolean | ActivitySchedule$specific_datesArgs<ExtArgs>
    occurrences?: boolean | ActivitySchedule$occurrencesArgs<ExtArgs>
    logs?: boolean | ActivitySchedule$logsArgs<ExtArgs>
    _count?: boolean | ActivityScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivitySchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivitySchedule"
    objects: {
      activity: Prisma.$ActivityPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      weekdays: Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>[]
      specific_dates: Prisma.$ActivityScheduleDatePayload<ExtArgs>[]
      occurrences: Prisma.$ActivityOccurrencePayload<ExtArgs>[]
      logs: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string
      activity_uuid: string
      valid_from: Date
      valid_until: Date | null
      repeat_type: $Enums.ActivityRepeatType
      interval_days: number | null
      time_of_day: string | null
      frequency_value: number | null
      frequency_period: $Enums.FrequencyPeriod | null
      target_type: $Enums.ActivityTargetType
      target_value: number | null
      target_unit: $Enums.ActivityTargetUnit | null
      target_unit_label: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["activitySchedule"]>
    composites: {}
  }

  type ActivityScheduleGetPayload<S extends boolean | null | undefined | ActivityScheduleDefaultArgs> = $Result.GetResult<Prisma.$ActivitySchedulePayload, S>

  type ActivityScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityScheduleCountAggregateInputType | true
    }

  export interface ActivityScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivitySchedule'], meta: { name: 'ActivitySchedule' } }
    /**
     * Find zero or one ActivitySchedule that matches the filter.
     * @param {ActivityScheduleFindUniqueArgs} args - Arguments to find a ActivitySchedule
     * @example
     * // Get one ActivitySchedule
     * const activitySchedule = await prisma.activitySchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityScheduleFindUniqueArgs>(args: SelectSubset<T, ActivityScheduleFindUniqueArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivitySchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityScheduleFindUniqueOrThrowArgs} args - Arguments to find a ActivitySchedule
     * @example
     * // Get one ActivitySchedule
     * const activitySchedule = await prisma.activitySchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivitySchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleFindFirstArgs} args - Arguments to find a ActivitySchedule
     * @example
     * // Get one ActivitySchedule
     * const activitySchedule = await prisma.activitySchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityScheduleFindFirstArgs>(args?: SelectSubset<T, ActivityScheduleFindFirstArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivitySchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleFindFirstOrThrowArgs} args - Arguments to find a ActivitySchedule
     * @example
     * // Get one ActivitySchedule
     * const activitySchedule = await prisma.activitySchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivitySchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivitySchedules
     * const activitySchedules = await prisma.activitySchedule.findMany()
     * 
     * // Get first 10 ActivitySchedules
     * const activitySchedules = await prisma.activitySchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityScheduleWithIdOnly = await prisma.activitySchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityScheduleFindManyArgs>(args?: SelectSubset<T, ActivityScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivitySchedule.
     * @param {ActivityScheduleCreateArgs} args - Arguments to create a ActivitySchedule.
     * @example
     * // Create one ActivitySchedule
     * const ActivitySchedule = await prisma.activitySchedule.create({
     *   data: {
     *     // ... data to create a ActivitySchedule
     *   }
     * })
     * 
     */
    create<T extends ActivityScheduleCreateArgs>(args: SelectSubset<T, ActivityScheduleCreateArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivitySchedules.
     * @param {ActivityScheduleCreateManyArgs} args - Arguments to create many ActivitySchedules.
     * @example
     * // Create many ActivitySchedules
     * const activitySchedule = await prisma.activitySchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityScheduleCreateManyArgs>(args?: SelectSubset<T, ActivityScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivitySchedules and returns the data saved in the database.
     * @param {ActivityScheduleCreateManyAndReturnArgs} args - Arguments to create many ActivitySchedules.
     * @example
     * // Create many ActivitySchedules
     * const activitySchedule = await prisma.activitySchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivitySchedules and only return the `id`
     * const activityScheduleWithIdOnly = await prisma.activitySchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivitySchedule.
     * @param {ActivityScheduleDeleteArgs} args - Arguments to delete one ActivitySchedule.
     * @example
     * // Delete one ActivitySchedule
     * const ActivitySchedule = await prisma.activitySchedule.delete({
     *   where: {
     *     // ... filter to delete one ActivitySchedule
     *   }
     * })
     * 
     */
    delete<T extends ActivityScheduleDeleteArgs>(args: SelectSubset<T, ActivityScheduleDeleteArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivitySchedule.
     * @param {ActivityScheduleUpdateArgs} args - Arguments to update one ActivitySchedule.
     * @example
     * // Update one ActivitySchedule
     * const activitySchedule = await prisma.activitySchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityScheduleUpdateArgs>(args: SelectSubset<T, ActivityScheduleUpdateArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivitySchedules.
     * @param {ActivityScheduleDeleteManyArgs} args - Arguments to filter ActivitySchedules to delete.
     * @example
     * // Delete a few ActivitySchedules
     * const { count } = await prisma.activitySchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityScheduleDeleteManyArgs>(args?: SelectSubset<T, ActivityScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivitySchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivitySchedules
     * const activitySchedule = await prisma.activitySchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityScheduleUpdateManyArgs>(args: SelectSubset<T, ActivityScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivitySchedules and returns the data updated in the database.
     * @param {ActivityScheduleUpdateManyAndReturnArgs} args - Arguments to update many ActivitySchedules.
     * @example
     * // Update many ActivitySchedules
     * const activitySchedule = await prisma.activitySchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivitySchedules and only return the `id`
     * const activityScheduleWithIdOnly = await prisma.activitySchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivitySchedule.
     * @param {ActivityScheduleUpsertArgs} args - Arguments to update or create a ActivitySchedule.
     * @example
     * // Update or create a ActivitySchedule
     * const activitySchedule = await prisma.activitySchedule.upsert({
     *   create: {
     *     // ... data to create a ActivitySchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivitySchedule we want to update
     *   }
     * })
     */
    upsert<T extends ActivityScheduleUpsertArgs>(args: SelectSubset<T, ActivityScheduleUpsertArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivitySchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleCountArgs} args - Arguments to filter ActivitySchedules to count.
     * @example
     * // Count the number of ActivitySchedules
     * const count = await prisma.activitySchedule.count({
     *   where: {
     *     // ... the filter for the ActivitySchedules we want to count
     *   }
     * })
    **/
    count<T extends ActivityScheduleCountArgs>(
      args?: Subset<T, ActivityScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivitySchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityScheduleAggregateArgs>(args: Subset<T, ActivityScheduleAggregateArgs>): Prisma.PrismaPromise<GetActivityScheduleAggregateType<T>>

    /**
     * Group by ActivitySchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ActivityScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivitySchedule model
   */
  readonly fields: ActivityScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivitySchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weekdays<T extends ActivitySchedule$weekdaysArgs<ExtArgs> = {}>(args?: Subset<T, ActivitySchedule$weekdaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specific_dates<T extends ActivitySchedule$specific_datesArgs<ExtArgs> = {}>(args?: Subset<T, ActivitySchedule$specific_datesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    occurrences<T extends ActivitySchedule$occurrencesArgs<ExtArgs> = {}>(args?: Subset<T, ActivitySchedule$occurrencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends ActivitySchedule$logsArgs<ExtArgs> = {}>(args?: Subset<T, ActivitySchedule$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivitySchedule model
   */
  interface ActivityScheduleFieldRefs {
    readonly id: FieldRef<"ActivitySchedule", 'Int'>
    readonly uuid: FieldRef<"ActivitySchedule", 'String'>
    readonly user_uuid: FieldRef<"ActivitySchedule", 'String'>
    readonly activity_uuid: FieldRef<"ActivitySchedule", 'String'>
    readonly valid_from: FieldRef<"ActivitySchedule", 'DateTime'>
    readonly valid_until: FieldRef<"ActivitySchedule", 'DateTime'>
    readonly repeat_type: FieldRef<"ActivitySchedule", 'ActivityRepeatType'>
    readonly interval_days: FieldRef<"ActivitySchedule", 'Int'>
    readonly time_of_day: FieldRef<"ActivitySchedule", 'String'>
    readonly frequency_value: FieldRef<"ActivitySchedule", 'Int'>
    readonly frequency_period: FieldRef<"ActivitySchedule", 'FrequencyPeriod'>
    readonly target_type: FieldRef<"ActivitySchedule", 'ActivityTargetType'>
    readonly target_value: FieldRef<"ActivitySchedule", 'Float'>
    readonly target_unit: FieldRef<"ActivitySchedule", 'ActivityTargetUnit'>
    readonly target_unit_label: FieldRef<"ActivitySchedule", 'String'>
    readonly is_active: FieldRef<"ActivitySchedule", 'Boolean'>
    readonly created_at: FieldRef<"ActivitySchedule", 'DateTime'>
    readonly updated_at: FieldRef<"ActivitySchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivitySchedule findUnique
   */
  export type ActivityScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ActivitySchedule to fetch.
     */
    where: ActivityScheduleWhereUniqueInput
  }

  /**
   * ActivitySchedule findUniqueOrThrow
   */
  export type ActivityScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ActivitySchedule to fetch.
     */
    where: ActivityScheduleWhereUniqueInput
  }

  /**
   * ActivitySchedule findFirst
   */
  export type ActivityScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ActivitySchedule to fetch.
     */
    where?: ActivityScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivitySchedules to fetch.
     */
    orderBy?: ActivityScheduleOrderByWithRelationInput | ActivityScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivitySchedules.
     */
    cursor?: ActivityScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivitySchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivitySchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivitySchedules.
     */
    distinct?: ActivityScheduleScalarFieldEnum | ActivityScheduleScalarFieldEnum[]
  }

  /**
   * ActivitySchedule findFirstOrThrow
   */
  export type ActivityScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ActivitySchedule to fetch.
     */
    where?: ActivityScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivitySchedules to fetch.
     */
    orderBy?: ActivityScheduleOrderByWithRelationInput | ActivityScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivitySchedules.
     */
    cursor?: ActivityScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivitySchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivitySchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivitySchedules.
     */
    distinct?: ActivityScheduleScalarFieldEnum | ActivityScheduleScalarFieldEnum[]
  }

  /**
   * ActivitySchedule findMany
   */
  export type ActivityScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ActivitySchedules to fetch.
     */
    where?: ActivityScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivitySchedules to fetch.
     */
    orderBy?: ActivityScheduleOrderByWithRelationInput | ActivityScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivitySchedules.
     */
    cursor?: ActivityScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivitySchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivitySchedules.
     */
    skip?: number
    distinct?: ActivityScheduleScalarFieldEnum | ActivityScheduleScalarFieldEnum[]
  }

  /**
   * ActivitySchedule create
   */
  export type ActivityScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivitySchedule.
     */
    data: XOR<ActivityScheduleCreateInput, ActivityScheduleUncheckedCreateInput>
  }

  /**
   * ActivitySchedule createMany
   */
  export type ActivityScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivitySchedules.
     */
    data: ActivityScheduleCreateManyInput | ActivityScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivitySchedule createManyAndReturn
   */
  export type ActivityScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many ActivitySchedules.
     */
    data: ActivityScheduleCreateManyInput | ActivityScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivitySchedule update
   */
  export type ActivityScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivitySchedule.
     */
    data: XOR<ActivityScheduleUpdateInput, ActivityScheduleUncheckedUpdateInput>
    /**
     * Choose, which ActivitySchedule to update.
     */
    where: ActivityScheduleWhereUniqueInput
  }

  /**
   * ActivitySchedule updateMany
   */
  export type ActivityScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivitySchedules.
     */
    data: XOR<ActivityScheduleUpdateManyMutationInput, ActivityScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ActivitySchedules to update
     */
    where?: ActivityScheduleWhereInput
    /**
     * Limit how many ActivitySchedules to update.
     */
    limit?: number
  }

  /**
   * ActivitySchedule updateManyAndReturn
   */
  export type ActivityScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * The data used to update ActivitySchedules.
     */
    data: XOR<ActivityScheduleUpdateManyMutationInput, ActivityScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ActivitySchedules to update
     */
    where?: ActivityScheduleWhereInput
    /**
     * Limit how many ActivitySchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivitySchedule upsert
   */
  export type ActivityScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivitySchedule to update in case it exists.
     */
    where: ActivityScheduleWhereUniqueInput
    /**
     * In case the ActivitySchedule found by the `where` argument doesn't exist, create a new ActivitySchedule with this data.
     */
    create: XOR<ActivityScheduleCreateInput, ActivityScheduleUncheckedCreateInput>
    /**
     * In case the ActivitySchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityScheduleUpdateInput, ActivityScheduleUncheckedUpdateInput>
  }

  /**
   * ActivitySchedule delete
   */
  export type ActivityScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
    /**
     * Filter which ActivitySchedule to delete.
     */
    where: ActivityScheduleWhereUniqueInput
  }

  /**
   * ActivitySchedule deleteMany
   */
  export type ActivityScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivitySchedules to delete
     */
    where?: ActivityScheduleWhereInput
    /**
     * Limit how many ActivitySchedules to delete.
     */
    limit?: number
  }

  /**
   * ActivitySchedule.weekdays
   */
  export type ActivitySchedule$weekdaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    where?: ActivityScheduleWeekdayWhereInput
    orderBy?: ActivityScheduleWeekdayOrderByWithRelationInput | ActivityScheduleWeekdayOrderByWithRelationInput[]
    cursor?: ActivityScheduleWeekdayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScheduleWeekdayScalarFieldEnum | ActivityScheduleWeekdayScalarFieldEnum[]
  }

  /**
   * ActivitySchedule.specific_dates
   */
  export type ActivitySchedule$specific_datesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    where?: ActivityScheduleDateWhereInput
    orderBy?: ActivityScheduleDateOrderByWithRelationInput | ActivityScheduleDateOrderByWithRelationInput[]
    cursor?: ActivityScheduleDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScheduleDateScalarFieldEnum | ActivityScheduleDateScalarFieldEnum[]
  }

  /**
   * ActivitySchedule.occurrences
   */
  export type ActivitySchedule$occurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    where?: ActivityOccurrenceWhereInput
    orderBy?: ActivityOccurrenceOrderByWithRelationInput | ActivityOccurrenceOrderByWithRelationInput[]
    cursor?: ActivityOccurrenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityOccurrenceScalarFieldEnum | ActivityOccurrenceScalarFieldEnum[]
  }

  /**
   * ActivitySchedule.logs
   */
  export type ActivitySchedule$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivitySchedule without action
   */
  export type ActivityScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitySchedule
     */
    select?: ActivityScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivitySchedule
     */
    omit?: ActivityScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ActivityScheduleWeekday
   */

  export type AggregateActivityScheduleWeekday = {
    _count: ActivityScheduleWeekdayCountAggregateOutputType | null
    _avg: ActivityScheduleWeekdayAvgAggregateOutputType | null
    _sum: ActivityScheduleWeekdaySumAggregateOutputType | null
    _min: ActivityScheduleWeekdayMinAggregateOutputType | null
    _max: ActivityScheduleWeekdayMaxAggregateOutputType | null
  }

  export type ActivityScheduleWeekdayAvgAggregateOutputType = {
    id: number | null
    weekday: number | null
  }

  export type ActivityScheduleWeekdaySumAggregateOutputType = {
    id: number | null
    weekday: number | null
  }

  export type ActivityScheduleWeekdayMinAggregateOutputType = {
    id: number | null
    schedule_uuid: string | null
    weekday: number | null
  }

  export type ActivityScheduleWeekdayMaxAggregateOutputType = {
    id: number | null
    schedule_uuid: string | null
    weekday: number | null
  }

  export type ActivityScheduleWeekdayCountAggregateOutputType = {
    id: number
    schedule_uuid: number
    weekday: number
    _all: number
  }


  export type ActivityScheduleWeekdayAvgAggregateInputType = {
    id?: true
    weekday?: true
  }

  export type ActivityScheduleWeekdaySumAggregateInputType = {
    id?: true
    weekday?: true
  }

  export type ActivityScheduleWeekdayMinAggregateInputType = {
    id?: true
    schedule_uuid?: true
    weekday?: true
  }

  export type ActivityScheduleWeekdayMaxAggregateInputType = {
    id?: true
    schedule_uuid?: true
    weekday?: true
  }

  export type ActivityScheduleWeekdayCountAggregateInputType = {
    id?: true
    schedule_uuid?: true
    weekday?: true
    _all?: true
  }

  export type ActivityScheduleWeekdayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityScheduleWeekday to aggregate.
     */
    where?: ActivityScheduleWeekdayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityScheduleWeekdays to fetch.
     */
    orderBy?: ActivityScheduleWeekdayOrderByWithRelationInput | ActivityScheduleWeekdayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityScheduleWeekdayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityScheduleWeekdays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityScheduleWeekdays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityScheduleWeekdays
    **/
    _count?: true | ActivityScheduleWeekdayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityScheduleWeekdayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityScheduleWeekdaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityScheduleWeekdayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityScheduleWeekdayMaxAggregateInputType
  }

  export type GetActivityScheduleWeekdayAggregateType<T extends ActivityScheduleWeekdayAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityScheduleWeekday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityScheduleWeekday[P]>
      : GetScalarType<T[P], AggregateActivityScheduleWeekday[P]>
  }




  export type ActivityScheduleWeekdayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityScheduleWeekdayWhereInput
    orderBy?: ActivityScheduleWeekdayOrderByWithAggregationInput | ActivityScheduleWeekdayOrderByWithAggregationInput[]
    by: ActivityScheduleWeekdayScalarFieldEnum[] | ActivityScheduleWeekdayScalarFieldEnum
    having?: ActivityScheduleWeekdayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityScheduleWeekdayCountAggregateInputType | true
    _avg?: ActivityScheduleWeekdayAvgAggregateInputType
    _sum?: ActivityScheduleWeekdaySumAggregateInputType
    _min?: ActivityScheduleWeekdayMinAggregateInputType
    _max?: ActivityScheduleWeekdayMaxAggregateInputType
  }

  export type ActivityScheduleWeekdayGroupByOutputType = {
    id: number
    schedule_uuid: string
    weekday: number
    _count: ActivityScheduleWeekdayCountAggregateOutputType | null
    _avg: ActivityScheduleWeekdayAvgAggregateOutputType | null
    _sum: ActivityScheduleWeekdaySumAggregateOutputType | null
    _min: ActivityScheduleWeekdayMinAggregateOutputType | null
    _max: ActivityScheduleWeekdayMaxAggregateOutputType | null
  }

  type GetActivityScheduleWeekdayGroupByPayload<T extends ActivityScheduleWeekdayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityScheduleWeekdayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityScheduleWeekdayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityScheduleWeekdayGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityScheduleWeekdayGroupByOutputType[P]>
        }
      >
    >


  export type ActivityScheduleWeekdaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schedule_uuid?: boolean
    weekday?: boolean
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityScheduleWeekday"]>

  export type ActivityScheduleWeekdaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schedule_uuid?: boolean
    weekday?: boolean
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityScheduleWeekday"]>

  export type ActivityScheduleWeekdaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schedule_uuid?: boolean
    weekday?: boolean
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityScheduleWeekday"]>

  export type ActivityScheduleWeekdaySelectScalar = {
    id?: boolean
    schedule_uuid?: boolean
    weekday?: boolean
  }

  export type ActivityScheduleWeekdayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schedule_uuid" | "weekday", ExtArgs["result"]["activityScheduleWeekday"]>
  export type ActivityScheduleWeekdayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }
  export type ActivityScheduleWeekdayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }
  export type ActivityScheduleWeekdayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }

  export type $ActivityScheduleWeekdayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityScheduleWeekday"
    objects: {
      schedule: Prisma.$ActivitySchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      schedule_uuid: string
      weekday: number
    }, ExtArgs["result"]["activityScheduleWeekday"]>
    composites: {}
  }

  type ActivityScheduleWeekdayGetPayload<S extends boolean | null | undefined | ActivityScheduleWeekdayDefaultArgs> = $Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload, S>

  type ActivityScheduleWeekdayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityScheduleWeekdayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityScheduleWeekdayCountAggregateInputType | true
    }

  export interface ActivityScheduleWeekdayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityScheduleWeekday'], meta: { name: 'ActivityScheduleWeekday' } }
    /**
     * Find zero or one ActivityScheduleWeekday that matches the filter.
     * @param {ActivityScheduleWeekdayFindUniqueArgs} args - Arguments to find a ActivityScheduleWeekday
     * @example
     * // Get one ActivityScheduleWeekday
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityScheduleWeekdayFindUniqueArgs>(args: SelectSubset<T, ActivityScheduleWeekdayFindUniqueArgs<ExtArgs>>): Prisma__ActivityScheduleWeekdayClient<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityScheduleWeekday that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityScheduleWeekdayFindUniqueOrThrowArgs} args - Arguments to find a ActivityScheduleWeekday
     * @example
     * // Get one ActivityScheduleWeekday
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityScheduleWeekdayFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityScheduleWeekdayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityScheduleWeekdayClient<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityScheduleWeekday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleWeekdayFindFirstArgs} args - Arguments to find a ActivityScheduleWeekday
     * @example
     * // Get one ActivityScheduleWeekday
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityScheduleWeekdayFindFirstArgs>(args?: SelectSubset<T, ActivityScheduleWeekdayFindFirstArgs<ExtArgs>>): Prisma__ActivityScheduleWeekdayClient<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityScheduleWeekday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleWeekdayFindFirstOrThrowArgs} args - Arguments to find a ActivityScheduleWeekday
     * @example
     * // Get one ActivityScheduleWeekday
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityScheduleWeekdayFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityScheduleWeekdayFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityScheduleWeekdayClient<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityScheduleWeekdays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleWeekdayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityScheduleWeekdays
     * const activityScheduleWeekdays = await prisma.activityScheduleWeekday.findMany()
     * 
     * // Get first 10 ActivityScheduleWeekdays
     * const activityScheduleWeekdays = await prisma.activityScheduleWeekday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityScheduleWeekdayWithIdOnly = await prisma.activityScheduleWeekday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityScheduleWeekdayFindManyArgs>(args?: SelectSubset<T, ActivityScheduleWeekdayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityScheduleWeekday.
     * @param {ActivityScheduleWeekdayCreateArgs} args - Arguments to create a ActivityScheduleWeekday.
     * @example
     * // Create one ActivityScheduleWeekday
     * const ActivityScheduleWeekday = await prisma.activityScheduleWeekday.create({
     *   data: {
     *     // ... data to create a ActivityScheduleWeekday
     *   }
     * })
     * 
     */
    create<T extends ActivityScheduleWeekdayCreateArgs>(args: SelectSubset<T, ActivityScheduleWeekdayCreateArgs<ExtArgs>>): Prisma__ActivityScheduleWeekdayClient<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityScheduleWeekdays.
     * @param {ActivityScheduleWeekdayCreateManyArgs} args - Arguments to create many ActivityScheduleWeekdays.
     * @example
     * // Create many ActivityScheduleWeekdays
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityScheduleWeekdayCreateManyArgs>(args?: SelectSubset<T, ActivityScheduleWeekdayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityScheduleWeekdays and returns the data saved in the database.
     * @param {ActivityScheduleWeekdayCreateManyAndReturnArgs} args - Arguments to create many ActivityScheduleWeekdays.
     * @example
     * // Create many ActivityScheduleWeekdays
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityScheduleWeekdays and only return the `id`
     * const activityScheduleWeekdayWithIdOnly = await prisma.activityScheduleWeekday.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityScheduleWeekdayCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityScheduleWeekdayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityScheduleWeekday.
     * @param {ActivityScheduleWeekdayDeleteArgs} args - Arguments to delete one ActivityScheduleWeekday.
     * @example
     * // Delete one ActivityScheduleWeekday
     * const ActivityScheduleWeekday = await prisma.activityScheduleWeekday.delete({
     *   where: {
     *     // ... filter to delete one ActivityScheduleWeekday
     *   }
     * })
     * 
     */
    delete<T extends ActivityScheduleWeekdayDeleteArgs>(args: SelectSubset<T, ActivityScheduleWeekdayDeleteArgs<ExtArgs>>): Prisma__ActivityScheduleWeekdayClient<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityScheduleWeekday.
     * @param {ActivityScheduleWeekdayUpdateArgs} args - Arguments to update one ActivityScheduleWeekday.
     * @example
     * // Update one ActivityScheduleWeekday
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityScheduleWeekdayUpdateArgs>(args: SelectSubset<T, ActivityScheduleWeekdayUpdateArgs<ExtArgs>>): Prisma__ActivityScheduleWeekdayClient<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityScheduleWeekdays.
     * @param {ActivityScheduleWeekdayDeleteManyArgs} args - Arguments to filter ActivityScheduleWeekdays to delete.
     * @example
     * // Delete a few ActivityScheduleWeekdays
     * const { count } = await prisma.activityScheduleWeekday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityScheduleWeekdayDeleteManyArgs>(args?: SelectSubset<T, ActivityScheduleWeekdayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityScheduleWeekdays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleWeekdayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityScheduleWeekdays
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityScheduleWeekdayUpdateManyArgs>(args: SelectSubset<T, ActivityScheduleWeekdayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityScheduleWeekdays and returns the data updated in the database.
     * @param {ActivityScheduleWeekdayUpdateManyAndReturnArgs} args - Arguments to update many ActivityScheduleWeekdays.
     * @example
     * // Update many ActivityScheduleWeekdays
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityScheduleWeekdays and only return the `id`
     * const activityScheduleWeekdayWithIdOnly = await prisma.activityScheduleWeekday.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityScheduleWeekdayUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityScheduleWeekdayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityScheduleWeekday.
     * @param {ActivityScheduleWeekdayUpsertArgs} args - Arguments to update or create a ActivityScheduleWeekday.
     * @example
     * // Update or create a ActivityScheduleWeekday
     * const activityScheduleWeekday = await prisma.activityScheduleWeekday.upsert({
     *   create: {
     *     // ... data to create a ActivityScheduleWeekday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityScheduleWeekday we want to update
     *   }
     * })
     */
    upsert<T extends ActivityScheduleWeekdayUpsertArgs>(args: SelectSubset<T, ActivityScheduleWeekdayUpsertArgs<ExtArgs>>): Prisma__ActivityScheduleWeekdayClient<$Result.GetResult<Prisma.$ActivityScheduleWeekdayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityScheduleWeekdays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleWeekdayCountArgs} args - Arguments to filter ActivityScheduleWeekdays to count.
     * @example
     * // Count the number of ActivityScheduleWeekdays
     * const count = await prisma.activityScheduleWeekday.count({
     *   where: {
     *     // ... the filter for the ActivityScheduleWeekdays we want to count
     *   }
     * })
    **/
    count<T extends ActivityScheduleWeekdayCountArgs>(
      args?: Subset<T, ActivityScheduleWeekdayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityScheduleWeekdayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityScheduleWeekday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleWeekdayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityScheduleWeekdayAggregateArgs>(args: Subset<T, ActivityScheduleWeekdayAggregateArgs>): Prisma.PrismaPromise<GetActivityScheduleWeekdayAggregateType<T>>

    /**
     * Group by ActivityScheduleWeekday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleWeekdayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityScheduleWeekdayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityScheduleWeekdayGroupByArgs['orderBy'] }
        : { orderBy?: ActivityScheduleWeekdayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityScheduleWeekdayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityScheduleWeekdayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityScheduleWeekday model
   */
  readonly fields: ActivityScheduleWeekdayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityScheduleWeekday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityScheduleWeekdayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ActivityScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityScheduleDefaultArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityScheduleWeekday model
   */
  interface ActivityScheduleWeekdayFieldRefs {
    readonly id: FieldRef<"ActivityScheduleWeekday", 'Int'>
    readonly schedule_uuid: FieldRef<"ActivityScheduleWeekday", 'String'>
    readonly weekday: FieldRef<"ActivityScheduleWeekday", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ActivityScheduleWeekday findUnique
   */
  export type ActivityScheduleWeekdayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleWeekday to fetch.
     */
    where: ActivityScheduleWeekdayWhereUniqueInput
  }

  /**
   * ActivityScheduleWeekday findUniqueOrThrow
   */
  export type ActivityScheduleWeekdayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleWeekday to fetch.
     */
    where: ActivityScheduleWeekdayWhereUniqueInput
  }

  /**
   * ActivityScheduleWeekday findFirst
   */
  export type ActivityScheduleWeekdayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleWeekday to fetch.
     */
    where?: ActivityScheduleWeekdayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityScheduleWeekdays to fetch.
     */
    orderBy?: ActivityScheduleWeekdayOrderByWithRelationInput | ActivityScheduleWeekdayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityScheduleWeekdays.
     */
    cursor?: ActivityScheduleWeekdayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityScheduleWeekdays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityScheduleWeekdays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityScheduleWeekdays.
     */
    distinct?: ActivityScheduleWeekdayScalarFieldEnum | ActivityScheduleWeekdayScalarFieldEnum[]
  }

  /**
   * ActivityScheduleWeekday findFirstOrThrow
   */
  export type ActivityScheduleWeekdayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleWeekday to fetch.
     */
    where?: ActivityScheduleWeekdayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityScheduleWeekdays to fetch.
     */
    orderBy?: ActivityScheduleWeekdayOrderByWithRelationInput | ActivityScheduleWeekdayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityScheduleWeekdays.
     */
    cursor?: ActivityScheduleWeekdayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityScheduleWeekdays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityScheduleWeekdays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityScheduleWeekdays.
     */
    distinct?: ActivityScheduleWeekdayScalarFieldEnum | ActivityScheduleWeekdayScalarFieldEnum[]
  }

  /**
   * ActivityScheduleWeekday findMany
   */
  export type ActivityScheduleWeekdayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleWeekdays to fetch.
     */
    where?: ActivityScheduleWeekdayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityScheduleWeekdays to fetch.
     */
    orderBy?: ActivityScheduleWeekdayOrderByWithRelationInput | ActivityScheduleWeekdayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityScheduleWeekdays.
     */
    cursor?: ActivityScheduleWeekdayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityScheduleWeekdays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityScheduleWeekdays.
     */
    skip?: number
    distinct?: ActivityScheduleWeekdayScalarFieldEnum | ActivityScheduleWeekdayScalarFieldEnum[]
  }

  /**
   * ActivityScheduleWeekday create
   */
  export type ActivityScheduleWeekdayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityScheduleWeekday.
     */
    data: XOR<ActivityScheduleWeekdayCreateInput, ActivityScheduleWeekdayUncheckedCreateInput>
  }

  /**
   * ActivityScheduleWeekday createMany
   */
  export type ActivityScheduleWeekdayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityScheduleWeekdays.
     */
    data: ActivityScheduleWeekdayCreateManyInput | ActivityScheduleWeekdayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityScheduleWeekday createManyAndReturn
   */
  export type ActivityScheduleWeekdayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityScheduleWeekdays.
     */
    data: ActivityScheduleWeekdayCreateManyInput | ActivityScheduleWeekdayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityScheduleWeekday update
   */
  export type ActivityScheduleWeekdayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityScheduleWeekday.
     */
    data: XOR<ActivityScheduleWeekdayUpdateInput, ActivityScheduleWeekdayUncheckedUpdateInput>
    /**
     * Choose, which ActivityScheduleWeekday to update.
     */
    where: ActivityScheduleWeekdayWhereUniqueInput
  }

  /**
   * ActivityScheduleWeekday updateMany
   */
  export type ActivityScheduleWeekdayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityScheduleWeekdays.
     */
    data: XOR<ActivityScheduleWeekdayUpdateManyMutationInput, ActivityScheduleWeekdayUncheckedUpdateManyInput>
    /**
     * Filter which ActivityScheduleWeekdays to update
     */
    where?: ActivityScheduleWeekdayWhereInput
    /**
     * Limit how many ActivityScheduleWeekdays to update.
     */
    limit?: number
  }

  /**
   * ActivityScheduleWeekday updateManyAndReturn
   */
  export type ActivityScheduleWeekdayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * The data used to update ActivityScheduleWeekdays.
     */
    data: XOR<ActivityScheduleWeekdayUpdateManyMutationInput, ActivityScheduleWeekdayUncheckedUpdateManyInput>
    /**
     * Filter which ActivityScheduleWeekdays to update
     */
    where?: ActivityScheduleWeekdayWhereInput
    /**
     * Limit how many ActivityScheduleWeekdays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityScheduleWeekday upsert
   */
  export type ActivityScheduleWeekdayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityScheduleWeekday to update in case it exists.
     */
    where: ActivityScheduleWeekdayWhereUniqueInput
    /**
     * In case the ActivityScheduleWeekday found by the `where` argument doesn't exist, create a new ActivityScheduleWeekday with this data.
     */
    create: XOR<ActivityScheduleWeekdayCreateInput, ActivityScheduleWeekdayUncheckedCreateInput>
    /**
     * In case the ActivityScheduleWeekday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityScheduleWeekdayUpdateInput, ActivityScheduleWeekdayUncheckedUpdateInput>
  }

  /**
   * ActivityScheduleWeekday delete
   */
  export type ActivityScheduleWeekdayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
    /**
     * Filter which ActivityScheduleWeekday to delete.
     */
    where: ActivityScheduleWeekdayWhereUniqueInput
  }

  /**
   * ActivityScheduleWeekday deleteMany
   */
  export type ActivityScheduleWeekdayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityScheduleWeekdays to delete
     */
    where?: ActivityScheduleWeekdayWhereInput
    /**
     * Limit how many ActivityScheduleWeekdays to delete.
     */
    limit?: number
  }

  /**
   * ActivityScheduleWeekday without action
   */
  export type ActivityScheduleWeekdayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleWeekday
     */
    select?: ActivityScheduleWeekdaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleWeekday
     */
    omit?: ActivityScheduleWeekdayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleWeekdayInclude<ExtArgs> | null
  }


  /**
   * Model ActivityScheduleDate
   */

  export type AggregateActivityScheduleDate = {
    _count: ActivityScheduleDateCountAggregateOutputType | null
    _avg: ActivityScheduleDateAvgAggregateOutputType | null
    _sum: ActivityScheduleDateSumAggregateOutputType | null
    _min: ActivityScheduleDateMinAggregateOutputType | null
    _max: ActivityScheduleDateMaxAggregateOutputType | null
  }

  export type ActivityScheduleDateAvgAggregateOutputType = {
    id: number | null
  }

  export type ActivityScheduleDateSumAggregateOutputType = {
    id: number | null
  }

  export type ActivityScheduleDateMinAggregateOutputType = {
    id: number | null
    schedule_uuid: string | null
    date: Date | null
  }

  export type ActivityScheduleDateMaxAggregateOutputType = {
    id: number | null
    schedule_uuid: string | null
    date: Date | null
  }

  export type ActivityScheduleDateCountAggregateOutputType = {
    id: number
    schedule_uuid: number
    date: number
    _all: number
  }


  export type ActivityScheduleDateAvgAggregateInputType = {
    id?: true
  }

  export type ActivityScheduleDateSumAggregateInputType = {
    id?: true
  }

  export type ActivityScheduleDateMinAggregateInputType = {
    id?: true
    schedule_uuid?: true
    date?: true
  }

  export type ActivityScheduleDateMaxAggregateInputType = {
    id?: true
    schedule_uuid?: true
    date?: true
  }

  export type ActivityScheduleDateCountAggregateInputType = {
    id?: true
    schedule_uuid?: true
    date?: true
    _all?: true
  }

  export type ActivityScheduleDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityScheduleDate to aggregate.
     */
    where?: ActivityScheduleDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityScheduleDates to fetch.
     */
    orderBy?: ActivityScheduleDateOrderByWithRelationInput | ActivityScheduleDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityScheduleDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityScheduleDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityScheduleDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityScheduleDates
    **/
    _count?: true | ActivityScheduleDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityScheduleDateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityScheduleDateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityScheduleDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityScheduleDateMaxAggregateInputType
  }

  export type GetActivityScheduleDateAggregateType<T extends ActivityScheduleDateAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityScheduleDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityScheduleDate[P]>
      : GetScalarType<T[P], AggregateActivityScheduleDate[P]>
  }




  export type ActivityScheduleDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityScheduleDateWhereInput
    orderBy?: ActivityScheduleDateOrderByWithAggregationInput | ActivityScheduleDateOrderByWithAggregationInput[]
    by: ActivityScheduleDateScalarFieldEnum[] | ActivityScheduleDateScalarFieldEnum
    having?: ActivityScheduleDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityScheduleDateCountAggregateInputType | true
    _avg?: ActivityScheduleDateAvgAggregateInputType
    _sum?: ActivityScheduleDateSumAggregateInputType
    _min?: ActivityScheduleDateMinAggregateInputType
    _max?: ActivityScheduleDateMaxAggregateInputType
  }

  export type ActivityScheduleDateGroupByOutputType = {
    id: number
    schedule_uuid: string
    date: Date
    _count: ActivityScheduleDateCountAggregateOutputType | null
    _avg: ActivityScheduleDateAvgAggregateOutputType | null
    _sum: ActivityScheduleDateSumAggregateOutputType | null
    _min: ActivityScheduleDateMinAggregateOutputType | null
    _max: ActivityScheduleDateMaxAggregateOutputType | null
  }

  type GetActivityScheduleDateGroupByPayload<T extends ActivityScheduleDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityScheduleDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityScheduleDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityScheduleDateGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityScheduleDateGroupByOutputType[P]>
        }
      >
    >


  export type ActivityScheduleDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schedule_uuid?: boolean
    date?: boolean
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityScheduleDate"]>

  export type ActivityScheduleDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schedule_uuid?: boolean
    date?: boolean
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityScheduleDate"]>

  export type ActivityScheduleDateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schedule_uuid?: boolean
    date?: boolean
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityScheduleDate"]>

  export type ActivityScheduleDateSelectScalar = {
    id?: boolean
    schedule_uuid?: boolean
    date?: boolean
  }

  export type ActivityScheduleDateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schedule_uuid" | "date", ExtArgs["result"]["activityScheduleDate"]>
  export type ActivityScheduleDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }
  export type ActivityScheduleDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }
  export type ActivityScheduleDateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
  }

  export type $ActivityScheduleDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityScheduleDate"
    objects: {
      schedule: Prisma.$ActivitySchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      schedule_uuid: string
      date: Date
    }, ExtArgs["result"]["activityScheduleDate"]>
    composites: {}
  }

  type ActivityScheduleDateGetPayload<S extends boolean | null | undefined | ActivityScheduleDateDefaultArgs> = $Result.GetResult<Prisma.$ActivityScheduleDatePayload, S>

  type ActivityScheduleDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityScheduleDateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityScheduleDateCountAggregateInputType | true
    }

  export interface ActivityScheduleDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityScheduleDate'], meta: { name: 'ActivityScheduleDate' } }
    /**
     * Find zero or one ActivityScheduleDate that matches the filter.
     * @param {ActivityScheduleDateFindUniqueArgs} args - Arguments to find a ActivityScheduleDate
     * @example
     * // Get one ActivityScheduleDate
     * const activityScheduleDate = await prisma.activityScheduleDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityScheduleDateFindUniqueArgs>(args: SelectSubset<T, ActivityScheduleDateFindUniqueArgs<ExtArgs>>): Prisma__ActivityScheduleDateClient<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityScheduleDate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityScheduleDateFindUniqueOrThrowArgs} args - Arguments to find a ActivityScheduleDate
     * @example
     * // Get one ActivityScheduleDate
     * const activityScheduleDate = await prisma.activityScheduleDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityScheduleDateFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityScheduleDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityScheduleDateClient<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityScheduleDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleDateFindFirstArgs} args - Arguments to find a ActivityScheduleDate
     * @example
     * // Get one ActivityScheduleDate
     * const activityScheduleDate = await prisma.activityScheduleDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityScheduleDateFindFirstArgs>(args?: SelectSubset<T, ActivityScheduleDateFindFirstArgs<ExtArgs>>): Prisma__ActivityScheduleDateClient<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityScheduleDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleDateFindFirstOrThrowArgs} args - Arguments to find a ActivityScheduleDate
     * @example
     * // Get one ActivityScheduleDate
     * const activityScheduleDate = await prisma.activityScheduleDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityScheduleDateFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityScheduleDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityScheduleDateClient<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityScheduleDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityScheduleDates
     * const activityScheduleDates = await prisma.activityScheduleDate.findMany()
     * 
     * // Get first 10 ActivityScheduleDates
     * const activityScheduleDates = await prisma.activityScheduleDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityScheduleDateWithIdOnly = await prisma.activityScheduleDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityScheduleDateFindManyArgs>(args?: SelectSubset<T, ActivityScheduleDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityScheduleDate.
     * @param {ActivityScheduleDateCreateArgs} args - Arguments to create a ActivityScheduleDate.
     * @example
     * // Create one ActivityScheduleDate
     * const ActivityScheduleDate = await prisma.activityScheduleDate.create({
     *   data: {
     *     // ... data to create a ActivityScheduleDate
     *   }
     * })
     * 
     */
    create<T extends ActivityScheduleDateCreateArgs>(args: SelectSubset<T, ActivityScheduleDateCreateArgs<ExtArgs>>): Prisma__ActivityScheduleDateClient<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityScheduleDates.
     * @param {ActivityScheduleDateCreateManyArgs} args - Arguments to create many ActivityScheduleDates.
     * @example
     * // Create many ActivityScheduleDates
     * const activityScheduleDate = await prisma.activityScheduleDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityScheduleDateCreateManyArgs>(args?: SelectSubset<T, ActivityScheduleDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityScheduleDates and returns the data saved in the database.
     * @param {ActivityScheduleDateCreateManyAndReturnArgs} args - Arguments to create many ActivityScheduleDates.
     * @example
     * // Create many ActivityScheduleDates
     * const activityScheduleDate = await prisma.activityScheduleDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityScheduleDates and only return the `id`
     * const activityScheduleDateWithIdOnly = await prisma.activityScheduleDate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityScheduleDateCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityScheduleDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityScheduleDate.
     * @param {ActivityScheduleDateDeleteArgs} args - Arguments to delete one ActivityScheduleDate.
     * @example
     * // Delete one ActivityScheduleDate
     * const ActivityScheduleDate = await prisma.activityScheduleDate.delete({
     *   where: {
     *     // ... filter to delete one ActivityScheduleDate
     *   }
     * })
     * 
     */
    delete<T extends ActivityScheduleDateDeleteArgs>(args: SelectSubset<T, ActivityScheduleDateDeleteArgs<ExtArgs>>): Prisma__ActivityScheduleDateClient<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityScheduleDate.
     * @param {ActivityScheduleDateUpdateArgs} args - Arguments to update one ActivityScheduleDate.
     * @example
     * // Update one ActivityScheduleDate
     * const activityScheduleDate = await prisma.activityScheduleDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityScheduleDateUpdateArgs>(args: SelectSubset<T, ActivityScheduleDateUpdateArgs<ExtArgs>>): Prisma__ActivityScheduleDateClient<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityScheduleDates.
     * @param {ActivityScheduleDateDeleteManyArgs} args - Arguments to filter ActivityScheduleDates to delete.
     * @example
     * // Delete a few ActivityScheduleDates
     * const { count } = await prisma.activityScheduleDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityScheduleDateDeleteManyArgs>(args?: SelectSubset<T, ActivityScheduleDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityScheduleDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityScheduleDates
     * const activityScheduleDate = await prisma.activityScheduleDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityScheduleDateUpdateManyArgs>(args: SelectSubset<T, ActivityScheduleDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityScheduleDates and returns the data updated in the database.
     * @param {ActivityScheduleDateUpdateManyAndReturnArgs} args - Arguments to update many ActivityScheduleDates.
     * @example
     * // Update many ActivityScheduleDates
     * const activityScheduleDate = await prisma.activityScheduleDate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityScheduleDates and only return the `id`
     * const activityScheduleDateWithIdOnly = await prisma.activityScheduleDate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityScheduleDateUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityScheduleDateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityScheduleDate.
     * @param {ActivityScheduleDateUpsertArgs} args - Arguments to update or create a ActivityScheduleDate.
     * @example
     * // Update or create a ActivityScheduleDate
     * const activityScheduleDate = await prisma.activityScheduleDate.upsert({
     *   create: {
     *     // ... data to create a ActivityScheduleDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityScheduleDate we want to update
     *   }
     * })
     */
    upsert<T extends ActivityScheduleDateUpsertArgs>(args: SelectSubset<T, ActivityScheduleDateUpsertArgs<ExtArgs>>): Prisma__ActivityScheduleDateClient<$Result.GetResult<Prisma.$ActivityScheduleDatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityScheduleDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleDateCountArgs} args - Arguments to filter ActivityScheduleDates to count.
     * @example
     * // Count the number of ActivityScheduleDates
     * const count = await prisma.activityScheduleDate.count({
     *   where: {
     *     // ... the filter for the ActivityScheduleDates we want to count
     *   }
     * })
    **/
    count<T extends ActivityScheduleDateCountArgs>(
      args?: Subset<T, ActivityScheduleDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityScheduleDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityScheduleDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityScheduleDateAggregateArgs>(args: Subset<T, ActivityScheduleDateAggregateArgs>): Prisma.PrismaPromise<GetActivityScheduleDateAggregateType<T>>

    /**
     * Group by ActivityScheduleDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityScheduleDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityScheduleDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityScheduleDateGroupByArgs['orderBy'] }
        : { orderBy?: ActivityScheduleDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityScheduleDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityScheduleDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityScheduleDate model
   */
  readonly fields: ActivityScheduleDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityScheduleDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityScheduleDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ActivityScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityScheduleDefaultArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityScheduleDate model
   */
  interface ActivityScheduleDateFieldRefs {
    readonly id: FieldRef<"ActivityScheduleDate", 'Int'>
    readonly schedule_uuid: FieldRef<"ActivityScheduleDate", 'String'>
    readonly date: FieldRef<"ActivityScheduleDate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityScheduleDate findUnique
   */
  export type ActivityScheduleDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleDate to fetch.
     */
    where: ActivityScheduleDateWhereUniqueInput
  }

  /**
   * ActivityScheduleDate findUniqueOrThrow
   */
  export type ActivityScheduleDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleDate to fetch.
     */
    where: ActivityScheduleDateWhereUniqueInput
  }

  /**
   * ActivityScheduleDate findFirst
   */
  export type ActivityScheduleDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleDate to fetch.
     */
    where?: ActivityScheduleDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityScheduleDates to fetch.
     */
    orderBy?: ActivityScheduleDateOrderByWithRelationInput | ActivityScheduleDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityScheduleDates.
     */
    cursor?: ActivityScheduleDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityScheduleDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityScheduleDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityScheduleDates.
     */
    distinct?: ActivityScheduleDateScalarFieldEnum | ActivityScheduleDateScalarFieldEnum[]
  }

  /**
   * ActivityScheduleDate findFirstOrThrow
   */
  export type ActivityScheduleDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleDate to fetch.
     */
    where?: ActivityScheduleDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityScheduleDates to fetch.
     */
    orderBy?: ActivityScheduleDateOrderByWithRelationInput | ActivityScheduleDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityScheduleDates.
     */
    cursor?: ActivityScheduleDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityScheduleDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityScheduleDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityScheduleDates.
     */
    distinct?: ActivityScheduleDateScalarFieldEnum | ActivityScheduleDateScalarFieldEnum[]
  }

  /**
   * ActivityScheduleDate findMany
   */
  export type ActivityScheduleDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityScheduleDates to fetch.
     */
    where?: ActivityScheduleDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityScheduleDates to fetch.
     */
    orderBy?: ActivityScheduleDateOrderByWithRelationInput | ActivityScheduleDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityScheduleDates.
     */
    cursor?: ActivityScheduleDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityScheduleDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityScheduleDates.
     */
    skip?: number
    distinct?: ActivityScheduleDateScalarFieldEnum | ActivityScheduleDateScalarFieldEnum[]
  }

  /**
   * ActivityScheduleDate create
   */
  export type ActivityScheduleDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityScheduleDate.
     */
    data: XOR<ActivityScheduleDateCreateInput, ActivityScheduleDateUncheckedCreateInput>
  }

  /**
   * ActivityScheduleDate createMany
   */
  export type ActivityScheduleDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityScheduleDates.
     */
    data: ActivityScheduleDateCreateManyInput | ActivityScheduleDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityScheduleDate createManyAndReturn
   */
  export type ActivityScheduleDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityScheduleDates.
     */
    data: ActivityScheduleDateCreateManyInput | ActivityScheduleDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityScheduleDate update
   */
  export type ActivityScheduleDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityScheduleDate.
     */
    data: XOR<ActivityScheduleDateUpdateInput, ActivityScheduleDateUncheckedUpdateInput>
    /**
     * Choose, which ActivityScheduleDate to update.
     */
    where: ActivityScheduleDateWhereUniqueInput
  }

  /**
   * ActivityScheduleDate updateMany
   */
  export type ActivityScheduleDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityScheduleDates.
     */
    data: XOR<ActivityScheduleDateUpdateManyMutationInput, ActivityScheduleDateUncheckedUpdateManyInput>
    /**
     * Filter which ActivityScheduleDates to update
     */
    where?: ActivityScheduleDateWhereInput
    /**
     * Limit how many ActivityScheduleDates to update.
     */
    limit?: number
  }

  /**
   * ActivityScheduleDate updateManyAndReturn
   */
  export type ActivityScheduleDateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * The data used to update ActivityScheduleDates.
     */
    data: XOR<ActivityScheduleDateUpdateManyMutationInput, ActivityScheduleDateUncheckedUpdateManyInput>
    /**
     * Filter which ActivityScheduleDates to update
     */
    where?: ActivityScheduleDateWhereInput
    /**
     * Limit how many ActivityScheduleDates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityScheduleDate upsert
   */
  export type ActivityScheduleDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityScheduleDate to update in case it exists.
     */
    where: ActivityScheduleDateWhereUniqueInput
    /**
     * In case the ActivityScheduleDate found by the `where` argument doesn't exist, create a new ActivityScheduleDate with this data.
     */
    create: XOR<ActivityScheduleDateCreateInput, ActivityScheduleDateUncheckedCreateInput>
    /**
     * In case the ActivityScheduleDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityScheduleDateUpdateInput, ActivityScheduleDateUncheckedUpdateInput>
  }

  /**
   * ActivityScheduleDate delete
   */
  export type ActivityScheduleDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
    /**
     * Filter which ActivityScheduleDate to delete.
     */
    where: ActivityScheduleDateWhereUniqueInput
  }

  /**
   * ActivityScheduleDate deleteMany
   */
  export type ActivityScheduleDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityScheduleDates to delete
     */
    where?: ActivityScheduleDateWhereInput
    /**
     * Limit how many ActivityScheduleDates to delete.
     */
    limit?: number
  }

  /**
   * ActivityScheduleDate without action
   */
  export type ActivityScheduleDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityScheduleDate
     */
    select?: ActivityScheduleDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityScheduleDate
     */
    omit?: ActivityScheduleDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityScheduleDateInclude<ExtArgs> | null
  }


  /**
   * Model ActivityOccurrence
   */

  export type AggregateActivityOccurrence = {
    _count: ActivityOccurrenceCountAggregateOutputType | null
    _avg: ActivityOccurrenceAvgAggregateOutputType | null
    _sum: ActivityOccurrenceSumAggregateOutputType | null
    _min: ActivityOccurrenceMinAggregateOutputType | null
    _max: ActivityOccurrenceMaxAggregateOutputType | null
  }

  export type ActivityOccurrenceAvgAggregateOutputType = {
    id: number | null
  }

  export type ActivityOccurrenceSumAggregateOutputType = {
    id: number | null
  }

  export type ActivityOccurrenceMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    activity_uuid: string | null
    schedule_uuid: string | null
    scheduled_for: Date | null
    status: $Enums.OccurrenceStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityOccurrenceMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    activity_uuid: string | null
    schedule_uuid: string | null
    scheduled_for: Date | null
    status: $Enums.OccurrenceStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityOccurrenceCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    activity_uuid: number
    schedule_uuid: number
    scheduled_for: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivityOccurrenceAvgAggregateInputType = {
    id?: true
  }

  export type ActivityOccurrenceSumAggregateInputType = {
    id?: true
  }

  export type ActivityOccurrenceMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    schedule_uuid?: true
    scheduled_for?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityOccurrenceMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    schedule_uuid?: true
    scheduled_for?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityOccurrenceCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    schedule_uuid?: true
    scheduled_for?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivityOccurrenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityOccurrence to aggregate.
     */
    where?: ActivityOccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityOccurrences to fetch.
     */
    orderBy?: ActivityOccurrenceOrderByWithRelationInput | ActivityOccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityOccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityOccurrences
    **/
    _count?: true | ActivityOccurrenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityOccurrenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityOccurrenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityOccurrenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityOccurrenceMaxAggregateInputType
  }

  export type GetActivityOccurrenceAggregateType<T extends ActivityOccurrenceAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityOccurrence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityOccurrence[P]>
      : GetScalarType<T[P], AggregateActivityOccurrence[P]>
  }




  export type ActivityOccurrenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityOccurrenceWhereInput
    orderBy?: ActivityOccurrenceOrderByWithAggregationInput | ActivityOccurrenceOrderByWithAggregationInput[]
    by: ActivityOccurrenceScalarFieldEnum[] | ActivityOccurrenceScalarFieldEnum
    having?: ActivityOccurrenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityOccurrenceCountAggregateInputType | true
    _avg?: ActivityOccurrenceAvgAggregateInputType
    _sum?: ActivityOccurrenceSumAggregateInputType
    _min?: ActivityOccurrenceMinAggregateInputType
    _max?: ActivityOccurrenceMaxAggregateInputType
  }

  export type ActivityOccurrenceGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string
    activity_uuid: string
    schedule_uuid: string
    scheduled_for: Date
    status: $Enums.OccurrenceStatus
    created_at: Date
    updated_at: Date
    _count: ActivityOccurrenceCountAggregateOutputType | null
    _avg: ActivityOccurrenceAvgAggregateOutputType | null
    _sum: ActivityOccurrenceSumAggregateOutputType | null
    _min: ActivityOccurrenceMinAggregateOutputType | null
    _max: ActivityOccurrenceMaxAggregateOutputType | null
  }

  type GetActivityOccurrenceGroupByPayload<T extends ActivityOccurrenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityOccurrenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityOccurrenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityOccurrenceGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityOccurrenceGroupByOutputType[P]>
        }
      >
    >


  export type ActivityOccurrenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    schedule_uuid?: boolean
    scheduled_for?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    log?: boolean | ActivityOccurrence$logArgs<ExtArgs>
  }, ExtArgs["result"]["activityOccurrence"]>

  export type ActivityOccurrenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    schedule_uuid?: boolean
    scheduled_for?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityOccurrence"]>

  export type ActivityOccurrenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    schedule_uuid?: boolean
    scheduled_for?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityOccurrence"]>

  export type ActivityOccurrenceSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    schedule_uuid?: boolean
    scheduled_for?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ActivityOccurrenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "activity_uuid" | "schedule_uuid" | "scheduled_for" | "status" | "created_at" | "updated_at", ExtArgs["result"]["activityOccurrence"]>
  export type ActivityOccurrenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    log?: boolean | ActivityOccurrence$logArgs<ExtArgs>
  }
  export type ActivityOccurrenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityOccurrenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityOccurrencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityOccurrence"
    objects: {
      activity: Prisma.$ActivityPayload<ExtArgs>
      schedule: Prisma.$ActivitySchedulePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      log: Prisma.$ActivityLogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string
      activity_uuid: string
      schedule_uuid: string
      scheduled_for: Date
      status: $Enums.OccurrenceStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["activityOccurrence"]>
    composites: {}
  }

  type ActivityOccurrenceGetPayload<S extends boolean | null | undefined | ActivityOccurrenceDefaultArgs> = $Result.GetResult<Prisma.$ActivityOccurrencePayload, S>

  type ActivityOccurrenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityOccurrenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityOccurrenceCountAggregateInputType | true
    }

  export interface ActivityOccurrenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityOccurrence'], meta: { name: 'ActivityOccurrence' } }
    /**
     * Find zero or one ActivityOccurrence that matches the filter.
     * @param {ActivityOccurrenceFindUniqueArgs} args - Arguments to find a ActivityOccurrence
     * @example
     * // Get one ActivityOccurrence
     * const activityOccurrence = await prisma.activityOccurrence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityOccurrenceFindUniqueArgs>(args: SelectSubset<T, ActivityOccurrenceFindUniqueArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityOccurrence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityOccurrenceFindUniqueOrThrowArgs} args - Arguments to find a ActivityOccurrence
     * @example
     * // Get one ActivityOccurrence
     * const activityOccurrence = await prisma.activityOccurrence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityOccurrenceFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityOccurrenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityOccurrence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityOccurrenceFindFirstArgs} args - Arguments to find a ActivityOccurrence
     * @example
     * // Get one ActivityOccurrence
     * const activityOccurrence = await prisma.activityOccurrence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityOccurrenceFindFirstArgs>(args?: SelectSubset<T, ActivityOccurrenceFindFirstArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityOccurrence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityOccurrenceFindFirstOrThrowArgs} args - Arguments to find a ActivityOccurrence
     * @example
     * // Get one ActivityOccurrence
     * const activityOccurrence = await prisma.activityOccurrence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityOccurrenceFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityOccurrenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityOccurrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityOccurrenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityOccurrences
     * const activityOccurrences = await prisma.activityOccurrence.findMany()
     * 
     * // Get first 10 ActivityOccurrences
     * const activityOccurrences = await prisma.activityOccurrence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityOccurrenceWithIdOnly = await prisma.activityOccurrence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityOccurrenceFindManyArgs>(args?: SelectSubset<T, ActivityOccurrenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityOccurrence.
     * @param {ActivityOccurrenceCreateArgs} args - Arguments to create a ActivityOccurrence.
     * @example
     * // Create one ActivityOccurrence
     * const ActivityOccurrence = await prisma.activityOccurrence.create({
     *   data: {
     *     // ... data to create a ActivityOccurrence
     *   }
     * })
     * 
     */
    create<T extends ActivityOccurrenceCreateArgs>(args: SelectSubset<T, ActivityOccurrenceCreateArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityOccurrences.
     * @param {ActivityOccurrenceCreateManyArgs} args - Arguments to create many ActivityOccurrences.
     * @example
     * // Create many ActivityOccurrences
     * const activityOccurrence = await prisma.activityOccurrence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityOccurrenceCreateManyArgs>(args?: SelectSubset<T, ActivityOccurrenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityOccurrences and returns the data saved in the database.
     * @param {ActivityOccurrenceCreateManyAndReturnArgs} args - Arguments to create many ActivityOccurrences.
     * @example
     * // Create many ActivityOccurrences
     * const activityOccurrence = await prisma.activityOccurrence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityOccurrences and only return the `id`
     * const activityOccurrenceWithIdOnly = await prisma.activityOccurrence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityOccurrenceCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityOccurrenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityOccurrence.
     * @param {ActivityOccurrenceDeleteArgs} args - Arguments to delete one ActivityOccurrence.
     * @example
     * // Delete one ActivityOccurrence
     * const ActivityOccurrence = await prisma.activityOccurrence.delete({
     *   where: {
     *     // ... filter to delete one ActivityOccurrence
     *   }
     * })
     * 
     */
    delete<T extends ActivityOccurrenceDeleteArgs>(args: SelectSubset<T, ActivityOccurrenceDeleteArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityOccurrence.
     * @param {ActivityOccurrenceUpdateArgs} args - Arguments to update one ActivityOccurrence.
     * @example
     * // Update one ActivityOccurrence
     * const activityOccurrence = await prisma.activityOccurrence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityOccurrenceUpdateArgs>(args: SelectSubset<T, ActivityOccurrenceUpdateArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityOccurrences.
     * @param {ActivityOccurrenceDeleteManyArgs} args - Arguments to filter ActivityOccurrences to delete.
     * @example
     * // Delete a few ActivityOccurrences
     * const { count } = await prisma.activityOccurrence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityOccurrenceDeleteManyArgs>(args?: SelectSubset<T, ActivityOccurrenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityOccurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityOccurrenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityOccurrences
     * const activityOccurrence = await prisma.activityOccurrence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityOccurrenceUpdateManyArgs>(args: SelectSubset<T, ActivityOccurrenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityOccurrences and returns the data updated in the database.
     * @param {ActivityOccurrenceUpdateManyAndReturnArgs} args - Arguments to update many ActivityOccurrences.
     * @example
     * // Update many ActivityOccurrences
     * const activityOccurrence = await prisma.activityOccurrence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityOccurrences and only return the `id`
     * const activityOccurrenceWithIdOnly = await prisma.activityOccurrence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityOccurrenceUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityOccurrenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityOccurrence.
     * @param {ActivityOccurrenceUpsertArgs} args - Arguments to update or create a ActivityOccurrence.
     * @example
     * // Update or create a ActivityOccurrence
     * const activityOccurrence = await prisma.activityOccurrence.upsert({
     *   create: {
     *     // ... data to create a ActivityOccurrence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityOccurrence we want to update
     *   }
     * })
     */
    upsert<T extends ActivityOccurrenceUpsertArgs>(args: SelectSubset<T, ActivityOccurrenceUpsertArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityOccurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityOccurrenceCountArgs} args - Arguments to filter ActivityOccurrences to count.
     * @example
     * // Count the number of ActivityOccurrences
     * const count = await prisma.activityOccurrence.count({
     *   where: {
     *     // ... the filter for the ActivityOccurrences we want to count
     *   }
     * })
    **/
    count<T extends ActivityOccurrenceCountArgs>(
      args?: Subset<T, ActivityOccurrenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityOccurrenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityOccurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityOccurrenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityOccurrenceAggregateArgs>(args: Subset<T, ActivityOccurrenceAggregateArgs>): Prisma.PrismaPromise<GetActivityOccurrenceAggregateType<T>>

    /**
     * Group by ActivityOccurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityOccurrenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityOccurrenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityOccurrenceGroupByArgs['orderBy'] }
        : { orderBy?: ActivityOccurrenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityOccurrenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityOccurrenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityOccurrence model
   */
  readonly fields: ActivityOccurrenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityOccurrence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityOccurrenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedule<T extends ActivityScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityScheduleDefaultArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    log<T extends ActivityOccurrence$logArgs<ExtArgs> = {}>(args?: Subset<T, ActivityOccurrence$logArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityOccurrence model
   */
  interface ActivityOccurrenceFieldRefs {
    readonly id: FieldRef<"ActivityOccurrence", 'Int'>
    readonly uuid: FieldRef<"ActivityOccurrence", 'String'>
    readonly user_uuid: FieldRef<"ActivityOccurrence", 'String'>
    readonly activity_uuid: FieldRef<"ActivityOccurrence", 'String'>
    readonly schedule_uuid: FieldRef<"ActivityOccurrence", 'String'>
    readonly scheduled_for: FieldRef<"ActivityOccurrence", 'DateTime'>
    readonly status: FieldRef<"ActivityOccurrence", 'OccurrenceStatus'>
    readonly created_at: FieldRef<"ActivityOccurrence", 'DateTime'>
    readonly updated_at: FieldRef<"ActivityOccurrence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityOccurrence findUnique
   */
  export type ActivityOccurrenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which ActivityOccurrence to fetch.
     */
    where: ActivityOccurrenceWhereUniqueInput
  }

  /**
   * ActivityOccurrence findUniqueOrThrow
   */
  export type ActivityOccurrenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which ActivityOccurrence to fetch.
     */
    where: ActivityOccurrenceWhereUniqueInput
  }

  /**
   * ActivityOccurrence findFirst
   */
  export type ActivityOccurrenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which ActivityOccurrence to fetch.
     */
    where?: ActivityOccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityOccurrences to fetch.
     */
    orderBy?: ActivityOccurrenceOrderByWithRelationInput | ActivityOccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityOccurrences.
     */
    cursor?: ActivityOccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityOccurrences.
     */
    distinct?: ActivityOccurrenceScalarFieldEnum | ActivityOccurrenceScalarFieldEnum[]
  }

  /**
   * ActivityOccurrence findFirstOrThrow
   */
  export type ActivityOccurrenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which ActivityOccurrence to fetch.
     */
    where?: ActivityOccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityOccurrences to fetch.
     */
    orderBy?: ActivityOccurrenceOrderByWithRelationInput | ActivityOccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityOccurrences.
     */
    cursor?: ActivityOccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityOccurrences.
     */
    distinct?: ActivityOccurrenceScalarFieldEnum | ActivityOccurrenceScalarFieldEnum[]
  }

  /**
   * ActivityOccurrence findMany
   */
  export type ActivityOccurrenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which ActivityOccurrences to fetch.
     */
    where?: ActivityOccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityOccurrences to fetch.
     */
    orderBy?: ActivityOccurrenceOrderByWithRelationInput | ActivityOccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityOccurrences.
     */
    cursor?: ActivityOccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityOccurrences.
     */
    skip?: number
    distinct?: ActivityOccurrenceScalarFieldEnum | ActivityOccurrenceScalarFieldEnum[]
  }

  /**
   * ActivityOccurrence create
   */
  export type ActivityOccurrenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityOccurrence.
     */
    data: XOR<ActivityOccurrenceCreateInput, ActivityOccurrenceUncheckedCreateInput>
  }

  /**
   * ActivityOccurrence createMany
   */
  export type ActivityOccurrenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityOccurrences.
     */
    data: ActivityOccurrenceCreateManyInput | ActivityOccurrenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityOccurrence createManyAndReturn
   */
  export type ActivityOccurrenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityOccurrences.
     */
    data: ActivityOccurrenceCreateManyInput | ActivityOccurrenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityOccurrence update
   */
  export type ActivityOccurrenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityOccurrence.
     */
    data: XOR<ActivityOccurrenceUpdateInput, ActivityOccurrenceUncheckedUpdateInput>
    /**
     * Choose, which ActivityOccurrence to update.
     */
    where: ActivityOccurrenceWhereUniqueInput
  }

  /**
   * ActivityOccurrence updateMany
   */
  export type ActivityOccurrenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityOccurrences.
     */
    data: XOR<ActivityOccurrenceUpdateManyMutationInput, ActivityOccurrenceUncheckedUpdateManyInput>
    /**
     * Filter which ActivityOccurrences to update
     */
    where?: ActivityOccurrenceWhereInput
    /**
     * Limit how many ActivityOccurrences to update.
     */
    limit?: number
  }

  /**
   * ActivityOccurrence updateManyAndReturn
   */
  export type ActivityOccurrenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * The data used to update ActivityOccurrences.
     */
    data: XOR<ActivityOccurrenceUpdateManyMutationInput, ActivityOccurrenceUncheckedUpdateManyInput>
    /**
     * Filter which ActivityOccurrences to update
     */
    where?: ActivityOccurrenceWhereInput
    /**
     * Limit how many ActivityOccurrences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityOccurrence upsert
   */
  export type ActivityOccurrenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityOccurrence to update in case it exists.
     */
    where: ActivityOccurrenceWhereUniqueInput
    /**
     * In case the ActivityOccurrence found by the `where` argument doesn't exist, create a new ActivityOccurrence with this data.
     */
    create: XOR<ActivityOccurrenceCreateInput, ActivityOccurrenceUncheckedCreateInput>
    /**
     * In case the ActivityOccurrence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityOccurrenceUpdateInput, ActivityOccurrenceUncheckedUpdateInput>
  }

  /**
   * ActivityOccurrence delete
   */
  export type ActivityOccurrenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
    /**
     * Filter which ActivityOccurrence to delete.
     */
    where: ActivityOccurrenceWhereUniqueInput
  }

  /**
   * ActivityOccurrence deleteMany
   */
  export type ActivityOccurrenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityOccurrences to delete
     */
    where?: ActivityOccurrenceWhereInput
    /**
     * Limit how many ActivityOccurrences to delete.
     */
    limit?: number
  }

  /**
   * ActivityOccurrence.log
   */
  export type ActivityOccurrence$logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityOccurrence without action
   */
  export type ActivityOccurrenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityOccurrence
     */
    select?: ActivityOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityOccurrence
     */
    omit?: ActivityOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityOccurrenceInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    snapshot_target_value: number | null
    value: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    snapshot_target_value: number | null
    value: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    activity_uuid: string | null
    schedule_uuid: string | null
    occurrence_uuid: string | null
    snapshot_target_type: $Enums.ActivityTargetType | null
    snapshot_target_value: number | null
    snapshot_target_unit: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label: string | null
    value: number | null
    completed: boolean | null
    completed_at: Date | null
    skipped: boolean | null
    skip_reason: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    activity_uuid: string | null
    schedule_uuid: string | null
    occurrence_uuid: string | null
    snapshot_target_type: $Enums.ActivityTargetType | null
    snapshot_target_value: number | null
    snapshot_target_unit: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label: string | null
    value: number | null
    completed: boolean | null
    completed_at: Date | null
    skipped: boolean | null
    skip_reason: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    activity_uuid: number
    schedule_uuid: number
    occurrence_uuid: number
    snapshot_target_type: number
    snapshot_target_value: number
    snapshot_target_unit: number
    snapshot_target_unit_label: number
    value: number
    completed: number
    completed_at: number
    skipped: number
    skip_reason: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    snapshot_target_value?: true
    value?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    snapshot_target_value?: true
    value?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    schedule_uuid?: true
    occurrence_uuid?: true
    snapshot_target_type?: true
    snapshot_target_value?: true
    snapshot_target_unit?: true
    snapshot_target_unit_label?: true
    value?: true
    completed?: true
    completed_at?: true
    skipped?: true
    skip_reason?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    schedule_uuid?: true
    occurrence_uuid?: true
    snapshot_target_type?: true
    snapshot_target_value?: true
    snapshot_target_unit?: true
    snapshot_target_unit_label?: true
    value?: true
    completed?: true
    completed_at?: true
    skipped?: true
    skip_reason?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    activity_uuid?: true
    schedule_uuid?: true
    occurrence_uuid?: true
    snapshot_target_type?: true
    snapshot_target_value?: true
    snapshot_target_unit?: true
    snapshot_target_unit_label?: true
    value?: true
    completed?: true
    completed_at?: true
    skipped?: true
    skip_reason?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string
    activity_uuid: string
    schedule_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value: number | null
    snapshot_target_unit: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label: string | null
    value: number | null
    completed: boolean
    completed_at: Date | null
    skipped: boolean
    skip_reason: string | null
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    schedule_uuid?: boolean
    occurrence_uuid?: boolean
    snapshot_target_type?: boolean
    snapshot_target_value?: boolean
    snapshot_target_unit?: boolean
    snapshot_target_unit_label?: boolean
    value?: boolean
    completed?: boolean
    completed_at?: boolean
    skipped?: boolean
    skip_reason?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    occurrence?: boolean | ActivityOccurrenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    schedule_uuid?: boolean
    occurrence_uuid?: boolean
    snapshot_target_type?: boolean
    snapshot_target_value?: boolean
    snapshot_target_unit?: boolean
    snapshot_target_unit_label?: boolean
    value?: boolean
    completed?: boolean
    completed_at?: boolean
    skipped?: boolean
    skip_reason?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    occurrence?: boolean | ActivityOccurrenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    schedule_uuid?: boolean
    occurrence_uuid?: boolean
    snapshot_target_type?: boolean
    snapshot_target_value?: boolean
    snapshot_target_unit?: boolean
    snapshot_target_unit_label?: boolean
    value?: boolean
    completed?: boolean
    completed_at?: boolean
    skipped?: boolean
    skip_reason?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    occurrence?: boolean | ActivityOccurrenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    activity_uuid?: boolean
    schedule_uuid?: boolean
    occurrence_uuid?: boolean
    snapshot_target_type?: boolean
    snapshot_target_value?: boolean
    snapshot_target_unit?: boolean
    snapshot_target_unit_label?: boolean
    value?: boolean
    completed?: boolean
    completed_at?: boolean
    skipped?: boolean
    skip_reason?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "activity_uuid" | "schedule_uuid" | "occurrence_uuid" | "snapshot_target_type" | "snapshot_target_value" | "snapshot_target_unit" | "snapshot_target_unit_label" | "value" | "completed" | "completed_at" | "skipped" | "skip_reason" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    occurrence?: boolean | ActivityOccurrenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    occurrence?: boolean | ActivityOccurrenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    schedule?: boolean | ActivityScheduleDefaultArgs<ExtArgs>
    occurrence?: boolean | ActivityOccurrenceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      activity: Prisma.$ActivityPayload<ExtArgs>
      schedule: Prisma.$ActivitySchedulePayload<ExtArgs>
      occurrence: Prisma.$ActivityOccurrencePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string
      activity_uuid: string
      schedule_uuid: string
      occurrence_uuid: string
      snapshot_target_type: $Enums.ActivityTargetType
      snapshot_target_value: number | null
      snapshot_target_unit: $Enums.ActivityTargetUnit | null
      snapshot_target_unit_label: string | null
      value: number | null
      completed: boolean
      completed_at: Date | null
      skipped: boolean
      skip_reason: string | null
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedule<T extends ActivityScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityScheduleDefaultArgs<ExtArgs>>): Prisma__ActivityScheduleClient<$Result.GetResult<Prisma.$ActivitySchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    occurrence<T extends ActivityOccurrenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityOccurrenceDefaultArgs<ExtArgs>>): Prisma__ActivityOccurrenceClient<$Result.GetResult<Prisma.$ActivityOccurrencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly uuid: FieldRef<"ActivityLog", 'String'>
    readonly user_uuid: FieldRef<"ActivityLog", 'String'>
    readonly activity_uuid: FieldRef<"ActivityLog", 'String'>
    readonly schedule_uuid: FieldRef<"ActivityLog", 'String'>
    readonly occurrence_uuid: FieldRef<"ActivityLog", 'String'>
    readonly snapshot_target_type: FieldRef<"ActivityLog", 'ActivityTargetType'>
    readonly snapshot_target_value: FieldRef<"ActivityLog", 'Float'>
    readonly snapshot_target_unit: FieldRef<"ActivityLog", 'ActivityTargetUnit'>
    readonly snapshot_target_unit_label: FieldRef<"ActivityLog", 'String'>
    readonly value: FieldRef<"ActivityLog", 'Float'>
    readonly completed: FieldRef<"ActivityLog", 'Boolean'>
    readonly completed_at: FieldRef<"ActivityLog", 'DateTime'>
    readonly skipped: FieldRef<"ActivityLog", 'Boolean'>
    readonly skip_reason: FieldRef<"ActivityLog", 'String'>
    readonly notes: FieldRef<"ActivityLog", 'String'>
    readonly created_at: FieldRef<"ActivityLog", 'DateTime'>
    readonly updated_at: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseAccount
   */

  export type AggregateExpenseAccount = {
    _count: ExpenseAccountCountAggregateOutputType | null
    _avg: ExpenseAccountAvgAggregateOutputType | null
    _sum: ExpenseAccountSumAggregateOutputType | null
    _min: ExpenseAccountMinAggregateOutputType | null
    _max: ExpenseAccountMaxAggregateOutputType | null
  }

  export type ExpenseAccountAvgAggregateOutputType = {
    id: number | null
    balance: Decimal | null
  }

  export type ExpenseAccountSumAggregateOutputType = {
    id: number | null
    balance: Decimal | null
  }

  export type ExpenseAccountMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    icon: string | null
    color: string | null
    balance: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseAccountMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    icon: string | null
    color: string | null
    balance: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseAccountCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    name: number
    icon: number
    color: number
    balance: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExpenseAccountAvgAggregateInputType = {
    id?: true
    balance?: true
  }

  export type ExpenseAccountSumAggregateInputType = {
    id?: true
    balance?: true
  }

  export type ExpenseAccountMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    icon?: true
    color?: true
    balance?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseAccountMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    icon?: true
    color?: true
    balance?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseAccountCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    icon?: true
    color?: true
    balance?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExpenseAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseAccount to aggregate.
     */
    where?: ExpenseAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseAccounts to fetch.
     */
    orderBy?: ExpenseAccountOrderByWithRelationInput | ExpenseAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseAccounts
    **/
    _count?: true | ExpenseAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseAccountMaxAggregateInputType
  }

  export type GetExpenseAccountAggregateType<T extends ExpenseAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseAccount[P]>
      : GetScalarType<T[P], AggregateExpenseAccount[P]>
  }




  export type ExpenseAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseAccountWhereInput
    orderBy?: ExpenseAccountOrderByWithAggregationInput | ExpenseAccountOrderByWithAggregationInput[]
    by: ExpenseAccountScalarFieldEnum[] | ExpenseAccountScalarFieldEnum
    having?: ExpenseAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseAccountCountAggregateInputType | true
    _avg?: ExpenseAccountAvgAggregateInputType
    _sum?: ExpenseAccountSumAggregateInputType
    _min?: ExpenseAccountMinAggregateInputType
    _max?: ExpenseAccountMaxAggregateInputType
  }

  export type ExpenseAccountGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string
    name: string
    icon: string | null
    color: string | null
    balance: Decimal
    created_at: Date
    updated_at: Date
    _count: ExpenseAccountCountAggregateOutputType | null
    _avg: ExpenseAccountAvgAggregateOutputType | null
    _sum: ExpenseAccountSumAggregateOutputType | null
    _min: ExpenseAccountMinAggregateOutputType | null
    _max: ExpenseAccountMaxAggregateOutputType | null
  }

  type GetExpenseAccountGroupByPayload<T extends ExpenseAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseAccountGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseAccountGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    balance?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    entries_from?: boolean | ExpenseAccount$entries_fromArgs<ExtArgs>
    entries_to?: boolean | ExpenseAccount$entries_toArgs<ExtArgs>
    _count?: boolean | ExpenseAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseAccount"]>

  export type ExpenseAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    balance?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseAccount"]>

  export type ExpenseAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    balance?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseAccount"]>

  export type ExpenseAccountSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    balance?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExpenseAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "name" | "icon" | "color" | "balance" | "created_at" | "updated_at", ExtArgs["result"]["expenseAccount"]>
  export type ExpenseAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    entries_from?: boolean | ExpenseAccount$entries_fromArgs<ExtArgs>
    entries_to?: boolean | ExpenseAccount$entries_toArgs<ExtArgs>
    _count?: boolean | ExpenseAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExpenseAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExpenseAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      entries_from: Prisma.$ExpenseEntryPayload<ExtArgs>[]
      entries_to: Prisma.$ExpenseEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string
      name: string
      icon: string | null
      color: string | null
      balance: Prisma.Decimal
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["expenseAccount"]>
    composites: {}
  }

  type ExpenseAccountGetPayload<S extends boolean | null | undefined | ExpenseAccountDefaultArgs> = $Result.GetResult<Prisma.$ExpenseAccountPayload, S>

  type ExpenseAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseAccountCountAggregateInputType | true
    }

  export interface ExpenseAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseAccount'], meta: { name: 'ExpenseAccount' } }
    /**
     * Find zero or one ExpenseAccount that matches the filter.
     * @param {ExpenseAccountFindUniqueArgs} args - Arguments to find a ExpenseAccount
     * @example
     * // Get one ExpenseAccount
     * const expenseAccount = await prisma.expenseAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseAccountFindUniqueArgs>(args: SelectSubset<T, ExpenseAccountFindUniqueArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseAccountFindUniqueOrThrowArgs} args - Arguments to find a ExpenseAccount
     * @example
     * // Get one ExpenseAccount
     * const expenseAccount = await prisma.expenseAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAccountFindFirstArgs} args - Arguments to find a ExpenseAccount
     * @example
     * // Get one ExpenseAccount
     * const expenseAccount = await prisma.expenseAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseAccountFindFirstArgs>(args?: SelectSubset<T, ExpenseAccountFindFirstArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAccountFindFirstOrThrowArgs} args - Arguments to find a ExpenseAccount
     * @example
     * // Get one ExpenseAccount
     * const expenseAccount = await prisma.expenseAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseAccounts
     * const expenseAccounts = await prisma.expenseAccount.findMany()
     * 
     * // Get first 10 ExpenseAccounts
     * const expenseAccounts = await prisma.expenseAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseAccountWithIdOnly = await prisma.expenseAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseAccountFindManyArgs>(args?: SelectSubset<T, ExpenseAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseAccount.
     * @param {ExpenseAccountCreateArgs} args - Arguments to create a ExpenseAccount.
     * @example
     * // Create one ExpenseAccount
     * const ExpenseAccount = await prisma.expenseAccount.create({
     *   data: {
     *     // ... data to create a ExpenseAccount
     *   }
     * })
     * 
     */
    create<T extends ExpenseAccountCreateArgs>(args: SelectSubset<T, ExpenseAccountCreateArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseAccounts.
     * @param {ExpenseAccountCreateManyArgs} args - Arguments to create many ExpenseAccounts.
     * @example
     * // Create many ExpenseAccounts
     * const expenseAccount = await prisma.expenseAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseAccountCreateManyArgs>(args?: SelectSubset<T, ExpenseAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseAccounts and returns the data saved in the database.
     * @param {ExpenseAccountCreateManyAndReturnArgs} args - Arguments to create many ExpenseAccounts.
     * @example
     * // Create many ExpenseAccounts
     * const expenseAccount = await prisma.expenseAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseAccounts and only return the `id`
     * const expenseAccountWithIdOnly = await prisma.expenseAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseAccount.
     * @param {ExpenseAccountDeleteArgs} args - Arguments to delete one ExpenseAccount.
     * @example
     * // Delete one ExpenseAccount
     * const ExpenseAccount = await prisma.expenseAccount.delete({
     *   where: {
     *     // ... filter to delete one ExpenseAccount
     *   }
     * })
     * 
     */
    delete<T extends ExpenseAccountDeleteArgs>(args: SelectSubset<T, ExpenseAccountDeleteArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseAccount.
     * @param {ExpenseAccountUpdateArgs} args - Arguments to update one ExpenseAccount.
     * @example
     * // Update one ExpenseAccount
     * const expenseAccount = await prisma.expenseAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseAccountUpdateArgs>(args: SelectSubset<T, ExpenseAccountUpdateArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseAccounts.
     * @param {ExpenseAccountDeleteManyArgs} args - Arguments to filter ExpenseAccounts to delete.
     * @example
     * // Delete a few ExpenseAccounts
     * const { count } = await prisma.expenseAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseAccountDeleteManyArgs>(args?: SelectSubset<T, ExpenseAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseAccounts
     * const expenseAccount = await prisma.expenseAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseAccountUpdateManyArgs>(args: SelectSubset<T, ExpenseAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseAccounts and returns the data updated in the database.
     * @param {ExpenseAccountUpdateManyAndReturnArgs} args - Arguments to update many ExpenseAccounts.
     * @example
     * // Update many ExpenseAccounts
     * const expenseAccount = await prisma.expenseAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseAccounts and only return the `id`
     * const expenseAccountWithIdOnly = await prisma.expenseAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseAccount.
     * @param {ExpenseAccountUpsertArgs} args - Arguments to update or create a ExpenseAccount.
     * @example
     * // Update or create a ExpenseAccount
     * const expenseAccount = await prisma.expenseAccount.upsert({
     *   create: {
     *     // ... data to create a ExpenseAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseAccount we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseAccountUpsertArgs>(args: SelectSubset<T, ExpenseAccountUpsertArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAccountCountArgs} args - Arguments to filter ExpenseAccounts to count.
     * @example
     * // Count the number of ExpenseAccounts
     * const count = await prisma.expenseAccount.count({
     *   where: {
     *     // ... the filter for the ExpenseAccounts we want to count
     *   }
     * })
    **/
    count<T extends ExpenseAccountCountArgs>(
      args?: Subset<T, ExpenseAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAccountAggregateArgs>(args: Subset<T, ExpenseAccountAggregateArgs>): Prisma.PrismaPromise<GetExpenseAccountAggregateType<T>>

    /**
     * Group by ExpenseAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseAccountGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseAccount model
   */
  readonly fields: ExpenseAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entries_from<T extends ExpenseAccount$entries_fromArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseAccount$entries_fromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entries_to<T extends ExpenseAccount$entries_toArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseAccount$entries_toArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseAccount model
   */
  interface ExpenseAccountFieldRefs {
    readonly id: FieldRef<"ExpenseAccount", 'Int'>
    readonly uuid: FieldRef<"ExpenseAccount", 'String'>
    readonly user_uuid: FieldRef<"ExpenseAccount", 'String'>
    readonly name: FieldRef<"ExpenseAccount", 'String'>
    readonly icon: FieldRef<"ExpenseAccount", 'String'>
    readonly color: FieldRef<"ExpenseAccount", 'String'>
    readonly balance: FieldRef<"ExpenseAccount", 'Decimal'>
    readonly created_at: FieldRef<"ExpenseAccount", 'DateTime'>
    readonly updated_at: FieldRef<"ExpenseAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseAccount findUnique
   */
  export type ExpenseAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseAccount to fetch.
     */
    where: ExpenseAccountWhereUniqueInput
  }

  /**
   * ExpenseAccount findUniqueOrThrow
   */
  export type ExpenseAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseAccount to fetch.
     */
    where: ExpenseAccountWhereUniqueInput
  }

  /**
   * ExpenseAccount findFirst
   */
  export type ExpenseAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseAccount to fetch.
     */
    where?: ExpenseAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseAccounts to fetch.
     */
    orderBy?: ExpenseAccountOrderByWithRelationInput | ExpenseAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseAccounts.
     */
    cursor?: ExpenseAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseAccounts.
     */
    distinct?: ExpenseAccountScalarFieldEnum | ExpenseAccountScalarFieldEnum[]
  }

  /**
   * ExpenseAccount findFirstOrThrow
   */
  export type ExpenseAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseAccount to fetch.
     */
    where?: ExpenseAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseAccounts to fetch.
     */
    orderBy?: ExpenseAccountOrderByWithRelationInput | ExpenseAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseAccounts.
     */
    cursor?: ExpenseAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseAccounts.
     */
    distinct?: ExpenseAccountScalarFieldEnum | ExpenseAccountScalarFieldEnum[]
  }

  /**
   * ExpenseAccount findMany
   */
  export type ExpenseAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseAccounts to fetch.
     */
    where?: ExpenseAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseAccounts to fetch.
     */
    orderBy?: ExpenseAccountOrderByWithRelationInput | ExpenseAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseAccounts.
     */
    cursor?: ExpenseAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseAccounts.
     */
    skip?: number
    distinct?: ExpenseAccountScalarFieldEnum | ExpenseAccountScalarFieldEnum[]
  }

  /**
   * ExpenseAccount create
   */
  export type ExpenseAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseAccount.
     */
    data: XOR<ExpenseAccountCreateInput, ExpenseAccountUncheckedCreateInput>
  }

  /**
   * ExpenseAccount createMany
   */
  export type ExpenseAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseAccounts.
     */
    data: ExpenseAccountCreateManyInput | ExpenseAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseAccount createManyAndReturn
   */
  export type ExpenseAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseAccounts.
     */
    data: ExpenseAccountCreateManyInput | ExpenseAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseAccount update
   */
  export type ExpenseAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseAccount.
     */
    data: XOR<ExpenseAccountUpdateInput, ExpenseAccountUncheckedUpdateInput>
    /**
     * Choose, which ExpenseAccount to update.
     */
    where: ExpenseAccountWhereUniqueInput
  }

  /**
   * ExpenseAccount updateMany
   */
  export type ExpenseAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseAccounts.
     */
    data: XOR<ExpenseAccountUpdateManyMutationInput, ExpenseAccountUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseAccounts to update
     */
    where?: ExpenseAccountWhereInput
    /**
     * Limit how many ExpenseAccounts to update.
     */
    limit?: number
  }

  /**
   * ExpenseAccount updateManyAndReturn
   */
  export type ExpenseAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseAccounts.
     */
    data: XOR<ExpenseAccountUpdateManyMutationInput, ExpenseAccountUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseAccounts to update
     */
    where?: ExpenseAccountWhereInput
    /**
     * Limit how many ExpenseAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseAccount upsert
   */
  export type ExpenseAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseAccount to update in case it exists.
     */
    where: ExpenseAccountWhereUniqueInput
    /**
     * In case the ExpenseAccount found by the `where` argument doesn't exist, create a new ExpenseAccount with this data.
     */
    create: XOR<ExpenseAccountCreateInput, ExpenseAccountUncheckedCreateInput>
    /**
     * In case the ExpenseAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseAccountUpdateInput, ExpenseAccountUncheckedUpdateInput>
  }

  /**
   * ExpenseAccount delete
   */
  export type ExpenseAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    /**
     * Filter which ExpenseAccount to delete.
     */
    where: ExpenseAccountWhereUniqueInput
  }

  /**
   * ExpenseAccount deleteMany
   */
  export type ExpenseAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseAccounts to delete
     */
    where?: ExpenseAccountWhereInput
    /**
     * Limit how many ExpenseAccounts to delete.
     */
    limit?: number
  }

  /**
   * ExpenseAccount.entries_from
   */
  export type ExpenseAccount$entries_fromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    where?: ExpenseEntryWhereInput
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    cursor?: ExpenseEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseEntryScalarFieldEnum | ExpenseEntryScalarFieldEnum[]
  }

  /**
   * ExpenseAccount.entries_to
   */
  export type ExpenseAccount$entries_toArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    where?: ExpenseEntryWhereInput
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    cursor?: ExpenseEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseEntryScalarFieldEnum | ExpenseEntryScalarFieldEnum[]
  }

  /**
   * ExpenseAccount without action
   */
  export type ExpenseAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseCategory
   */

  export type AggregateExpenseCategory = {
    _count: ExpenseCategoryCountAggregateOutputType | null
    _avg: ExpenseCategoryAvgAggregateOutputType | null
    _sum: ExpenseCategorySumAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  export type ExpenseCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ExpenseCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ExpenseCategoryMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    icon: string | null
    color: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseCategoryMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    icon: string | null
    color: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseCategoryCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    name: number
    icon: number
    color: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExpenseCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ExpenseCategorySumAggregateInputType = {
    id?: true
  }

  export type ExpenseCategoryMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    icon?: true
    color?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseCategoryMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    icon?: true
    color?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseCategoryCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    icon?: true
    color?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExpenseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategory to aggregate.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseCategories
    **/
    _count?: true | ExpenseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type GetExpenseCategoryAggregateType<T extends ExpenseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseCategory[P]>
      : GetScalarType<T[P], AggregateExpenseCategory[P]>
  }




  export type ExpenseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithAggregationInput | ExpenseCategoryOrderByWithAggregationInput[]
    by: ExpenseCategoryScalarFieldEnum[] | ExpenseCategoryScalarFieldEnum
    having?: ExpenseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCategoryCountAggregateInputType | true
    _avg?: ExpenseCategoryAvgAggregateInputType
    _sum?: ExpenseCategorySumAggregateInputType
    _min?: ExpenseCategoryMinAggregateInputType
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type ExpenseCategoryGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string | null
    name: string
    icon: string | null
    color: string | null
    created_at: Date
    updated_at: Date
    _count: ExpenseCategoryCountAggregateOutputType | null
    _avg: ExpenseCategoryAvgAggregateOutputType | null
    _sum: ExpenseCategorySumAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  type GetExpenseCategoryGroupByPayload<T extends ExpenseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseCategory$userArgs<ExtArgs>
    subcategories?: boolean | ExpenseCategory$subcategoriesArgs<ExtArgs>
    entries?: boolean | ExpenseCategory$entriesArgs<ExtArgs>
    products?: boolean | ExpenseCategory$productsArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseCategory$userArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseCategory$userArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExpenseCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "name" | "icon" | "color" | "created_at" | "updated_at", ExtArgs["result"]["expenseCategory"]>
  export type ExpenseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseCategory$userArgs<ExtArgs>
    subcategories?: boolean | ExpenseCategory$subcategoriesArgs<ExtArgs>
    entries?: boolean | ExpenseCategory$entriesArgs<ExtArgs>
    products?: boolean | ExpenseCategory$productsArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseCategory$userArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseCategory$userArgs<ExtArgs>
  }

  export type $ExpenseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseCategory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      subcategories: Prisma.$ExpenseSubcategoryPayload<ExtArgs>[]
      entries: Prisma.$ExpenseEntryPayload<ExtArgs>[]
      products: Prisma.$ExpenseProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string | null
      name: string
      icon: string | null
      color: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["expenseCategory"]>
    composites: {}
  }

  type ExpenseCategoryGetPayload<S extends boolean | null | undefined | ExpenseCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseCategoryPayload, S>

  type ExpenseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCategoryCountAggregateInputType | true
    }

  export interface ExpenseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseCategory'], meta: { name: 'ExpenseCategory' } }
    /**
     * Find zero or one ExpenseCategory that matches the filter.
     * @param {ExpenseCategoryFindUniqueArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseCategoryFindUniqueArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseCategoryFindFirstArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany()
     * 
     * // Get first 10 ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseCategoryFindManyArgs>(args?: SelectSubset<T, ExpenseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseCategory.
     * @param {ExpenseCategoryCreateArgs} args - Arguments to create a ExpenseCategory.
     * @example
     * // Create one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.create({
     *   data: {
     *     // ... data to create a ExpenseCategory
     *   }
     * })
     * 
     */
    create<T extends ExpenseCategoryCreateArgs>(args: SelectSubset<T, ExpenseCategoryCreateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseCategories.
     * @param {ExpenseCategoryCreateManyArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCategoryCreateManyArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseCategories and returns the data saved in the database.
     * @param {ExpenseCategoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseCategory.
     * @param {ExpenseCategoryDeleteArgs} args - Arguments to delete one ExpenseCategory.
     * @example
     * // Delete one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseCategory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseCategoryDeleteArgs>(args: SelectSubset<T, ExpenseCategoryDeleteArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseCategory.
     * @param {ExpenseCategoryUpdateArgs} args - Arguments to update one ExpenseCategory.
     * @example
     * // Update one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseCategoryUpdateArgs>(args: SelectSubset<T, ExpenseCategoryUpdateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseCategories.
     * @param {ExpenseCategoryDeleteManyArgs} args - Arguments to filter ExpenseCategories to delete.
     * @example
     * // Delete a few ExpenseCategories
     * const { count } = await prisma.expenseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseCategoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseCategoryUpdateManyArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories and returns the data updated in the database.
     * @param {ExpenseCategoryUpdateManyAndReturnArgs} args - Arguments to update many ExpenseCategories.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseCategory.
     * @param {ExpenseCategoryUpsertArgs} args - Arguments to update or create a ExpenseCategory.
     * @example
     * // Update or create a ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.upsert({
     *   create: {
     *     // ... data to create a ExpenseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseCategoryUpsertArgs>(args: SelectSubset<T, ExpenseCategoryUpsertArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryCountArgs} args - Arguments to filter ExpenseCategories to count.
     * @example
     * // Count the number of ExpenseCategories
     * const count = await prisma.expenseCategory.count({
     *   where: {
     *     // ... the filter for the ExpenseCategories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCategoryCountArgs>(
      args?: Subset<T, ExpenseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseCategoryAggregateArgs>(args: Subset<T, ExpenseCategoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseCategoryAggregateType<T>>

    /**
     * Group by ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseCategory model
   */
  readonly fields: ExpenseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ExpenseCategory$userArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subcategories<T extends ExpenseCategory$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entries<T extends ExpenseCategory$entriesArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends ExpenseCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseCategory model
   */
  interface ExpenseCategoryFieldRefs {
    readonly id: FieldRef<"ExpenseCategory", 'Int'>
    readonly uuid: FieldRef<"ExpenseCategory", 'String'>
    readonly user_uuid: FieldRef<"ExpenseCategory", 'String'>
    readonly name: FieldRef<"ExpenseCategory", 'String'>
    readonly icon: FieldRef<"ExpenseCategory", 'String'>
    readonly color: FieldRef<"ExpenseCategory", 'String'>
    readonly created_at: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly updated_at: FieldRef<"ExpenseCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseCategory findUnique
   */
  export type ExpenseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findUniqueOrThrow
   */
  export type ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findFirst
   */
  export type ExpenseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findFirstOrThrow
   */
  export type ExpenseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findMany
   */
  export type ExpenseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategories to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory create
   */
  export type ExpenseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
  }

  /**
   * ExpenseCategory createMany
   */
  export type ExpenseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseCategory createManyAndReturn
   */
  export type ExpenseCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseCategory update
   */
  export type ExpenseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseCategory to update.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory updateMany
   */
  export type ExpenseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
  }

  /**
   * ExpenseCategory updateManyAndReturn
   */
  export type ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseCategory upsert
   */
  export type ExpenseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseCategory to update in case it exists.
     */
    where: ExpenseCategoryWhereUniqueInput
    /**
     * In case the ExpenseCategory found by the `where` argument doesn't exist, create a new ExpenseCategory with this data.
     */
    create: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
    /**
     * In case the ExpenseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
  }

  /**
   * ExpenseCategory delete
   */
  export type ExpenseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseCategory to delete.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory deleteMany
   */
  export type ExpenseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategories to delete
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to delete.
     */
    limit?: number
  }

  /**
   * ExpenseCategory.user
   */
  export type ExpenseCategory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ExpenseCategory.subcategories
   */
  export type ExpenseCategory$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    where?: ExpenseSubcategoryWhereInput
    orderBy?: ExpenseSubcategoryOrderByWithRelationInput | ExpenseSubcategoryOrderByWithRelationInput[]
    cursor?: ExpenseSubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseSubcategoryScalarFieldEnum | ExpenseSubcategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory.entries
   */
  export type ExpenseCategory$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    where?: ExpenseEntryWhereInput
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    cursor?: ExpenseEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseEntryScalarFieldEnum | ExpenseEntryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory.products
   */
  export type ExpenseCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    where?: ExpenseProductWhereInput
    orderBy?: ExpenseProductOrderByWithRelationInput | ExpenseProductOrderByWithRelationInput[]
    cursor?: ExpenseProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseProductScalarFieldEnum | ExpenseProductScalarFieldEnum[]
  }

  /**
   * ExpenseCategory without action
   */
  export type ExpenseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseSubcategory
   */

  export type AggregateExpenseSubcategory = {
    _count: ExpenseSubcategoryCountAggregateOutputType | null
    _avg: ExpenseSubcategoryAvgAggregateOutputType | null
    _sum: ExpenseSubcategorySumAggregateOutputType | null
    _min: ExpenseSubcategoryMinAggregateOutputType | null
    _max: ExpenseSubcategoryMaxAggregateOutputType | null
  }

  export type ExpenseSubcategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ExpenseSubcategorySumAggregateOutputType = {
    id: number | null
  }

  export type ExpenseSubcategoryMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    category_uuid: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseSubcategoryMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    category_uuid: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseSubcategoryCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    category_uuid: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExpenseSubcategoryAvgAggregateInputType = {
    id?: true
  }

  export type ExpenseSubcategorySumAggregateInputType = {
    id?: true
  }

  export type ExpenseSubcategoryMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    category_uuid?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseSubcategoryMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    category_uuid?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseSubcategoryCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    category_uuid?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExpenseSubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseSubcategory to aggregate.
     */
    where?: ExpenseSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseSubcategories to fetch.
     */
    orderBy?: ExpenseSubcategoryOrderByWithRelationInput | ExpenseSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseSubcategories
    **/
    _count?: true | ExpenseSubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseSubcategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSubcategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseSubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseSubcategoryMaxAggregateInputType
  }

  export type GetExpenseSubcategoryAggregateType<T extends ExpenseSubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseSubcategory[P]>
      : GetScalarType<T[P], AggregateExpenseSubcategory[P]>
  }




  export type ExpenseSubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseSubcategoryWhereInput
    orderBy?: ExpenseSubcategoryOrderByWithAggregationInput | ExpenseSubcategoryOrderByWithAggregationInput[]
    by: ExpenseSubcategoryScalarFieldEnum[] | ExpenseSubcategoryScalarFieldEnum
    having?: ExpenseSubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseSubcategoryCountAggregateInputType | true
    _avg?: ExpenseSubcategoryAvgAggregateInputType
    _sum?: ExpenseSubcategorySumAggregateInputType
    _min?: ExpenseSubcategoryMinAggregateInputType
    _max?: ExpenseSubcategoryMaxAggregateInputType
  }

  export type ExpenseSubcategoryGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string | null
    category_uuid: string
    name: string
    created_at: Date
    updated_at: Date
    _count: ExpenseSubcategoryCountAggregateOutputType | null
    _avg: ExpenseSubcategoryAvgAggregateOutputType | null
    _sum: ExpenseSubcategorySumAggregateOutputType | null
    _min: ExpenseSubcategoryMinAggregateOutputType | null
    _max: ExpenseSubcategoryMaxAggregateOutputType | null
  }

  type GetExpenseSubcategoryGroupByPayload<T extends ExpenseSubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseSubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseSubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseSubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseSubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    category_uuid?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseSubcategory$userArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    entries?: boolean | ExpenseSubcategory$entriesArgs<ExtArgs>
    products?: boolean | ExpenseSubcategory$productsArgs<ExtArgs>
    _count?: boolean | ExpenseSubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseSubcategory"]>

  export type ExpenseSubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    category_uuid?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseSubcategory$userArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseSubcategory"]>

  export type ExpenseSubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    category_uuid?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseSubcategory$userArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseSubcategory"]>

  export type ExpenseSubcategorySelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    category_uuid?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExpenseSubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "category_uuid" | "name" | "created_at" | "updated_at", ExtArgs["result"]["expenseSubcategory"]>
  export type ExpenseSubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseSubcategory$userArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    entries?: boolean | ExpenseSubcategory$entriesArgs<ExtArgs>
    products?: boolean | ExpenseSubcategory$productsArgs<ExtArgs>
    _count?: boolean | ExpenseSubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseSubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseSubcategory$userArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }
  export type ExpenseSubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseSubcategory$userArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }

  export type $ExpenseSubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseSubcategory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      category: Prisma.$ExpenseCategoryPayload<ExtArgs>
      entries: Prisma.$ExpenseEntryPayload<ExtArgs>[]
      products: Prisma.$ExpenseProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string | null
      category_uuid: string
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["expenseSubcategory"]>
    composites: {}
  }

  type ExpenseSubcategoryGetPayload<S extends boolean | null | undefined | ExpenseSubcategoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseSubcategoryPayload, S>

  type ExpenseSubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseSubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseSubcategoryCountAggregateInputType | true
    }

  export interface ExpenseSubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseSubcategory'], meta: { name: 'ExpenseSubcategory' } }
    /**
     * Find zero or one ExpenseSubcategory that matches the filter.
     * @param {ExpenseSubcategoryFindUniqueArgs} args - Arguments to find a ExpenseSubcategory
     * @example
     * // Get one ExpenseSubcategory
     * const expenseSubcategory = await prisma.expenseSubcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseSubcategoryFindUniqueArgs>(args: SelectSubset<T, ExpenseSubcategoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseSubcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseSubcategoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseSubcategory
     * @example
     * // Get one ExpenseSubcategory
     * const expenseSubcategory = await prisma.expenseSubcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseSubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseSubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseSubcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSubcategoryFindFirstArgs} args - Arguments to find a ExpenseSubcategory
     * @example
     * // Get one ExpenseSubcategory
     * const expenseSubcategory = await prisma.expenseSubcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseSubcategoryFindFirstArgs>(args?: SelectSubset<T, ExpenseSubcategoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseSubcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSubcategoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseSubcategory
     * @example
     * // Get one ExpenseSubcategory
     * const expenseSubcategory = await prisma.expenseSubcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseSubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseSubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseSubcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseSubcategories
     * const expenseSubcategories = await prisma.expenseSubcategory.findMany()
     * 
     * // Get first 10 ExpenseSubcategories
     * const expenseSubcategories = await prisma.expenseSubcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseSubcategoryWithIdOnly = await prisma.expenseSubcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseSubcategoryFindManyArgs>(args?: SelectSubset<T, ExpenseSubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseSubcategory.
     * @param {ExpenseSubcategoryCreateArgs} args - Arguments to create a ExpenseSubcategory.
     * @example
     * // Create one ExpenseSubcategory
     * const ExpenseSubcategory = await prisma.expenseSubcategory.create({
     *   data: {
     *     // ... data to create a ExpenseSubcategory
     *   }
     * })
     * 
     */
    create<T extends ExpenseSubcategoryCreateArgs>(args: SelectSubset<T, ExpenseSubcategoryCreateArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseSubcategories.
     * @param {ExpenseSubcategoryCreateManyArgs} args - Arguments to create many ExpenseSubcategories.
     * @example
     * // Create many ExpenseSubcategories
     * const expenseSubcategory = await prisma.expenseSubcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseSubcategoryCreateManyArgs>(args?: SelectSubset<T, ExpenseSubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseSubcategories and returns the data saved in the database.
     * @param {ExpenseSubcategoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseSubcategories.
     * @example
     * // Create many ExpenseSubcategories
     * const expenseSubcategory = await prisma.expenseSubcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseSubcategories and only return the `id`
     * const expenseSubcategoryWithIdOnly = await prisma.expenseSubcategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseSubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseSubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseSubcategory.
     * @param {ExpenseSubcategoryDeleteArgs} args - Arguments to delete one ExpenseSubcategory.
     * @example
     * // Delete one ExpenseSubcategory
     * const ExpenseSubcategory = await prisma.expenseSubcategory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseSubcategory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseSubcategoryDeleteArgs>(args: SelectSubset<T, ExpenseSubcategoryDeleteArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseSubcategory.
     * @param {ExpenseSubcategoryUpdateArgs} args - Arguments to update one ExpenseSubcategory.
     * @example
     * // Update one ExpenseSubcategory
     * const expenseSubcategory = await prisma.expenseSubcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseSubcategoryUpdateArgs>(args: SelectSubset<T, ExpenseSubcategoryUpdateArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseSubcategories.
     * @param {ExpenseSubcategoryDeleteManyArgs} args - Arguments to filter ExpenseSubcategories to delete.
     * @example
     * // Delete a few ExpenseSubcategories
     * const { count } = await prisma.expenseSubcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseSubcategoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseSubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseSubcategories
     * const expenseSubcategory = await prisma.expenseSubcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseSubcategoryUpdateManyArgs>(args: SelectSubset<T, ExpenseSubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseSubcategories and returns the data updated in the database.
     * @param {ExpenseSubcategoryUpdateManyAndReturnArgs} args - Arguments to update many ExpenseSubcategories.
     * @example
     * // Update many ExpenseSubcategories
     * const expenseSubcategory = await prisma.expenseSubcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseSubcategories and only return the `id`
     * const expenseSubcategoryWithIdOnly = await prisma.expenseSubcategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseSubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseSubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseSubcategory.
     * @param {ExpenseSubcategoryUpsertArgs} args - Arguments to update or create a ExpenseSubcategory.
     * @example
     * // Update or create a ExpenseSubcategory
     * const expenseSubcategory = await prisma.expenseSubcategory.upsert({
     *   create: {
     *     // ... data to create a ExpenseSubcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseSubcategory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseSubcategoryUpsertArgs>(args: SelectSubset<T, ExpenseSubcategoryUpsertArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSubcategoryCountArgs} args - Arguments to filter ExpenseSubcategories to count.
     * @example
     * // Count the number of ExpenseSubcategories
     * const count = await prisma.expenseSubcategory.count({
     *   where: {
     *     // ... the filter for the ExpenseSubcategories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseSubcategoryCountArgs>(
      args?: Subset<T, ExpenseSubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseSubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseSubcategoryAggregateArgs>(args: Subset<T, ExpenseSubcategoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseSubcategoryAggregateType<T>>

    /**
     * Group by ExpenseSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseSubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseSubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseSubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseSubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseSubcategory model
   */
  readonly fields: ExpenseSubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseSubcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseSubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ExpenseSubcategory$userArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseSubcategory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends ExpenseCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategoryDefaultArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entries<T extends ExpenseSubcategory$entriesArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseSubcategory$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends ExpenseSubcategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseSubcategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseSubcategory model
   */
  interface ExpenseSubcategoryFieldRefs {
    readonly id: FieldRef<"ExpenseSubcategory", 'Int'>
    readonly uuid: FieldRef<"ExpenseSubcategory", 'String'>
    readonly user_uuid: FieldRef<"ExpenseSubcategory", 'String'>
    readonly category_uuid: FieldRef<"ExpenseSubcategory", 'String'>
    readonly name: FieldRef<"ExpenseSubcategory", 'String'>
    readonly created_at: FieldRef<"ExpenseSubcategory", 'DateTime'>
    readonly updated_at: FieldRef<"ExpenseSubcategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseSubcategory findUnique
   */
  export type ExpenseSubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSubcategory to fetch.
     */
    where: ExpenseSubcategoryWhereUniqueInput
  }

  /**
   * ExpenseSubcategory findUniqueOrThrow
   */
  export type ExpenseSubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSubcategory to fetch.
     */
    where: ExpenseSubcategoryWhereUniqueInput
  }

  /**
   * ExpenseSubcategory findFirst
   */
  export type ExpenseSubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSubcategory to fetch.
     */
    where?: ExpenseSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseSubcategories to fetch.
     */
    orderBy?: ExpenseSubcategoryOrderByWithRelationInput | ExpenseSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseSubcategories.
     */
    cursor?: ExpenseSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseSubcategories.
     */
    distinct?: ExpenseSubcategoryScalarFieldEnum | ExpenseSubcategoryScalarFieldEnum[]
  }

  /**
   * ExpenseSubcategory findFirstOrThrow
   */
  export type ExpenseSubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSubcategory to fetch.
     */
    where?: ExpenseSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseSubcategories to fetch.
     */
    orderBy?: ExpenseSubcategoryOrderByWithRelationInput | ExpenseSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseSubcategories.
     */
    cursor?: ExpenseSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseSubcategories.
     */
    distinct?: ExpenseSubcategoryScalarFieldEnum | ExpenseSubcategoryScalarFieldEnum[]
  }

  /**
   * ExpenseSubcategory findMany
   */
  export type ExpenseSubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSubcategories to fetch.
     */
    where?: ExpenseSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseSubcategories to fetch.
     */
    orderBy?: ExpenseSubcategoryOrderByWithRelationInput | ExpenseSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseSubcategories.
     */
    cursor?: ExpenseSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseSubcategories.
     */
    skip?: number
    distinct?: ExpenseSubcategoryScalarFieldEnum | ExpenseSubcategoryScalarFieldEnum[]
  }

  /**
   * ExpenseSubcategory create
   */
  export type ExpenseSubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseSubcategory.
     */
    data: XOR<ExpenseSubcategoryCreateInput, ExpenseSubcategoryUncheckedCreateInput>
  }

  /**
   * ExpenseSubcategory createMany
   */
  export type ExpenseSubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseSubcategories.
     */
    data: ExpenseSubcategoryCreateManyInput | ExpenseSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseSubcategory createManyAndReturn
   */
  export type ExpenseSubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseSubcategories.
     */
    data: ExpenseSubcategoryCreateManyInput | ExpenseSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseSubcategory update
   */
  export type ExpenseSubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseSubcategory.
     */
    data: XOR<ExpenseSubcategoryUpdateInput, ExpenseSubcategoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseSubcategory to update.
     */
    where: ExpenseSubcategoryWhereUniqueInput
  }

  /**
   * ExpenseSubcategory updateMany
   */
  export type ExpenseSubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseSubcategories.
     */
    data: XOR<ExpenseSubcategoryUpdateManyMutationInput, ExpenseSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseSubcategories to update
     */
    where?: ExpenseSubcategoryWhereInput
    /**
     * Limit how many ExpenseSubcategories to update.
     */
    limit?: number
  }

  /**
   * ExpenseSubcategory updateManyAndReturn
   */
  export type ExpenseSubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseSubcategories.
     */
    data: XOR<ExpenseSubcategoryUpdateManyMutationInput, ExpenseSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseSubcategories to update
     */
    where?: ExpenseSubcategoryWhereInput
    /**
     * Limit how many ExpenseSubcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseSubcategory upsert
   */
  export type ExpenseSubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseSubcategory to update in case it exists.
     */
    where: ExpenseSubcategoryWhereUniqueInput
    /**
     * In case the ExpenseSubcategory found by the `where` argument doesn't exist, create a new ExpenseSubcategory with this data.
     */
    create: XOR<ExpenseSubcategoryCreateInput, ExpenseSubcategoryUncheckedCreateInput>
    /**
     * In case the ExpenseSubcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseSubcategoryUpdateInput, ExpenseSubcategoryUncheckedUpdateInput>
  }

  /**
   * ExpenseSubcategory delete
   */
  export type ExpenseSubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseSubcategory to delete.
     */
    where: ExpenseSubcategoryWhereUniqueInput
  }

  /**
   * ExpenseSubcategory deleteMany
   */
  export type ExpenseSubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseSubcategories to delete
     */
    where?: ExpenseSubcategoryWhereInput
    /**
     * Limit how many ExpenseSubcategories to delete.
     */
    limit?: number
  }

  /**
   * ExpenseSubcategory.user
   */
  export type ExpenseSubcategory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ExpenseSubcategory.entries
   */
  export type ExpenseSubcategory$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    where?: ExpenseEntryWhereInput
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    cursor?: ExpenseEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseEntryScalarFieldEnum | ExpenseEntryScalarFieldEnum[]
  }

  /**
   * ExpenseSubcategory.products
   */
  export type ExpenseSubcategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    where?: ExpenseProductWhereInput
    orderBy?: ExpenseProductOrderByWithRelationInput | ExpenseProductOrderByWithRelationInput[]
    cursor?: ExpenseProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseProductScalarFieldEnum | ExpenseProductScalarFieldEnum[]
  }

  /**
   * ExpenseSubcategory without action
   */
  export type ExpenseSubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseEntry
   */

  export type AggregateExpenseEntry = {
    _count: ExpenseEntryCountAggregateOutputType | null
    _avg: ExpenseEntryAvgAggregateOutputType | null
    _sum: ExpenseEntrySumAggregateOutputType | null
    _min: ExpenseEntryMinAggregateOutputType | null
    _max: ExpenseEntryMaxAggregateOutputType | null
  }

  export type ExpenseEntryAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
  }

  export type ExpenseEntrySumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
  }

  export type ExpenseEntryMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    type: $Enums.ExpenseEntryType | null
    amount: Decimal | null
    description: string | null
    from_account_uuid: string | null
    to_account_uuid: string | null
    category_uuid: string | null
    subcategory_uuid: string | null
    entry_date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseEntryMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    type: $Enums.ExpenseEntryType | null
    amount: Decimal | null
    description: string | null
    from_account_uuid: string | null
    to_account_uuid: string | null
    category_uuid: string | null
    subcategory_uuid: string | null
    entry_date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseEntryCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    type: number
    amount: number
    description: number
    from_account_uuid: number
    to_account_uuid: number
    category_uuid: number
    subcategory_uuid: number
    entry_date: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExpenseEntryAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type ExpenseEntrySumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type ExpenseEntryMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    type?: true
    amount?: true
    description?: true
    from_account_uuid?: true
    to_account_uuid?: true
    category_uuid?: true
    subcategory_uuid?: true
    entry_date?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseEntryMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    type?: true
    amount?: true
    description?: true
    from_account_uuid?: true
    to_account_uuid?: true
    category_uuid?: true
    subcategory_uuid?: true
    entry_date?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseEntryCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    type?: true
    amount?: true
    description?: true
    from_account_uuid?: true
    to_account_uuid?: true
    category_uuid?: true
    subcategory_uuid?: true
    entry_date?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExpenseEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseEntry to aggregate.
     */
    where?: ExpenseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseEntries to fetch.
     */
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseEntries
    **/
    _count?: true | ExpenseEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseEntryMaxAggregateInputType
  }

  export type GetExpenseEntryAggregateType<T extends ExpenseEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseEntry[P]>
      : GetScalarType<T[P], AggregateExpenseEntry[P]>
  }




  export type ExpenseEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseEntryWhereInput
    orderBy?: ExpenseEntryOrderByWithAggregationInput | ExpenseEntryOrderByWithAggregationInput[]
    by: ExpenseEntryScalarFieldEnum[] | ExpenseEntryScalarFieldEnum
    having?: ExpenseEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseEntryCountAggregateInputType | true
    _avg?: ExpenseEntryAvgAggregateInputType
    _sum?: ExpenseEntrySumAggregateInputType
    _min?: ExpenseEntryMinAggregateInputType
    _max?: ExpenseEntryMaxAggregateInputType
  }

  export type ExpenseEntryGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal
    description: string | null
    from_account_uuid: string
    to_account_uuid: string | null
    category_uuid: string | null
    subcategory_uuid: string | null
    entry_date: Date
    created_at: Date
    updated_at: Date
    _count: ExpenseEntryCountAggregateOutputType | null
    _avg: ExpenseEntryAvgAggregateOutputType | null
    _sum: ExpenseEntrySumAggregateOutputType | null
    _min: ExpenseEntryMinAggregateOutputType | null
    _max: ExpenseEntryMaxAggregateOutputType | null
  }

  type GetExpenseEntryGroupByPayload<T extends ExpenseEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseEntryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseEntryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    from_account_uuid?: boolean
    to_account_uuid?: boolean
    category_uuid?: boolean
    subcategory_uuid?: boolean
    entry_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    from_account?: boolean | ExpenseAccountDefaultArgs<ExtArgs>
    to_account?: boolean | ExpenseEntry$to_accountArgs<ExtArgs>
    category?: boolean | ExpenseEntry$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseEntry$subcategoryArgs<ExtArgs>
    expense_receipt?: boolean | ExpenseEntry$expense_receiptArgs<ExtArgs>
  }, ExtArgs["result"]["expenseEntry"]>

  export type ExpenseEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    from_account_uuid?: boolean
    to_account_uuid?: boolean
    category_uuid?: boolean
    subcategory_uuid?: boolean
    entry_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    from_account?: boolean | ExpenseAccountDefaultArgs<ExtArgs>
    to_account?: boolean | ExpenseEntry$to_accountArgs<ExtArgs>
    category?: boolean | ExpenseEntry$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseEntry$subcategoryArgs<ExtArgs>
  }, ExtArgs["result"]["expenseEntry"]>

  export type ExpenseEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    from_account_uuid?: boolean
    to_account_uuid?: boolean
    category_uuid?: boolean
    subcategory_uuid?: boolean
    entry_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    from_account?: boolean | ExpenseAccountDefaultArgs<ExtArgs>
    to_account?: boolean | ExpenseEntry$to_accountArgs<ExtArgs>
    category?: boolean | ExpenseEntry$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseEntry$subcategoryArgs<ExtArgs>
  }, ExtArgs["result"]["expenseEntry"]>

  export type ExpenseEntrySelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    from_account_uuid?: boolean
    to_account_uuid?: boolean
    category_uuid?: boolean
    subcategory_uuid?: boolean
    entry_date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExpenseEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "type" | "amount" | "description" | "from_account_uuid" | "to_account_uuid" | "category_uuid" | "subcategory_uuid" | "entry_date" | "created_at" | "updated_at", ExtArgs["result"]["expenseEntry"]>
  export type ExpenseEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    from_account?: boolean | ExpenseAccountDefaultArgs<ExtArgs>
    to_account?: boolean | ExpenseEntry$to_accountArgs<ExtArgs>
    category?: boolean | ExpenseEntry$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseEntry$subcategoryArgs<ExtArgs>
    expense_receipt?: boolean | ExpenseEntry$expense_receiptArgs<ExtArgs>
  }
  export type ExpenseEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    from_account?: boolean | ExpenseAccountDefaultArgs<ExtArgs>
    to_account?: boolean | ExpenseEntry$to_accountArgs<ExtArgs>
    category?: boolean | ExpenseEntry$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseEntry$subcategoryArgs<ExtArgs>
  }
  export type ExpenseEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    from_account?: boolean | ExpenseAccountDefaultArgs<ExtArgs>
    to_account?: boolean | ExpenseEntry$to_accountArgs<ExtArgs>
    category?: boolean | ExpenseEntry$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseEntry$subcategoryArgs<ExtArgs>
  }

  export type $ExpenseEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      from_account: Prisma.$ExpenseAccountPayload<ExtArgs>
      to_account: Prisma.$ExpenseAccountPayload<ExtArgs> | null
      category: Prisma.$ExpenseCategoryPayload<ExtArgs> | null
      subcategory: Prisma.$ExpenseSubcategoryPayload<ExtArgs> | null
      expense_receipt: Prisma.$ExpenseReceiptPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string
      type: $Enums.ExpenseEntryType
      amount: Prisma.Decimal
      description: string | null
      from_account_uuid: string
      to_account_uuid: string | null
      category_uuid: string | null
      subcategory_uuid: string | null
      entry_date: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["expenseEntry"]>
    composites: {}
  }

  type ExpenseEntryGetPayload<S extends boolean | null | undefined | ExpenseEntryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseEntryPayload, S>

  type ExpenseEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseEntryCountAggregateInputType | true
    }

  export interface ExpenseEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseEntry'], meta: { name: 'ExpenseEntry' } }
    /**
     * Find zero or one ExpenseEntry that matches the filter.
     * @param {ExpenseEntryFindUniqueArgs} args - Arguments to find a ExpenseEntry
     * @example
     * // Get one ExpenseEntry
     * const expenseEntry = await prisma.expenseEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseEntryFindUniqueArgs>(args: SelectSubset<T, ExpenseEntryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseEntryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseEntry
     * @example
     * // Get one ExpenseEntry
     * const expenseEntry = await prisma.expenseEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseEntryFindFirstArgs} args - Arguments to find a ExpenseEntry
     * @example
     * // Get one ExpenseEntry
     * const expenseEntry = await prisma.expenseEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseEntryFindFirstArgs>(args?: SelectSubset<T, ExpenseEntryFindFirstArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseEntryFindFirstOrThrowArgs} args - Arguments to find a ExpenseEntry
     * @example
     * // Get one ExpenseEntry
     * const expenseEntry = await prisma.expenseEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseEntries
     * const expenseEntries = await prisma.expenseEntry.findMany()
     * 
     * // Get first 10 ExpenseEntries
     * const expenseEntries = await prisma.expenseEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseEntryWithIdOnly = await prisma.expenseEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseEntryFindManyArgs>(args?: SelectSubset<T, ExpenseEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseEntry.
     * @param {ExpenseEntryCreateArgs} args - Arguments to create a ExpenseEntry.
     * @example
     * // Create one ExpenseEntry
     * const ExpenseEntry = await prisma.expenseEntry.create({
     *   data: {
     *     // ... data to create a ExpenseEntry
     *   }
     * })
     * 
     */
    create<T extends ExpenseEntryCreateArgs>(args: SelectSubset<T, ExpenseEntryCreateArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseEntries.
     * @param {ExpenseEntryCreateManyArgs} args - Arguments to create many ExpenseEntries.
     * @example
     * // Create many ExpenseEntries
     * const expenseEntry = await prisma.expenseEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseEntryCreateManyArgs>(args?: SelectSubset<T, ExpenseEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseEntries and returns the data saved in the database.
     * @param {ExpenseEntryCreateManyAndReturnArgs} args - Arguments to create many ExpenseEntries.
     * @example
     * // Create many ExpenseEntries
     * const expenseEntry = await prisma.expenseEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseEntries and only return the `id`
     * const expenseEntryWithIdOnly = await prisma.expenseEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseEntry.
     * @param {ExpenseEntryDeleteArgs} args - Arguments to delete one ExpenseEntry.
     * @example
     * // Delete one ExpenseEntry
     * const ExpenseEntry = await prisma.expenseEntry.delete({
     *   where: {
     *     // ... filter to delete one ExpenseEntry
     *   }
     * })
     * 
     */
    delete<T extends ExpenseEntryDeleteArgs>(args: SelectSubset<T, ExpenseEntryDeleteArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseEntry.
     * @param {ExpenseEntryUpdateArgs} args - Arguments to update one ExpenseEntry.
     * @example
     * // Update one ExpenseEntry
     * const expenseEntry = await prisma.expenseEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseEntryUpdateArgs>(args: SelectSubset<T, ExpenseEntryUpdateArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseEntries.
     * @param {ExpenseEntryDeleteManyArgs} args - Arguments to filter ExpenseEntries to delete.
     * @example
     * // Delete a few ExpenseEntries
     * const { count } = await prisma.expenseEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseEntryDeleteManyArgs>(args?: SelectSubset<T, ExpenseEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseEntries
     * const expenseEntry = await prisma.expenseEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseEntryUpdateManyArgs>(args: SelectSubset<T, ExpenseEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseEntries and returns the data updated in the database.
     * @param {ExpenseEntryUpdateManyAndReturnArgs} args - Arguments to update many ExpenseEntries.
     * @example
     * // Update many ExpenseEntries
     * const expenseEntry = await prisma.expenseEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseEntries and only return the `id`
     * const expenseEntryWithIdOnly = await prisma.expenseEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseEntry.
     * @param {ExpenseEntryUpsertArgs} args - Arguments to update or create a ExpenseEntry.
     * @example
     * // Update or create a ExpenseEntry
     * const expenseEntry = await prisma.expenseEntry.upsert({
     *   create: {
     *     // ... data to create a ExpenseEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseEntry we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseEntryUpsertArgs>(args: SelectSubset<T, ExpenseEntryUpsertArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseEntryCountArgs} args - Arguments to filter ExpenseEntries to count.
     * @example
     * // Count the number of ExpenseEntries
     * const count = await prisma.expenseEntry.count({
     *   where: {
     *     // ... the filter for the ExpenseEntries we want to count
     *   }
     * })
    **/
    count<T extends ExpenseEntryCountArgs>(
      args?: Subset<T, ExpenseEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseEntryAggregateArgs>(args: Subset<T, ExpenseEntryAggregateArgs>): Prisma.PrismaPromise<GetExpenseEntryAggregateType<T>>

    /**
     * Group by ExpenseEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseEntryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseEntry model
   */
  readonly fields: ExpenseEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    from_account<T extends ExpenseAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseAccountDefaultArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    to_account<T extends ExpenseEntry$to_accountArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseEntry$to_accountArgs<ExtArgs>>): Prisma__ExpenseAccountClient<$Result.GetResult<Prisma.$ExpenseAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends ExpenseEntry$categoryArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseEntry$categoryArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends ExpenseEntry$subcategoryArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseEntry$subcategoryArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    expense_receipt<T extends ExpenseEntry$expense_receiptArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseEntry$expense_receiptArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseEntry model
   */
  interface ExpenseEntryFieldRefs {
    readonly id: FieldRef<"ExpenseEntry", 'Int'>
    readonly uuid: FieldRef<"ExpenseEntry", 'String'>
    readonly user_uuid: FieldRef<"ExpenseEntry", 'String'>
    readonly type: FieldRef<"ExpenseEntry", 'ExpenseEntryType'>
    readonly amount: FieldRef<"ExpenseEntry", 'Decimal'>
    readonly description: FieldRef<"ExpenseEntry", 'String'>
    readonly from_account_uuid: FieldRef<"ExpenseEntry", 'String'>
    readonly to_account_uuid: FieldRef<"ExpenseEntry", 'String'>
    readonly category_uuid: FieldRef<"ExpenseEntry", 'String'>
    readonly subcategory_uuid: FieldRef<"ExpenseEntry", 'String'>
    readonly entry_date: FieldRef<"ExpenseEntry", 'DateTime'>
    readonly created_at: FieldRef<"ExpenseEntry", 'DateTime'>
    readonly updated_at: FieldRef<"ExpenseEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseEntry findUnique
   */
  export type ExpenseEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseEntry to fetch.
     */
    where: ExpenseEntryWhereUniqueInput
  }

  /**
   * ExpenseEntry findUniqueOrThrow
   */
  export type ExpenseEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseEntry to fetch.
     */
    where: ExpenseEntryWhereUniqueInput
  }

  /**
   * ExpenseEntry findFirst
   */
  export type ExpenseEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseEntry to fetch.
     */
    where?: ExpenseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseEntries to fetch.
     */
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseEntries.
     */
    cursor?: ExpenseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseEntries.
     */
    distinct?: ExpenseEntryScalarFieldEnum | ExpenseEntryScalarFieldEnum[]
  }

  /**
   * ExpenseEntry findFirstOrThrow
   */
  export type ExpenseEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseEntry to fetch.
     */
    where?: ExpenseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseEntries to fetch.
     */
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseEntries.
     */
    cursor?: ExpenseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseEntries.
     */
    distinct?: ExpenseEntryScalarFieldEnum | ExpenseEntryScalarFieldEnum[]
  }

  /**
   * ExpenseEntry findMany
   */
  export type ExpenseEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseEntries to fetch.
     */
    where?: ExpenseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseEntries to fetch.
     */
    orderBy?: ExpenseEntryOrderByWithRelationInput | ExpenseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseEntries.
     */
    cursor?: ExpenseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseEntries.
     */
    skip?: number
    distinct?: ExpenseEntryScalarFieldEnum | ExpenseEntryScalarFieldEnum[]
  }

  /**
   * ExpenseEntry create
   */
  export type ExpenseEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseEntry.
     */
    data: XOR<ExpenseEntryCreateInput, ExpenseEntryUncheckedCreateInput>
  }

  /**
   * ExpenseEntry createMany
   */
  export type ExpenseEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseEntries.
     */
    data: ExpenseEntryCreateManyInput | ExpenseEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseEntry createManyAndReturn
   */
  export type ExpenseEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseEntries.
     */
    data: ExpenseEntryCreateManyInput | ExpenseEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseEntry update
   */
  export type ExpenseEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseEntry.
     */
    data: XOR<ExpenseEntryUpdateInput, ExpenseEntryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseEntry to update.
     */
    where: ExpenseEntryWhereUniqueInput
  }

  /**
   * ExpenseEntry updateMany
   */
  export type ExpenseEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseEntries.
     */
    data: XOR<ExpenseEntryUpdateManyMutationInput, ExpenseEntryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseEntries to update
     */
    where?: ExpenseEntryWhereInput
    /**
     * Limit how many ExpenseEntries to update.
     */
    limit?: number
  }

  /**
   * ExpenseEntry updateManyAndReturn
   */
  export type ExpenseEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseEntries.
     */
    data: XOR<ExpenseEntryUpdateManyMutationInput, ExpenseEntryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseEntries to update
     */
    where?: ExpenseEntryWhereInput
    /**
     * Limit how many ExpenseEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseEntry upsert
   */
  export type ExpenseEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseEntry to update in case it exists.
     */
    where: ExpenseEntryWhereUniqueInput
    /**
     * In case the ExpenseEntry found by the `where` argument doesn't exist, create a new ExpenseEntry with this data.
     */
    create: XOR<ExpenseEntryCreateInput, ExpenseEntryUncheckedCreateInput>
    /**
     * In case the ExpenseEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseEntryUpdateInput, ExpenseEntryUncheckedUpdateInput>
  }

  /**
   * ExpenseEntry delete
   */
  export type ExpenseEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseEntry to delete.
     */
    where: ExpenseEntryWhereUniqueInput
  }

  /**
   * ExpenseEntry deleteMany
   */
  export type ExpenseEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseEntries to delete
     */
    where?: ExpenseEntryWhereInput
    /**
     * Limit how many ExpenseEntries to delete.
     */
    limit?: number
  }

  /**
   * ExpenseEntry.to_account
   */
  export type ExpenseEntry$to_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseAccount
     */
    select?: ExpenseAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseAccount
     */
    omit?: ExpenseAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseAccountInclude<ExtArgs> | null
    where?: ExpenseAccountWhereInput
  }

  /**
   * ExpenseEntry.category
   */
  export type ExpenseEntry$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
  }

  /**
   * ExpenseEntry.subcategory
   */
  export type ExpenseEntry$subcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    where?: ExpenseSubcategoryWhereInput
  }

  /**
   * ExpenseEntry.expense_receipt
   */
  export type ExpenseEntry$expense_receiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    where?: ExpenseReceiptWhereInput
  }

  /**
   * ExpenseEntry without action
   */
  export type ExpenseEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseEntry
     */
    select?: ExpenseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseEntry
     */
    omit?: ExpenseEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseEntryInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseStore
   */

  export type AggregateExpenseStore = {
    _count: ExpenseStoreCountAggregateOutputType | null
    _avg: ExpenseStoreAvgAggregateOutputType | null
    _sum: ExpenseStoreSumAggregateOutputType | null
    _min: ExpenseStoreMinAggregateOutputType | null
    _max: ExpenseStoreMaxAggregateOutputType | null
  }

  export type ExpenseStoreAvgAggregateOutputType = {
    id: number | null
  }

  export type ExpenseStoreSumAggregateOutputType = {
    id: number | null
  }

  export type ExpenseStoreMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseStoreMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseStoreCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExpenseStoreAvgAggregateInputType = {
    id?: true
  }

  export type ExpenseStoreSumAggregateInputType = {
    id?: true
  }

  export type ExpenseStoreMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseStoreMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseStoreCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExpenseStoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseStore to aggregate.
     */
    where?: ExpenseStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseStores to fetch.
     */
    orderBy?: ExpenseStoreOrderByWithRelationInput | ExpenseStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseStores
    **/
    _count?: true | ExpenseStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseStoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseStoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseStoreMaxAggregateInputType
  }

  export type GetExpenseStoreAggregateType<T extends ExpenseStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseStore[P]>
      : GetScalarType<T[P], AggregateExpenseStore[P]>
  }




  export type ExpenseStoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseStoreWhereInput
    orderBy?: ExpenseStoreOrderByWithAggregationInput | ExpenseStoreOrderByWithAggregationInput[]
    by: ExpenseStoreScalarFieldEnum[] | ExpenseStoreScalarFieldEnum
    having?: ExpenseStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseStoreCountAggregateInputType | true
    _avg?: ExpenseStoreAvgAggregateInputType
    _sum?: ExpenseStoreSumAggregateInputType
    _min?: ExpenseStoreMinAggregateInputType
    _max?: ExpenseStoreMaxAggregateInputType
  }

  export type ExpenseStoreGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string | null
    name: string
    created_at: Date
    updated_at: Date
    _count: ExpenseStoreCountAggregateOutputType | null
    _avg: ExpenseStoreAvgAggregateOutputType | null
    _sum: ExpenseStoreSumAggregateOutputType | null
    _min: ExpenseStoreMinAggregateOutputType | null
    _max: ExpenseStoreMaxAggregateOutputType | null
  }

  type GetExpenseStoreGroupByPayload<T extends ExpenseStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseStoreGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseStoreGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseStoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseStore$userArgs<ExtArgs>
    receipts?: boolean | ExpenseStore$receiptsArgs<ExtArgs>
    _count?: boolean | ExpenseStoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseStore"]>

  export type ExpenseStoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseStore$userArgs<ExtArgs>
  }, ExtArgs["result"]["expenseStore"]>

  export type ExpenseStoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseStore$userArgs<ExtArgs>
  }, ExtArgs["result"]["expenseStore"]>

  export type ExpenseStoreSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExpenseStoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "name" | "created_at" | "updated_at", ExtArgs["result"]["expenseStore"]>
  export type ExpenseStoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseStore$userArgs<ExtArgs>
    receipts?: boolean | ExpenseStore$receiptsArgs<ExtArgs>
    _count?: boolean | ExpenseStoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseStoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseStore$userArgs<ExtArgs>
  }
  export type ExpenseStoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseStore$userArgs<ExtArgs>
  }

  export type $ExpenseStorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseStore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      receipts: Prisma.$ExpenseReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string | null
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["expenseStore"]>
    composites: {}
  }

  type ExpenseStoreGetPayload<S extends boolean | null | undefined | ExpenseStoreDefaultArgs> = $Result.GetResult<Prisma.$ExpenseStorePayload, S>

  type ExpenseStoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseStoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseStoreCountAggregateInputType | true
    }

  export interface ExpenseStoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseStore'], meta: { name: 'ExpenseStore' } }
    /**
     * Find zero or one ExpenseStore that matches the filter.
     * @param {ExpenseStoreFindUniqueArgs} args - Arguments to find a ExpenseStore
     * @example
     * // Get one ExpenseStore
     * const expenseStore = await prisma.expenseStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseStoreFindUniqueArgs>(args: SelectSubset<T, ExpenseStoreFindUniqueArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseStore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseStoreFindUniqueOrThrowArgs} args - Arguments to find a ExpenseStore
     * @example
     * // Get one ExpenseStore
     * const expenseStore = await prisma.expenseStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseStoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseStoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseStoreFindFirstArgs} args - Arguments to find a ExpenseStore
     * @example
     * // Get one ExpenseStore
     * const expenseStore = await prisma.expenseStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseStoreFindFirstArgs>(args?: SelectSubset<T, ExpenseStoreFindFirstArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseStore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseStoreFindFirstOrThrowArgs} args - Arguments to find a ExpenseStore
     * @example
     * // Get one ExpenseStore
     * const expenseStore = await prisma.expenseStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseStoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseStoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseStoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseStores
     * const expenseStores = await prisma.expenseStore.findMany()
     * 
     * // Get first 10 ExpenseStores
     * const expenseStores = await prisma.expenseStore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseStoreWithIdOnly = await prisma.expenseStore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseStoreFindManyArgs>(args?: SelectSubset<T, ExpenseStoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseStore.
     * @param {ExpenseStoreCreateArgs} args - Arguments to create a ExpenseStore.
     * @example
     * // Create one ExpenseStore
     * const ExpenseStore = await prisma.expenseStore.create({
     *   data: {
     *     // ... data to create a ExpenseStore
     *   }
     * })
     * 
     */
    create<T extends ExpenseStoreCreateArgs>(args: SelectSubset<T, ExpenseStoreCreateArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseStores.
     * @param {ExpenseStoreCreateManyArgs} args - Arguments to create many ExpenseStores.
     * @example
     * // Create many ExpenseStores
     * const expenseStore = await prisma.expenseStore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseStoreCreateManyArgs>(args?: SelectSubset<T, ExpenseStoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseStores and returns the data saved in the database.
     * @param {ExpenseStoreCreateManyAndReturnArgs} args - Arguments to create many ExpenseStores.
     * @example
     * // Create many ExpenseStores
     * const expenseStore = await prisma.expenseStore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseStores and only return the `id`
     * const expenseStoreWithIdOnly = await prisma.expenseStore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseStoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseStoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseStore.
     * @param {ExpenseStoreDeleteArgs} args - Arguments to delete one ExpenseStore.
     * @example
     * // Delete one ExpenseStore
     * const ExpenseStore = await prisma.expenseStore.delete({
     *   where: {
     *     // ... filter to delete one ExpenseStore
     *   }
     * })
     * 
     */
    delete<T extends ExpenseStoreDeleteArgs>(args: SelectSubset<T, ExpenseStoreDeleteArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseStore.
     * @param {ExpenseStoreUpdateArgs} args - Arguments to update one ExpenseStore.
     * @example
     * // Update one ExpenseStore
     * const expenseStore = await prisma.expenseStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseStoreUpdateArgs>(args: SelectSubset<T, ExpenseStoreUpdateArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseStores.
     * @param {ExpenseStoreDeleteManyArgs} args - Arguments to filter ExpenseStores to delete.
     * @example
     * // Delete a few ExpenseStores
     * const { count } = await prisma.expenseStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseStoreDeleteManyArgs>(args?: SelectSubset<T, ExpenseStoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseStores
     * const expenseStore = await prisma.expenseStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseStoreUpdateManyArgs>(args: SelectSubset<T, ExpenseStoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseStores and returns the data updated in the database.
     * @param {ExpenseStoreUpdateManyAndReturnArgs} args - Arguments to update many ExpenseStores.
     * @example
     * // Update many ExpenseStores
     * const expenseStore = await prisma.expenseStore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseStores and only return the `id`
     * const expenseStoreWithIdOnly = await prisma.expenseStore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseStoreUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseStoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseStore.
     * @param {ExpenseStoreUpsertArgs} args - Arguments to update or create a ExpenseStore.
     * @example
     * // Update or create a ExpenseStore
     * const expenseStore = await prisma.expenseStore.upsert({
     *   create: {
     *     // ... data to create a ExpenseStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseStore we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseStoreUpsertArgs>(args: SelectSubset<T, ExpenseStoreUpsertArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseStoreCountArgs} args - Arguments to filter ExpenseStores to count.
     * @example
     * // Count the number of ExpenseStores
     * const count = await prisma.expenseStore.count({
     *   where: {
     *     // ... the filter for the ExpenseStores we want to count
     *   }
     * })
    **/
    count<T extends ExpenseStoreCountArgs>(
      args?: Subset<T, ExpenseStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseStoreAggregateArgs>(args: Subset<T, ExpenseStoreAggregateArgs>): Prisma.PrismaPromise<GetExpenseStoreAggregateType<T>>

    /**
     * Group by ExpenseStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseStoreGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseStore model
   */
  readonly fields: ExpenseStoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseStoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ExpenseStore$userArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseStore$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    receipts<T extends ExpenseStore$receiptsArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseStore$receiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseStore model
   */
  interface ExpenseStoreFieldRefs {
    readonly id: FieldRef<"ExpenseStore", 'Int'>
    readonly uuid: FieldRef<"ExpenseStore", 'String'>
    readonly user_uuid: FieldRef<"ExpenseStore", 'String'>
    readonly name: FieldRef<"ExpenseStore", 'String'>
    readonly created_at: FieldRef<"ExpenseStore", 'DateTime'>
    readonly updated_at: FieldRef<"ExpenseStore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseStore findUnique
   */
  export type ExpenseStoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseStore to fetch.
     */
    where: ExpenseStoreWhereUniqueInput
  }

  /**
   * ExpenseStore findUniqueOrThrow
   */
  export type ExpenseStoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseStore to fetch.
     */
    where: ExpenseStoreWhereUniqueInput
  }

  /**
   * ExpenseStore findFirst
   */
  export type ExpenseStoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseStore to fetch.
     */
    where?: ExpenseStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseStores to fetch.
     */
    orderBy?: ExpenseStoreOrderByWithRelationInput | ExpenseStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseStores.
     */
    cursor?: ExpenseStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseStores.
     */
    distinct?: ExpenseStoreScalarFieldEnum | ExpenseStoreScalarFieldEnum[]
  }

  /**
   * ExpenseStore findFirstOrThrow
   */
  export type ExpenseStoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseStore to fetch.
     */
    where?: ExpenseStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseStores to fetch.
     */
    orderBy?: ExpenseStoreOrderByWithRelationInput | ExpenseStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseStores.
     */
    cursor?: ExpenseStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseStores.
     */
    distinct?: ExpenseStoreScalarFieldEnum | ExpenseStoreScalarFieldEnum[]
  }

  /**
   * ExpenseStore findMany
   */
  export type ExpenseStoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseStores to fetch.
     */
    where?: ExpenseStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseStores to fetch.
     */
    orderBy?: ExpenseStoreOrderByWithRelationInput | ExpenseStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseStores.
     */
    cursor?: ExpenseStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseStores.
     */
    skip?: number
    distinct?: ExpenseStoreScalarFieldEnum | ExpenseStoreScalarFieldEnum[]
  }

  /**
   * ExpenseStore create
   */
  export type ExpenseStoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseStore.
     */
    data: XOR<ExpenseStoreCreateInput, ExpenseStoreUncheckedCreateInput>
  }

  /**
   * ExpenseStore createMany
   */
  export type ExpenseStoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseStores.
     */
    data: ExpenseStoreCreateManyInput | ExpenseStoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseStore createManyAndReturn
   */
  export type ExpenseStoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseStores.
     */
    data: ExpenseStoreCreateManyInput | ExpenseStoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseStore update
   */
  export type ExpenseStoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseStore.
     */
    data: XOR<ExpenseStoreUpdateInput, ExpenseStoreUncheckedUpdateInput>
    /**
     * Choose, which ExpenseStore to update.
     */
    where: ExpenseStoreWhereUniqueInput
  }

  /**
   * ExpenseStore updateMany
   */
  export type ExpenseStoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseStores.
     */
    data: XOR<ExpenseStoreUpdateManyMutationInput, ExpenseStoreUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseStores to update
     */
    where?: ExpenseStoreWhereInput
    /**
     * Limit how many ExpenseStores to update.
     */
    limit?: number
  }

  /**
   * ExpenseStore updateManyAndReturn
   */
  export type ExpenseStoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseStores.
     */
    data: XOR<ExpenseStoreUpdateManyMutationInput, ExpenseStoreUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseStores to update
     */
    where?: ExpenseStoreWhereInput
    /**
     * Limit how many ExpenseStores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseStore upsert
   */
  export type ExpenseStoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseStore to update in case it exists.
     */
    where: ExpenseStoreWhereUniqueInput
    /**
     * In case the ExpenseStore found by the `where` argument doesn't exist, create a new ExpenseStore with this data.
     */
    create: XOR<ExpenseStoreCreateInput, ExpenseStoreUncheckedCreateInput>
    /**
     * In case the ExpenseStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseStoreUpdateInput, ExpenseStoreUncheckedUpdateInput>
  }

  /**
   * ExpenseStore delete
   */
  export type ExpenseStoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    /**
     * Filter which ExpenseStore to delete.
     */
    where: ExpenseStoreWhereUniqueInput
  }

  /**
   * ExpenseStore deleteMany
   */
  export type ExpenseStoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseStores to delete
     */
    where?: ExpenseStoreWhereInput
    /**
     * Limit how many ExpenseStores to delete.
     */
    limit?: number
  }

  /**
   * ExpenseStore.user
   */
  export type ExpenseStore$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ExpenseStore.receipts
   */
  export type ExpenseStore$receiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    where?: ExpenseReceiptWhereInput
    orderBy?: ExpenseReceiptOrderByWithRelationInput | ExpenseReceiptOrderByWithRelationInput[]
    cursor?: ExpenseReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseReceiptScalarFieldEnum | ExpenseReceiptScalarFieldEnum[]
  }

  /**
   * ExpenseStore without action
   */
  export type ExpenseStoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseReceipt
   */

  export type AggregateExpenseReceipt = {
    _count: ExpenseReceiptCountAggregateOutputType | null
    _avg: ExpenseReceiptAvgAggregateOutputType | null
    _sum: ExpenseReceiptSumAggregateOutputType | null
    _min: ExpenseReceiptMinAggregateOutputType | null
    _max: ExpenseReceiptMaxAggregateOutputType | null
  }

  export type ExpenseReceiptAvgAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
  }

  export type ExpenseReceiptSumAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
  }

  export type ExpenseReceiptMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    store_uuid: string | null
    expense_entry_uuid: string | null
    receipt_date: Date | null
    total_amount: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseReceiptMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    store_uuid: string | null
    expense_entry_uuid: string | null
    receipt_date: Date | null
    total_amount: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseReceiptCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    store_uuid: number
    expense_entry_uuid: number
    receipt_date: number
    total_amount: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExpenseReceiptAvgAggregateInputType = {
    id?: true
    total_amount?: true
  }

  export type ExpenseReceiptSumAggregateInputType = {
    id?: true
    total_amount?: true
  }

  export type ExpenseReceiptMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    store_uuid?: true
    expense_entry_uuid?: true
    receipt_date?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseReceiptMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    store_uuid?: true
    expense_entry_uuid?: true
    receipt_date?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseReceiptCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    store_uuid?: true
    expense_entry_uuid?: true
    receipt_date?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExpenseReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseReceipt to aggregate.
     */
    where?: ExpenseReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseReceipts to fetch.
     */
    orderBy?: ExpenseReceiptOrderByWithRelationInput | ExpenseReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseReceipts
    **/
    _count?: true | ExpenseReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseReceiptMaxAggregateInputType
  }

  export type GetExpenseReceiptAggregateType<T extends ExpenseReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseReceipt[P]>
      : GetScalarType<T[P], AggregateExpenseReceipt[P]>
  }




  export type ExpenseReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseReceiptWhereInput
    orderBy?: ExpenseReceiptOrderByWithAggregationInput | ExpenseReceiptOrderByWithAggregationInput[]
    by: ExpenseReceiptScalarFieldEnum[] | ExpenseReceiptScalarFieldEnum
    having?: ExpenseReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseReceiptCountAggregateInputType | true
    _avg?: ExpenseReceiptAvgAggregateInputType
    _sum?: ExpenseReceiptSumAggregateInputType
    _min?: ExpenseReceiptMinAggregateInputType
    _max?: ExpenseReceiptMaxAggregateInputType
  }

  export type ExpenseReceiptGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string
    store_uuid: string | null
    expense_entry_uuid: string
    receipt_date: Date
    total_amount: Decimal
    created_at: Date
    updated_at: Date
    _count: ExpenseReceiptCountAggregateOutputType | null
    _avg: ExpenseReceiptAvgAggregateOutputType | null
    _sum: ExpenseReceiptSumAggregateOutputType | null
    _min: ExpenseReceiptMinAggregateOutputType | null
    _max: ExpenseReceiptMaxAggregateOutputType | null
  }

  type GetExpenseReceiptGroupByPayload<T extends ExpenseReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    store_uuid?: boolean
    expense_entry_uuid?: boolean
    receipt_date?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | ExpenseReceipt$storeArgs<ExtArgs>
    expense_entry?: boolean | ExpenseEntryDefaultArgs<ExtArgs>
    items?: boolean | ExpenseReceipt$itemsArgs<ExtArgs>
    _count?: boolean | ExpenseReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseReceipt"]>

  export type ExpenseReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    store_uuid?: boolean
    expense_entry_uuid?: boolean
    receipt_date?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | ExpenseReceipt$storeArgs<ExtArgs>
    expense_entry?: boolean | ExpenseEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseReceipt"]>

  export type ExpenseReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    store_uuid?: boolean
    expense_entry_uuid?: boolean
    receipt_date?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | ExpenseReceipt$storeArgs<ExtArgs>
    expense_entry?: boolean | ExpenseEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseReceipt"]>

  export type ExpenseReceiptSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    store_uuid?: boolean
    expense_entry_uuid?: boolean
    receipt_date?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExpenseReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "store_uuid" | "expense_entry_uuid" | "receipt_date" | "total_amount" | "created_at" | "updated_at", ExtArgs["result"]["expenseReceipt"]>
  export type ExpenseReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | ExpenseReceipt$storeArgs<ExtArgs>
    expense_entry?: boolean | ExpenseEntryDefaultArgs<ExtArgs>
    items?: boolean | ExpenseReceipt$itemsArgs<ExtArgs>
    _count?: boolean | ExpenseReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | ExpenseReceipt$storeArgs<ExtArgs>
    expense_entry?: boolean | ExpenseEntryDefaultArgs<ExtArgs>
  }
  export type ExpenseReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | ExpenseReceipt$storeArgs<ExtArgs>
    expense_entry?: boolean | ExpenseEntryDefaultArgs<ExtArgs>
  }

  export type $ExpenseReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseReceipt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      store: Prisma.$ExpenseStorePayload<ExtArgs> | null
      expense_entry: Prisma.$ExpenseEntryPayload<ExtArgs>
      items: Prisma.$ExpenseReceiptItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string
      store_uuid: string | null
      expense_entry_uuid: string
      receipt_date: Date
      total_amount: Prisma.Decimal
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["expenseReceipt"]>
    composites: {}
  }

  type ExpenseReceiptGetPayload<S extends boolean | null | undefined | ExpenseReceiptDefaultArgs> = $Result.GetResult<Prisma.$ExpenseReceiptPayload, S>

  type ExpenseReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseReceiptCountAggregateInputType | true
    }

  export interface ExpenseReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseReceipt'], meta: { name: 'ExpenseReceipt' } }
    /**
     * Find zero or one ExpenseReceipt that matches the filter.
     * @param {ExpenseReceiptFindUniqueArgs} args - Arguments to find a ExpenseReceipt
     * @example
     * // Get one ExpenseReceipt
     * const expenseReceipt = await prisma.expenseReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseReceiptFindUniqueArgs>(args: SelectSubset<T, ExpenseReceiptFindUniqueArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseReceipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseReceiptFindUniqueOrThrowArgs} args - Arguments to find a ExpenseReceipt
     * @example
     * // Get one ExpenseReceipt
     * const expenseReceipt = await prisma.expenseReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptFindFirstArgs} args - Arguments to find a ExpenseReceipt
     * @example
     * // Get one ExpenseReceipt
     * const expenseReceipt = await prisma.expenseReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseReceiptFindFirstArgs>(args?: SelectSubset<T, ExpenseReceiptFindFirstArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptFindFirstOrThrowArgs} args - Arguments to find a ExpenseReceipt
     * @example
     * // Get one ExpenseReceipt
     * const expenseReceipt = await prisma.expenseReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseReceipts
     * const expenseReceipts = await prisma.expenseReceipt.findMany()
     * 
     * // Get first 10 ExpenseReceipts
     * const expenseReceipts = await prisma.expenseReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseReceiptWithIdOnly = await prisma.expenseReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseReceiptFindManyArgs>(args?: SelectSubset<T, ExpenseReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseReceipt.
     * @param {ExpenseReceiptCreateArgs} args - Arguments to create a ExpenseReceipt.
     * @example
     * // Create one ExpenseReceipt
     * const ExpenseReceipt = await prisma.expenseReceipt.create({
     *   data: {
     *     // ... data to create a ExpenseReceipt
     *   }
     * })
     * 
     */
    create<T extends ExpenseReceiptCreateArgs>(args: SelectSubset<T, ExpenseReceiptCreateArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseReceipts.
     * @param {ExpenseReceiptCreateManyArgs} args - Arguments to create many ExpenseReceipts.
     * @example
     * // Create many ExpenseReceipts
     * const expenseReceipt = await prisma.expenseReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseReceiptCreateManyArgs>(args?: SelectSubset<T, ExpenseReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseReceipts and returns the data saved in the database.
     * @param {ExpenseReceiptCreateManyAndReturnArgs} args - Arguments to create many ExpenseReceipts.
     * @example
     * // Create many ExpenseReceipts
     * const expenseReceipt = await prisma.expenseReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseReceipts and only return the `id`
     * const expenseReceiptWithIdOnly = await prisma.expenseReceipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseReceipt.
     * @param {ExpenseReceiptDeleteArgs} args - Arguments to delete one ExpenseReceipt.
     * @example
     * // Delete one ExpenseReceipt
     * const ExpenseReceipt = await prisma.expenseReceipt.delete({
     *   where: {
     *     // ... filter to delete one ExpenseReceipt
     *   }
     * })
     * 
     */
    delete<T extends ExpenseReceiptDeleteArgs>(args: SelectSubset<T, ExpenseReceiptDeleteArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseReceipt.
     * @param {ExpenseReceiptUpdateArgs} args - Arguments to update one ExpenseReceipt.
     * @example
     * // Update one ExpenseReceipt
     * const expenseReceipt = await prisma.expenseReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseReceiptUpdateArgs>(args: SelectSubset<T, ExpenseReceiptUpdateArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseReceipts.
     * @param {ExpenseReceiptDeleteManyArgs} args - Arguments to filter ExpenseReceipts to delete.
     * @example
     * // Delete a few ExpenseReceipts
     * const { count } = await prisma.expenseReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseReceiptDeleteManyArgs>(args?: SelectSubset<T, ExpenseReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseReceipts
     * const expenseReceipt = await prisma.expenseReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseReceiptUpdateManyArgs>(args: SelectSubset<T, ExpenseReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseReceipts and returns the data updated in the database.
     * @param {ExpenseReceiptUpdateManyAndReturnArgs} args - Arguments to update many ExpenseReceipts.
     * @example
     * // Update many ExpenseReceipts
     * const expenseReceipt = await prisma.expenseReceipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseReceipts and only return the `id`
     * const expenseReceiptWithIdOnly = await prisma.expenseReceipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseReceipt.
     * @param {ExpenseReceiptUpsertArgs} args - Arguments to update or create a ExpenseReceipt.
     * @example
     * // Update or create a ExpenseReceipt
     * const expenseReceipt = await prisma.expenseReceipt.upsert({
     *   create: {
     *     // ... data to create a ExpenseReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseReceipt we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseReceiptUpsertArgs>(args: SelectSubset<T, ExpenseReceiptUpsertArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptCountArgs} args - Arguments to filter ExpenseReceipts to count.
     * @example
     * // Count the number of ExpenseReceipts
     * const count = await prisma.expenseReceipt.count({
     *   where: {
     *     // ... the filter for the ExpenseReceipts we want to count
     *   }
     * })
    **/
    count<T extends ExpenseReceiptCountArgs>(
      args?: Subset<T, ExpenseReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseReceiptAggregateArgs>(args: Subset<T, ExpenseReceiptAggregateArgs>): Prisma.PrismaPromise<GetExpenseReceiptAggregateType<T>>

    /**
     * Group by ExpenseReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseReceipt model
   */
  readonly fields: ExpenseReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends ExpenseReceipt$storeArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseReceipt$storeArgs<ExtArgs>>): Prisma__ExpenseStoreClient<$Result.GetResult<Prisma.$ExpenseStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    expense_entry<T extends ExpenseEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseEntryDefaultArgs<ExtArgs>>): Prisma__ExpenseEntryClient<$Result.GetResult<Prisma.$ExpenseEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends ExpenseReceipt$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseReceipt$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseReceipt model
   */
  interface ExpenseReceiptFieldRefs {
    readonly id: FieldRef<"ExpenseReceipt", 'Int'>
    readonly uuid: FieldRef<"ExpenseReceipt", 'String'>
    readonly user_uuid: FieldRef<"ExpenseReceipt", 'String'>
    readonly store_uuid: FieldRef<"ExpenseReceipt", 'String'>
    readonly expense_entry_uuid: FieldRef<"ExpenseReceipt", 'String'>
    readonly receipt_date: FieldRef<"ExpenseReceipt", 'DateTime'>
    readonly total_amount: FieldRef<"ExpenseReceipt", 'Decimal'>
    readonly created_at: FieldRef<"ExpenseReceipt", 'DateTime'>
    readonly updated_at: FieldRef<"ExpenseReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseReceipt findUnique
   */
  export type ExpenseReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceipt to fetch.
     */
    where: ExpenseReceiptWhereUniqueInput
  }

  /**
   * ExpenseReceipt findUniqueOrThrow
   */
  export type ExpenseReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceipt to fetch.
     */
    where: ExpenseReceiptWhereUniqueInput
  }

  /**
   * ExpenseReceipt findFirst
   */
  export type ExpenseReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceipt to fetch.
     */
    where?: ExpenseReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseReceipts to fetch.
     */
    orderBy?: ExpenseReceiptOrderByWithRelationInput | ExpenseReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseReceipts.
     */
    cursor?: ExpenseReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseReceipts.
     */
    distinct?: ExpenseReceiptScalarFieldEnum | ExpenseReceiptScalarFieldEnum[]
  }

  /**
   * ExpenseReceipt findFirstOrThrow
   */
  export type ExpenseReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceipt to fetch.
     */
    where?: ExpenseReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseReceipts to fetch.
     */
    orderBy?: ExpenseReceiptOrderByWithRelationInput | ExpenseReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseReceipts.
     */
    cursor?: ExpenseReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseReceipts.
     */
    distinct?: ExpenseReceiptScalarFieldEnum | ExpenseReceiptScalarFieldEnum[]
  }

  /**
   * ExpenseReceipt findMany
   */
  export type ExpenseReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceipts to fetch.
     */
    where?: ExpenseReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseReceipts to fetch.
     */
    orderBy?: ExpenseReceiptOrderByWithRelationInput | ExpenseReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseReceipts.
     */
    cursor?: ExpenseReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseReceipts.
     */
    skip?: number
    distinct?: ExpenseReceiptScalarFieldEnum | ExpenseReceiptScalarFieldEnum[]
  }

  /**
   * ExpenseReceipt create
   */
  export type ExpenseReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseReceipt.
     */
    data: XOR<ExpenseReceiptCreateInput, ExpenseReceiptUncheckedCreateInput>
  }

  /**
   * ExpenseReceipt createMany
   */
  export type ExpenseReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseReceipts.
     */
    data: ExpenseReceiptCreateManyInput | ExpenseReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseReceipt createManyAndReturn
   */
  export type ExpenseReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseReceipts.
     */
    data: ExpenseReceiptCreateManyInput | ExpenseReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseReceipt update
   */
  export type ExpenseReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseReceipt.
     */
    data: XOR<ExpenseReceiptUpdateInput, ExpenseReceiptUncheckedUpdateInput>
    /**
     * Choose, which ExpenseReceipt to update.
     */
    where: ExpenseReceiptWhereUniqueInput
  }

  /**
   * ExpenseReceipt updateMany
   */
  export type ExpenseReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseReceipts.
     */
    data: XOR<ExpenseReceiptUpdateManyMutationInput, ExpenseReceiptUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseReceipts to update
     */
    where?: ExpenseReceiptWhereInput
    /**
     * Limit how many ExpenseReceipts to update.
     */
    limit?: number
  }

  /**
   * ExpenseReceipt updateManyAndReturn
   */
  export type ExpenseReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseReceipts.
     */
    data: XOR<ExpenseReceiptUpdateManyMutationInput, ExpenseReceiptUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseReceipts to update
     */
    where?: ExpenseReceiptWhereInput
    /**
     * Limit how many ExpenseReceipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseReceipt upsert
   */
  export type ExpenseReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseReceipt to update in case it exists.
     */
    where: ExpenseReceiptWhereUniqueInput
    /**
     * In case the ExpenseReceipt found by the `where` argument doesn't exist, create a new ExpenseReceipt with this data.
     */
    create: XOR<ExpenseReceiptCreateInput, ExpenseReceiptUncheckedCreateInput>
    /**
     * In case the ExpenseReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseReceiptUpdateInput, ExpenseReceiptUncheckedUpdateInput>
  }

  /**
   * ExpenseReceipt delete
   */
  export type ExpenseReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
    /**
     * Filter which ExpenseReceipt to delete.
     */
    where: ExpenseReceiptWhereUniqueInput
  }

  /**
   * ExpenseReceipt deleteMany
   */
  export type ExpenseReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseReceipts to delete
     */
    where?: ExpenseReceiptWhereInput
    /**
     * Limit how many ExpenseReceipts to delete.
     */
    limit?: number
  }

  /**
   * ExpenseReceipt.store
   */
  export type ExpenseReceipt$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseStore
     */
    select?: ExpenseStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseStore
     */
    omit?: ExpenseStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseStoreInclude<ExtArgs> | null
    where?: ExpenseStoreWhereInput
  }

  /**
   * ExpenseReceipt.items
   */
  export type ExpenseReceipt$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    where?: ExpenseReceiptItemWhereInput
    orderBy?: ExpenseReceiptItemOrderByWithRelationInput | ExpenseReceiptItemOrderByWithRelationInput[]
    cursor?: ExpenseReceiptItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseReceiptItemScalarFieldEnum | ExpenseReceiptItemScalarFieldEnum[]
  }

  /**
   * ExpenseReceipt without action
   */
  export type ExpenseReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceipt
     */
    select?: ExpenseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceipt
     */
    omit?: ExpenseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseProduct
   */

  export type AggregateExpenseProduct = {
    _count: ExpenseProductCountAggregateOutputType | null
    _avg: ExpenseProductAvgAggregateOutputType | null
    _sum: ExpenseProductSumAggregateOutputType | null
    _min: ExpenseProductMinAggregateOutputType | null
    _max: ExpenseProductMaxAggregateOutputType | null
  }

  export type ExpenseProductAvgAggregateOutputType = {
    id: number | null
    size: Decimal | null
  }

  export type ExpenseProductSumAggregateOutputType = {
    id: number | null
    size: Decimal | null
  }

  export type ExpenseProductMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    brand: string | null
    unit: string | null
    size: Decimal | null
    category_uuid: string | null
    subcategory_uuid: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseProductMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    brand: string | null
    unit: string | null
    size: Decimal | null
    category_uuid: string | null
    subcategory_uuid: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseProductCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    name: number
    brand: number
    unit: number
    size: number
    category_uuid: number
    subcategory_uuid: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExpenseProductAvgAggregateInputType = {
    id?: true
    size?: true
  }

  export type ExpenseProductSumAggregateInputType = {
    id?: true
    size?: true
  }

  export type ExpenseProductMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    brand?: true
    unit?: true
    size?: true
    category_uuid?: true
    subcategory_uuid?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseProductMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    brand?: true
    unit?: true
    size?: true
    category_uuid?: true
    subcategory_uuid?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseProductCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    brand?: true
    unit?: true
    size?: true
    category_uuid?: true
    subcategory_uuid?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExpenseProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseProduct to aggregate.
     */
    where?: ExpenseProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseProducts to fetch.
     */
    orderBy?: ExpenseProductOrderByWithRelationInput | ExpenseProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseProducts
    **/
    _count?: true | ExpenseProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseProductMaxAggregateInputType
  }

  export type GetExpenseProductAggregateType<T extends ExpenseProductAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseProduct[P]>
      : GetScalarType<T[P], AggregateExpenseProduct[P]>
  }




  export type ExpenseProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseProductWhereInput
    orderBy?: ExpenseProductOrderByWithAggregationInput | ExpenseProductOrderByWithAggregationInput[]
    by: ExpenseProductScalarFieldEnum[] | ExpenseProductScalarFieldEnum
    having?: ExpenseProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseProductCountAggregateInputType | true
    _avg?: ExpenseProductAvgAggregateInputType
    _sum?: ExpenseProductSumAggregateInputType
    _min?: ExpenseProductMinAggregateInputType
    _max?: ExpenseProductMaxAggregateInputType
  }

  export type ExpenseProductGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string | null
    name: string
    brand: string | null
    unit: string | null
    size: Decimal | null
    category_uuid: string | null
    subcategory_uuid: string | null
    created_at: Date
    updated_at: Date
    _count: ExpenseProductCountAggregateOutputType | null
    _avg: ExpenseProductAvgAggregateOutputType | null
    _sum: ExpenseProductSumAggregateOutputType | null
    _min: ExpenseProductMinAggregateOutputType | null
    _max: ExpenseProductMaxAggregateOutputType | null
  }

  type GetExpenseProductGroupByPayload<T extends ExpenseProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseProductGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseProductGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    brand?: boolean
    unit?: boolean
    size?: boolean
    category_uuid?: boolean
    subcategory_uuid?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseProduct$userArgs<ExtArgs>
    category?: boolean | ExpenseProduct$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseProduct$subcategoryArgs<ExtArgs>
    receipt_items?: boolean | ExpenseProduct$receipt_itemsArgs<ExtArgs>
    _count?: boolean | ExpenseProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseProduct"]>

  export type ExpenseProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    brand?: boolean
    unit?: boolean
    size?: boolean
    category_uuid?: boolean
    subcategory_uuid?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseProduct$userArgs<ExtArgs>
    category?: boolean | ExpenseProduct$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseProduct$subcategoryArgs<ExtArgs>
  }, ExtArgs["result"]["expenseProduct"]>

  export type ExpenseProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    brand?: boolean
    unit?: boolean
    size?: boolean
    category_uuid?: boolean
    subcategory_uuid?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | ExpenseProduct$userArgs<ExtArgs>
    category?: boolean | ExpenseProduct$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseProduct$subcategoryArgs<ExtArgs>
  }, ExtArgs["result"]["expenseProduct"]>

  export type ExpenseProductSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    brand?: boolean
    unit?: boolean
    size?: boolean
    category_uuid?: boolean
    subcategory_uuid?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExpenseProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "name" | "brand" | "unit" | "size" | "category_uuid" | "subcategory_uuid" | "created_at" | "updated_at", ExtArgs["result"]["expenseProduct"]>
  export type ExpenseProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseProduct$userArgs<ExtArgs>
    category?: boolean | ExpenseProduct$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseProduct$subcategoryArgs<ExtArgs>
    receipt_items?: boolean | ExpenseProduct$receipt_itemsArgs<ExtArgs>
    _count?: boolean | ExpenseProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseProduct$userArgs<ExtArgs>
    category?: boolean | ExpenseProduct$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseProduct$subcategoryArgs<ExtArgs>
  }
  export type ExpenseProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ExpenseProduct$userArgs<ExtArgs>
    category?: boolean | ExpenseProduct$categoryArgs<ExtArgs>
    subcategory?: boolean | ExpenseProduct$subcategoryArgs<ExtArgs>
  }

  export type $ExpenseProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseProduct"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      category: Prisma.$ExpenseCategoryPayload<ExtArgs> | null
      subcategory: Prisma.$ExpenseSubcategoryPayload<ExtArgs> | null
      receipt_items: Prisma.$ExpenseReceiptItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string | null
      name: string
      brand: string | null
      unit: string | null
      size: Prisma.Decimal | null
      category_uuid: string | null
      subcategory_uuid: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["expenseProduct"]>
    composites: {}
  }

  type ExpenseProductGetPayload<S extends boolean | null | undefined | ExpenseProductDefaultArgs> = $Result.GetResult<Prisma.$ExpenseProductPayload, S>

  type ExpenseProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseProductCountAggregateInputType | true
    }

  export interface ExpenseProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseProduct'], meta: { name: 'ExpenseProduct' } }
    /**
     * Find zero or one ExpenseProduct that matches the filter.
     * @param {ExpenseProductFindUniqueArgs} args - Arguments to find a ExpenseProduct
     * @example
     * // Get one ExpenseProduct
     * const expenseProduct = await prisma.expenseProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseProductFindUniqueArgs>(args: SelectSubset<T, ExpenseProductFindUniqueArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseProductFindUniqueOrThrowArgs} args - Arguments to find a ExpenseProduct
     * @example
     * // Get one ExpenseProduct
     * const expenseProduct = await prisma.expenseProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseProductFindFirstArgs} args - Arguments to find a ExpenseProduct
     * @example
     * // Get one ExpenseProduct
     * const expenseProduct = await prisma.expenseProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseProductFindFirstArgs>(args?: SelectSubset<T, ExpenseProductFindFirstArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseProductFindFirstOrThrowArgs} args - Arguments to find a ExpenseProduct
     * @example
     * // Get one ExpenseProduct
     * const expenseProduct = await prisma.expenseProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseProducts
     * const expenseProducts = await prisma.expenseProduct.findMany()
     * 
     * // Get first 10 ExpenseProducts
     * const expenseProducts = await prisma.expenseProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseProductWithIdOnly = await prisma.expenseProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseProductFindManyArgs>(args?: SelectSubset<T, ExpenseProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseProduct.
     * @param {ExpenseProductCreateArgs} args - Arguments to create a ExpenseProduct.
     * @example
     * // Create one ExpenseProduct
     * const ExpenseProduct = await prisma.expenseProduct.create({
     *   data: {
     *     // ... data to create a ExpenseProduct
     *   }
     * })
     * 
     */
    create<T extends ExpenseProductCreateArgs>(args: SelectSubset<T, ExpenseProductCreateArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseProducts.
     * @param {ExpenseProductCreateManyArgs} args - Arguments to create many ExpenseProducts.
     * @example
     * // Create many ExpenseProducts
     * const expenseProduct = await prisma.expenseProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseProductCreateManyArgs>(args?: SelectSubset<T, ExpenseProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseProducts and returns the data saved in the database.
     * @param {ExpenseProductCreateManyAndReturnArgs} args - Arguments to create many ExpenseProducts.
     * @example
     * // Create many ExpenseProducts
     * const expenseProduct = await prisma.expenseProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseProducts and only return the `id`
     * const expenseProductWithIdOnly = await prisma.expenseProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseProduct.
     * @param {ExpenseProductDeleteArgs} args - Arguments to delete one ExpenseProduct.
     * @example
     * // Delete one ExpenseProduct
     * const ExpenseProduct = await prisma.expenseProduct.delete({
     *   where: {
     *     // ... filter to delete one ExpenseProduct
     *   }
     * })
     * 
     */
    delete<T extends ExpenseProductDeleteArgs>(args: SelectSubset<T, ExpenseProductDeleteArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseProduct.
     * @param {ExpenseProductUpdateArgs} args - Arguments to update one ExpenseProduct.
     * @example
     * // Update one ExpenseProduct
     * const expenseProduct = await prisma.expenseProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseProductUpdateArgs>(args: SelectSubset<T, ExpenseProductUpdateArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseProducts.
     * @param {ExpenseProductDeleteManyArgs} args - Arguments to filter ExpenseProducts to delete.
     * @example
     * // Delete a few ExpenseProducts
     * const { count } = await prisma.expenseProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseProductDeleteManyArgs>(args?: SelectSubset<T, ExpenseProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseProducts
     * const expenseProduct = await prisma.expenseProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseProductUpdateManyArgs>(args: SelectSubset<T, ExpenseProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseProducts and returns the data updated in the database.
     * @param {ExpenseProductUpdateManyAndReturnArgs} args - Arguments to update many ExpenseProducts.
     * @example
     * // Update many ExpenseProducts
     * const expenseProduct = await prisma.expenseProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseProducts and only return the `id`
     * const expenseProductWithIdOnly = await prisma.expenseProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseProduct.
     * @param {ExpenseProductUpsertArgs} args - Arguments to update or create a ExpenseProduct.
     * @example
     * // Update or create a ExpenseProduct
     * const expenseProduct = await prisma.expenseProduct.upsert({
     *   create: {
     *     // ... data to create a ExpenseProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseProduct we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseProductUpsertArgs>(args: SelectSubset<T, ExpenseProductUpsertArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseProductCountArgs} args - Arguments to filter ExpenseProducts to count.
     * @example
     * // Count the number of ExpenseProducts
     * const count = await prisma.expenseProduct.count({
     *   where: {
     *     // ... the filter for the ExpenseProducts we want to count
     *   }
     * })
    **/
    count<T extends ExpenseProductCountArgs>(
      args?: Subset<T, ExpenseProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseProductAggregateArgs>(args: Subset<T, ExpenseProductAggregateArgs>): Prisma.PrismaPromise<GetExpenseProductAggregateType<T>>

    /**
     * Group by ExpenseProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseProductGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseProduct model
   */
  readonly fields: ExpenseProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ExpenseProduct$userArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseProduct$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends ExpenseProduct$categoryArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseProduct$categoryArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends ExpenseProduct$subcategoryArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseProduct$subcategoryArgs<ExtArgs>>): Prisma__ExpenseSubcategoryClient<$Result.GetResult<Prisma.$ExpenseSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    receipt_items<T extends ExpenseProduct$receipt_itemsArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseProduct$receipt_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseProduct model
   */
  interface ExpenseProductFieldRefs {
    readonly id: FieldRef<"ExpenseProduct", 'Int'>
    readonly uuid: FieldRef<"ExpenseProduct", 'String'>
    readonly user_uuid: FieldRef<"ExpenseProduct", 'String'>
    readonly name: FieldRef<"ExpenseProduct", 'String'>
    readonly brand: FieldRef<"ExpenseProduct", 'String'>
    readonly unit: FieldRef<"ExpenseProduct", 'String'>
    readonly size: FieldRef<"ExpenseProduct", 'Decimal'>
    readonly category_uuid: FieldRef<"ExpenseProduct", 'String'>
    readonly subcategory_uuid: FieldRef<"ExpenseProduct", 'String'>
    readonly created_at: FieldRef<"ExpenseProduct", 'DateTime'>
    readonly updated_at: FieldRef<"ExpenseProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseProduct findUnique
   */
  export type ExpenseProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseProduct to fetch.
     */
    where: ExpenseProductWhereUniqueInput
  }

  /**
   * ExpenseProduct findUniqueOrThrow
   */
  export type ExpenseProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseProduct to fetch.
     */
    where: ExpenseProductWhereUniqueInput
  }

  /**
   * ExpenseProduct findFirst
   */
  export type ExpenseProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseProduct to fetch.
     */
    where?: ExpenseProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseProducts to fetch.
     */
    orderBy?: ExpenseProductOrderByWithRelationInput | ExpenseProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseProducts.
     */
    cursor?: ExpenseProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseProducts.
     */
    distinct?: ExpenseProductScalarFieldEnum | ExpenseProductScalarFieldEnum[]
  }

  /**
   * ExpenseProduct findFirstOrThrow
   */
  export type ExpenseProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseProduct to fetch.
     */
    where?: ExpenseProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseProducts to fetch.
     */
    orderBy?: ExpenseProductOrderByWithRelationInput | ExpenseProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseProducts.
     */
    cursor?: ExpenseProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseProducts.
     */
    distinct?: ExpenseProductScalarFieldEnum | ExpenseProductScalarFieldEnum[]
  }

  /**
   * ExpenseProduct findMany
   */
  export type ExpenseProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseProducts to fetch.
     */
    where?: ExpenseProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseProducts to fetch.
     */
    orderBy?: ExpenseProductOrderByWithRelationInput | ExpenseProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseProducts.
     */
    cursor?: ExpenseProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseProducts.
     */
    skip?: number
    distinct?: ExpenseProductScalarFieldEnum | ExpenseProductScalarFieldEnum[]
  }

  /**
   * ExpenseProduct create
   */
  export type ExpenseProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseProduct.
     */
    data: XOR<ExpenseProductCreateInput, ExpenseProductUncheckedCreateInput>
  }

  /**
   * ExpenseProduct createMany
   */
  export type ExpenseProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseProducts.
     */
    data: ExpenseProductCreateManyInput | ExpenseProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseProduct createManyAndReturn
   */
  export type ExpenseProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseProducts.
     */
    data: ExpenseProductCreateManyInput | ExpenseProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseProduct update
   */
  export type ExpenseProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseProduct.
     */
    data: XOR<ExpenseProductUpdateInput, ExpenseProductUncheckedUpdateInput>
    /**
     * Choose, which ExpenseProduct to update.
     */
    where: ExpenseProductWhereUniqueInput
  }

  /**
   * ExpenseProduct updateMany
   */
  export type ExpenseProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseProducts.
     */
    data: XOR<ExpenseProductUpdateManyMutationInput, ExpenseProductUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseProducts to update
     */
    where?: ExpenseProductWhereInput
    /**
     * Limit how many ExpenseProducts to update.
     */
    limit?: number
  }

  /**
   * ExpenseProduct updateManyAndReturn
   */
  export type ExpenseProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseProducts.
     */
    data: XOR<ExpenseProductUpdateManyMutationInput, ExpenseProductUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseProducts to update
     */
    where?: ExpenseProductWhereInput
    /**
     * Limit how many ExpenseProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseProduct upsert
   */
  export type ExpenseProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseProduct to update in case it exists.
     */
    where: ExpenseProductWhereUniqueInput
    /**
     * In case the ExpenseProduct found by the `where` argument doesn't exist, create a new ExpenseProduct with this data.
     */
    create: XOR<ExpenseProductCreateInput, ExpenseProductUncheckedCreateInput>
    /**
     * In case the ExpenseProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseProductUpdateInput, ExpenseProductUncheckedUpdateInput>
  }

  /**
   * ExpenseProduct delete
   */
  export type ExpenseProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    /**
     * Filter which ExpenseProduct to delete.
     */
    where: ExpenseProductWhereUniqueInput
  }

  /**
   * ExpenseProduct deleteMany
   */
  export type ExpenseProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseProducts to delete
     */
    where?: ExpenseProductWhereInput
    /**
     * Limit how many ExpenseProducts to delete.
     */
    limit?: number
  }

  /**
   * ExpenseProduct.user
   */
  export type ExpenseProduct$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ExpenseProduct.category
   */
  export type ExpenseProduct$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
  }

  /**
   * ExpenseProduct.subcategory
   */
  export type ExpenseProduct$subcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSubcategory
     */
    select?: ExpenseSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseSubcategory
     */
    omit?: ExpenseSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSubcategoryInclude<ExtArgs> | null
    where?: ExpenseSubcategoryWhereInput
  }

  /**
   * ExpenseProduct.receipt_items
   */
  export type ExpenseProduct$receipt_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    where?: ExpenseReceiptItemWhereInput
    orderBy?: ExpenseReceiptItemOrderByWithRelationInput | ExpenseReceiptItemOrderByWithRelationInput[]
    cursor?: ExpenseReceiptItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseReceiptItemScalarFieldEnum | ExpenseReceiptItemScalarFieldEnum[]
  }

  /**
   * ExpenseProduct without action
   */
  export type ExpenseProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseReceiptItem
   */

  export type AggregateExpenseReceiptItem = {
    _count: ExpenseReceiptItemCountAggregateOutputType | null
    _avg: ExpenseReceiptItemAvgAggregateOutputType | null
    _sum: ExpenseReceiptItemSumAggregateOutputType | null
    _min: ExpenseReceiptItemMinAggregateOutputType | null
    _max: ExpenseReceiptItemMaxAggregateOutputType | null
  }

  export type ExpenseReceiptItemAvgAggregateOutputType = {
    id: number | null
    quantity: Decimal | null
    unit_price: Decimal | null
    total_price: Decimal | null
  }

  export type ExpenseReceiptItemSumAggregateOutputType = {
    id: number | null
    quantity: Decimal | null
    unit_price: Decimal | null
    total_price: Decimal | null
  }

  export type ExpenseReceiptItemMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    receipt_uuid: string | null
    product_uuid: string | null
    quantity: Decimal | null
    unit_price: Decimal | null
    total_price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseReceiptItemMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    receipt_uuid: string | null
    product_uuid: string | null
    quantity: Decimal | null
    unit_price: Decimal | null
    total_price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExpenseReceiptItemCountAggregateOutputType = {
    id: number
    uuid: number
    receipt_uuid: number
    product_uuid: number
    quantity: number
    unit_price: number
    total_price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExpenseReceiptItemAvgAggregateInputType = {
    id?: true
    quantity?: true
    unit_price?: true
    total_price?: true
  }

  export type ExpenseReceiptItemSumAggregateInputType = {
    id?: true
    quantity?: true
    unit_price?: true
    total_price?: true
  }

  export type ExpenseReceiptItemMinAggregateInputType = {
    id?: true
    uuid?: true
    receipt_uuid?: true
    product_uuid?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseReceiptItemMaxAggregateInputType = {
    id?: true
    uuid?: true
    receipt_uuid?: true
    product_uuid?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    created_at?: true
    updated_at?: true
  }

  export type ExpenseReceiptItemCountAggregateInputType = {
    id?: true
    uuid?: true
    receipt_uuid?: true
    product_uuid?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExpenseReceiptItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseReceiptItem to aggregate.
     */
    where?: ExpenseReceiptItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseReceiptItems to fetch.
     */
    orderBy?: ExpenseReceiptItemOrderByWithRelationInput | ExpenseReceiptItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseReceiptItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseReceiptItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseReceiptItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseReceiptItems
    **/
    _count?: true | ExpenseReceiptItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseReceiptItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseReceiptItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseReceiptItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseReceiptItemMaxAggregateInputType
  }

  export type GetExpenseReceiptItemAggregateType<T extends ExpenseReceiptItemAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseReceiptItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseReceiptItem[P]>
      : GetScalarType<T[P], AggregateExpenseReceiptItem[P]>
  }




  export type ExpenseReceiptItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseReceiptItemWhereInput
    orderBy?: ExpenseReceiptItemOrderByWithAggregationInput | ExpenseReceiptItemOrderByWithAggregationInput[]
    by: ExpenseReceiptItemScalarFieldEnum[] | ExpenseReceiptItemScalarFieldEnum
    having?: ExpenseReceiptItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseReceiptItemCountAggregateInputType | true
    _avg?: ExpenseReceiptItemAvgAggregateInputType
    _sum?: ExpenseReceiptItemSumAggregateInputType
    _min?: ExpenseReceiptItemMinAggregateInputType
    _max?: ExpenseReceiptItemMaxAggregateInputType
  }

  export type ExpenseReceiptItemGroupByOutputType = {
    id: number
    uuid: string
    receipt_uuid: string
    product_uuid: string | null
    quantity: Decimal
    unit_price: Decimal
    total_price: Decimal
    created_at: Date
    updated_at: Date
    _count: ExpenseReceiptItemCountAggregateOutputType | null
    _avg: ExpenseReceiptItemAvgAggregateOutputType | null
    _sum: ExpenseReceiptItemSumAggregateOutputType | null
    _min: ExpenseReceiptItemMinAggregateOutputType | null
    _max: ExpenseReceiptItemMaxAggregateOutputType | null
  }

  type GetExpenseReceiptItemGroupByPayload<T extends ExpenseReceiptItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseReceiptItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseReceiptItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseReceiptItemGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseReceiptItemGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseReceiptItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    receipt_uuid?: boolean
    product_uuid?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    created_at?: boolean
    updated_at?: boolean
    receipt?: boolean | ExpenseReceiptDefaultArgs<ExtArgs>
    product?: boolean | ExpenseReceiptItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["expenseReceiptItem"]>

  export type ExpenseReceiptItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    receipt_uuid?: boolean
    product_uuid?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    created_at?: boolean
    updated_at?: boolean
    receipt?: boolean | ExpenseReceiptDefaultArgs<ExtArgs>
    product?: boolean | ExpenseReceiptItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["expenseReceiptItem"]>

  export type ExpenseReceiptItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    receipt_uuid?: boolean
    product_uuid?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    created_at?: boolean
    updated_at?: boolean
    receipt?: boolean | ExpenseReceiptDefaultArgs<ExtArgs>
    product?: boolean | ExpenseReceiptItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["expenseReceiptItem"]>

  export type ExpenseReceiptItemSelectScalar = {
    id?: boolean
    uuid?: boolean
    receipt_uuid?: boolean
    product_uuid?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExpenseReceiptItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "receipt_uuid" | "product_uuid" | "quantity" | "unit_price" | "total_price" | "created_at" | "updated_at", ExtArgs["result"]["expenseReceiptItem"]>
  export type ExpenseReceiptItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | ExpenseReceiptDefaultArgs<ExtArgs>
    product?: boolean | ExpenseReceiptItem$productArgs<ExtArgs>
  }
  export type ExpenseReceiptItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | ExpenseReceiptDefaultArgs<ExtArgs>
    product?: boolean | ExpenseReceiptItem$productArgs<ExtArgs>
  }
  export type ExpenseReceiptItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | ExpenseReceiptDefaultArgs<ExtArgs>
    product?: boolean | ExpenseReceiptItem$productArgs<ExtArgs>
  }

  export type $ExpenseReceiptItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseReceiptItem"
    objects: {
      receipt: Prisma.$ExpenseReceiptPayload<ExtArgs>
      product: Prisma.$ExpenseProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      receipt_uuid: string
      product_uuid: string | null
      quantity: Prisma.Decimal
      unit_price: Prisma.Decimal
      total_price: Prisma.Decimal
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["expenseReceiptItem"]>
    composites: {}
  }

  type ExpenseReceiptItemGetPayload<S extends boolean | null | undefined | ExpenseReceiptItemDefaultArgs> = $Result.GetResult<Prisma.$ExpenseReceiptItemPayload, S>

  type ExpenseReceiptItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseReceiptItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseReceiptItemCountAggregateInputType | true
    }

  export interface ExpenseReceiptItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseReceiptItem'], meta: { name: 'ExpenseReceiptItem' } }
    /**
     * Find zero or one ExpenseReceiptItem that matches the filter.
     * @param {ExpenseReceiptItemFindUniqueArgs} args - Arguments to find a ExpenseReceiptItem
     * @example
     * // Get one ExpenseReceiptItem
     * const expenseReceiptItem = await prisma.expenseReceiptItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseReceiptItemFindUniqueArgs>(args: SelectSubset<T, ExpenseReceiptItemFindUniqueArgs<ExtArgs>>): Prisma__ExpenseReceiptItemClient<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseReceiptItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseReceiptItemFindUniqueOrThrowArgs} args - Arguments to find a ExpenseReceiptItem
     * @example
     * // Get one ExpenseReceiptItem
     * const expenseReceiptItem = await prisma.expenseReceiptItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseReceiptItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseReceiptItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseReceiptItemClient<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseReceiptItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptItemFindFirstArgs} args - Arguments to find a ExpenseReceiptItem
     * @example
     * // Get one ExpenseReceiptItem
     * const expenseReceiptItem = await prisma.expenseReceiptItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseReceiptItemFindFirstArgs>(args?: SelectSubset<T, ExpenseReceiptItemFindFirstArgs<ExtArgs>>): Prisma__ExpenseReceiptItemClient<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseReceiptItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptItemFindFirstOrThrowArgs} args - Arguments to find a ExpenseReceiptItem
     * @example
     * // Get one ExpenseReceiptItem
     * const expenseReceiptItem = await prisma.expenseReceiptItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseReceiptItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseReceiptItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseReceiptItemClient<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseReceiptItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseReceiptItems
     * const expenseReceiptItems = await prisma.expenseReceiptItem.findMany()
     * 
     * // Get first 10 ExpenseReceiptItems
     * const expenseReceiptItems = await prisma.expenseReceiptItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseReceiptItemWithIdOnly = await prisma.expenseReceiptItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseReceiptItemFindManyArgs>(args?: SelectSubset<T, ExpenseReceiptItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseReceiptItem.
     * @param {ExpenseReceiptItemCreateArgs} args - Arguments to create a ExpenseReceiptItem.
     * @example
     * // Create one ExpenseReceiptItem
     * const ExpenseReceiptItem = await prisma.expenseReceiptItem.create({
     *   data: {
     *     // ... data to create a ExpenseReceiptItem
     *   }
     * })
     * 
     */
    create<T extends ExpenseReceiptItemCreateArgs>(args: SelectSubset<T, ExpenseReceiptItemCreateArgs<ExtArgs>>): Prisma__ExpenseReceiptItemClient<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseReceiptItems.
     * @param {ExpenseReceiptItemCreateManyArgs} args - Arguments to create many ExpenseReceiptItems.
     * @example
     * // Create many ExpenseReceiptItems
     * const expenseReceiptItem = await prisma.expenseReceiptItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseReceiptItemCreateManyArgs>(args?: SelectSubset<T, ExpenseReceiptItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseReceiptItems and returns the data saved in the database.
     * @param {ExpenseReceiptItemCreateManyAndReturnArgs} args - Arguments to create many ExpenseReceiptItems.
     * @example
     * // Create many ExpenseReceiptItems
     * const expenseReceiptItem = await prisma.expenseReceiptItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseReceiptItems and only return the `id`
     * const expenseReceiptItemWithIdOnly = await prisma.expenseReceiptItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseReceiptItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseReceiptItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseReceiptItem.
     * @param {ExpenseReceiptItemDeleteArgs} args - Arguments to delete one ExpenseReceiptItem.
     * @example
     * // Delete one ExpenseReceiptItem
     * const ExpenseReceiptItem = await prisma.expenseReceiptItem.delete({
     *   where: {
     *     // ... filter to delete one ExpenseReceiptItem
     *   }
     * })
     * 
     */
    delete<T extends ExpenseReceiptItemDeleteArgs>(args: SelectSubset<T, ExpenseReceiptItemDeleteArgs<ExtArgs>>): Prisma__ExpenseReceiptItemClient<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseReceiptItem.
     * @param {ExpenseReceiptItemUpdateArgs} args - Arguments to update one ExpenseReceiptItem.
     * @example
     * // Update one ExpenseReceiptItem
     * const expenseReceiptItem = await prisma.expenseReceiptItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseReceiptItemUpdateArgs>(args: SelectSubset<T, ExpenseReceiptItemUpdateArgs<ExtArgs>>): Prisma__ExpenseReceiptItemClient<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseReceiptItems.
     * @param {ExpenseReceiptItemDeleteManyArgs} args - Arguments to filter ExpenseReceiptItems to delete.
     * @example
     * // Delete a few ExpenseReceiptItems
     * const { count } = await prisma.expenseReceiptItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseReceiptItemDeleteManyArgs>(args?: SelectSubset<T, ExpenseReceiptItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseReceiptItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseReceiptItems
     * const expenseReceiptItem = await prisma.expenseReceiptItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseReceiptItemUpdateManyArgs>(args: SelectSubset<T, ExpenseReceiptItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseReceiptItems and returns the data updated in the database.
     * @param {ExpenseReceiptItemUpdateManyAndReturnArgs} args - Arguments to update many ExpenseReceiptItems.
     * @example
     * // Update many ExpenseReceiptItems
     * const expenseReceiptItem = await prisma.expenseReceiptItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseReceiptItems and only return the `id`
     * const expenseReceiptItemWithIdOnly = await prisma.expenseReceiptItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseReceiptItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseReceiptItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseReceiptItem.
     * @param {ExpenseReceiptItemUpsertArgs} args - Arguments to update or create a ExpenseReceiptItem.
     * @example
     * // Update or create a ExpenseReceiptItem
     * const expenseReceiptItem = await prisma.expenseReceiptItem.upsert({
     *   create: {
     *     // ... data to create a ExpenseReceiptItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseReceiptItem we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseReceiptItemUpsertArgs>(args: SelectSubset<T, ExpenseReceiptItemUpsertArgs<ExtArgs>>): Prisma__ExpenseReceiptItemClient<$Result.GetResult<Prisma.$ExpenseReceiptItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseReceiptItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptItemCountArgs} args - Arguments to filter ExpenseReceiptItems to count.
     * @example
     * // Count the number of ExpenseReceiptItems
     * const count = await prisma.expenseReceiptItem.count({
     *   where: {
     *     // ... the filter for the ExpenseReceiptItems we want to count
     *   }
     * })
    **/
    count<T extends ExpenseReceiptItemCountArgs>(
      args?: Subset<T, ExpenseReceiptItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseReceiptItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseReceiptItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseReceiptItemAggregateArgs>(args: Subset<T, ExpenseReceiptItemAggregateArgs>): Prisma.PrismaPromise<GetExpenseReceiptItemAggregateType<T>>

    /**
     * Group by ExpenseReceiptItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseReceiptItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseReceiptItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseReceiptItemGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseReceiptItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseReceiptItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseReceiptItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseReceiptItem model
   */
  readonly fields: ExpenseReceiptItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseReceiptItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseReceiptItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receipt<T extends ExpenseReceiptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseReceiptDefaultArgs<ExtArgs>>): Prisma__ExpenseReceiptClient<$Result.GetResult<Prisma.$ExpenseReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ExpenseReceiptItem$productArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseReceiptItem$productArgs<ExtArgs>>): Prisma__ExpenseProductClient<$Result.GetResult<Prisma.$ExpenseProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseReceiptItem model
   */
  interface ExpenseReceiptItemFieldRefs {
    readonly id: FieldRef<"ExpenseReceiptItem", 'Int'>
    readonly uuid: FieldRef<"ExpenseReceiptItem", 'String'>
    readonly receipt_uuid: FieldRef<"ExpenseReceiptItem", 'String'>
    readonly product_uuid: FieldRef<"ExpenseReceiptItem", 'String'>
    readonly quantity: FieldRef<"ExpenseReceiptItem", 'Decimal'>
    readonly unit_price: FieldRef<"ExpenseReceiptItem", 'Decimal'>
    readonly total_price: FieldRef<"ExpenseReceiptItem", 'Decimal'>
    readonly created_at: FieldRef<"ExpenseReceiptItem", 'DateTime'>
    readonly updated_at: FieldRef<"ExpenseReceiptItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseReceiptItem findUnique
   */
  export type ExpenseReceiptItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceiptItem to fetch.
     */
    where: ExpenseReceiptItemWhereUniqueInput
  }

  /**
   * ExpenseReceiptItem findUniqueOrThrow
   */
  export type ExpenseReceiptItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceiptItem to fetch.
     */
    where: ExpenseReceiptItemWhereUniqueInput
  }

  /**
   * ExpenseReceiptItem findFirst
   */
  export type ExpenseReceiptItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceiptItem to fetch.
     */
    where?: ExpenseReceiptItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseReceiptItems to fetch.
     */
    orderBy?: ExpenseReceiptItemOrderByWithRelationInput | ExpenseReceiptItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseReceiptItems.
     */
    cursor?: ExpenseReceiptItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseReceiptItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseReceiptItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseReceiptItems.
     */
    distinct?: ExpenseReceiptItemScalarFieldEnum | ExpenseReceiptItemScalarFieldEnum[]
  }

  /**
   * ExpenseReceiptItem findFirstOrThrow
   */
  export type ExpenseReceiptItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceiptItem to fetch.
     */
    where?: ExpenseReceiptItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseReceiptItems to fetch.
     */
    orderBy?: ExpenseReceiptItemOrderByWithRelationInput | ExpenseReceiptItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseReceiptItems.
     */
    cursor?: ExpenseReceiptItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseReceiptItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseReceiptItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseReceiptItems.
     */
    distinct?: ExpenseReceiptItemScalarFieldEnum | ExpenseReceiptItemScalarFieldEnum[]
  }

  /**
   * ExpenseReceiptItem findMany
   */
  export type ExpenseReceiptItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseReceiptItems to fetch.
     */
    where?: ExpenseReceiptItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseReceiptItems to fetch.
     */
    orderBy?: ExpenseReceiptItemOrderByWithRelationInput | ExpenseReceiptItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseReceiptItems.
     */
    cursor?: ExpenseReceiptItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseReceiptItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseReceiptItems.
     */
    skip?: number
    distinct?: ExpenseReceiptItemScalarFieldEnum | ExpenseReceiptItemScalarFieldEnum[]
  }

  /**
   * ExpenseReceiptItem create
   */
  export type ExpenseReceiptItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseReceiptItem.
     */
    data: XOR<ExpenseReceiptItemCreateInput, ExpenseReceiptItemUncheckedCreateInput>
  }

  /**
   * ExpenseReceiptItem createMany
   */
  export type ExpenseReceiptItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseReceiptItems.
     */
    data: ExpenseReceiptItemCreateManyInput | ExpenseReceiptItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseReceiptItem createManyAndReturn
   */
  export type ExpenseReceiptItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseReceiptItems.
     */
    data: ExpenseReceiptItemCreateManyInput | ExpenseReceiptItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseReceiptItem update
   */
  export type ExpenseReceiptItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseReceiptItem.
     */
    data: XOR<ExpenseReceiptItemUpdateInput, ExpenseReceiptItemUncheckedUpdateInput>
    /**
     * Choose, which ExpenseReceiptItem to update.
     */
    where: ExpenseReceiptItemWhereUniqueInput
  }

  /**
   * ExpenseReceiptItem updateMany
   */
  export type ExpenseReceiptItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseReceiptItems.
     */
    data: XOR<ExpenseReceiptItemUpdateManyMutationInput, ExpenseReceiptItemUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseReceiptItems to update
     */
    where?: ExpenseReceiptItemWhereInput
    /**
     * Limit how many ExpenseReceiptItems to update.
     */
    limit?: number
  }

  /**
   * ExpenseReceiptItem updateManyAndReturn
   */
  export type ExpenseReceiptItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseReceiptItems.
     */
    data: XOR<ExpenseReceiptItemUpdateManyMutationInput, ExpenseReceiptItemUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseReceiptItems to update
     */
    where?: ExpenseReceiptItemWhereInput
    /**
     * Limit how many ExpenseReceiptItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseReceiptItem upsert
   */
  export type ExpenseReceiptItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseReceiptItem to update in case it exists.
     */
    where: ExpenseReceiptItemWhereUniqueInput
    /**
     * In case the ExpenseReceiptItem found by the `where` argument doesn't exist, create a new ExpenseReceiptItem with this data.
     */
    create: XOR<ExpenseReceiptItemCreateInput, ExpenseReceiptItemUncheckedCreateInput>
    /**
     * In case the ExpenseReceiptItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseReceiptItemUpdateInput, ExpenseReceiptItemUncheckedUpdateInput>
  }

  /**
   * ExpenseReceiptItem delete
   */
  export type ExpenseReceiptItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
    /**
     * Filter which ExpenseReceiptItem to delete.
     */
    where: ExpenseReceiptItemWhereUniqueInput
  }

  /**
   * ExpenseReceiptItem deleteMany
   */
  export type ExpenseReceiptItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseReceiptItems to delete
     */
    where?: ExpenseReceiptItemWhereInput
    /**
     * Limit how many ExpenseReceiptItems to delete.
     */
    limit?: number
  }

  /**
   * ExpenseReceiptItem.product
   */
  export type ExpenseReceiptItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseProduct
     */
    select?: ExpenseProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseProduct
     */
    omit?: ExpenseProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseProductInclude<ExtArgs> | null
    where?: ExpenseProductWhereInput
  }

  /**
   * ExpenseReceiptItem without action
   */
  export type ExpenseReceiptItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseReceiptItem
     */
    select?: ExpenseReceiptItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseReceiptItem
     */
    omit?: ExpenseReceiptItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseReceiptItemInclude<ExtArgs> | null
  }


  /**
   * Model MuscleGroup
   */

  export type AggregateMuscleGroup = {
    _count: MuscleGroupCountAggregateOutputType | null
    _avg: MuscleGroupAvgAggregateOutputType | null
    _sum: MuscleGroupSumAggregateOutputType | null
    _min: MuscleGroupMinAggregateOutputType | null
    _max: MuscleGroupMaxAggregateOutputType | null
  }

  export type MuscleGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type MuscleGroupSumAggregateOutputType = {
    id: number | null
  }

  export type MuscleGroupMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    color: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MuscleGroupMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    color: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MuscleGroupCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    name: number
    color: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MuscleGroupAvgAggregateInputType = {
    id?: true
  }

  export type MuscleGroupSumAggregateInputType = {
    id?: true
  }

  export type MuscleGroupMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    color?: true
    created_at?: true
    updated_at?: true
  }

  export type MuscleGroupMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    color?: true
    created_at?: true
    updated_at?: true
  }

  export type MuscleGroupCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    color?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MuscleGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MuscleGroup to aggregate.
     */
    where?: MuscleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuscleGroups to fetch.
     */
    orderBy?: MuscleGroupOrderByWithRelationInput | MuscleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MuscleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuscleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuscleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MuscleGroups
    **/
    _count?: true | MuscleGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MuscleGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MuscleGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuscleGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuscleGroupMaxAggregateInputType
  }

  export type GetMuscleGroupAggregateType<T extends MuscleGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateMuscleGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMuscleGroup[P]>
      : GetScalarType<T[P], AggregateMuscleGroup[P]>
  }




  export type MuscleGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuscleGroupWhereInput
    orderBy?: MuscleGroupOrderByWithAggregationInput | MuscleGroupOrderByWithAggregationInput[]
    by: MuscleGroupScalarFieldEnum[] | MuscleGroupScalarFieldEnum
    having?: MuscleGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuscleGroupCountAggregateInputType | true
    _avg?: MuscleGroupAvgAggregateInputType
    _sum?: MuscleGroupSumAggregateInputType
    _min?: MuscleGroupMinAggregateInputType
    _max?: MuscleGroupMaxAggregateInputType
  }

  export type MuscleGroupGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string | null
    name: string
    color: string | null
    created_at: Date
    updated_at: Date
    _count: MuscleGroupCountAggregateOutputType | null
    _avg: MuscleGroupAvgAggregateOutputType | null
    _sum: MuscleGroupSumAggregateOutputType | null
    _min: MuscleGroupMinAggregateOutputType | null
    _max: MuscleGroupMaxAggregateOutputType | null
  }

  type GetMuscleGroupGroupByPayload<T extends MuscleGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MuscleGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MuscleGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MuscleGroupGroupByOutputType[P]>
            : GetScalarType<T[P], MuscleGroupGroupByOutputType[P]>
        }
      >
    >


  export type MuscleGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | MuscleGroup$userArgs<ExtArgs>
    exercises?: boolean | MuscleGroup$exercisesArgs<ExtArgs>
    _count?: boolean | MuscleGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["muscleGroup"]>

  export type MuscleGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | MuscleGroup$userArgs<ExtArgs>
  }, ExtArgs["result"]["muscleGroup"]>

  export type MuscleGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | MuscleGroup$userArgs<ExtArgs>
  }, ExtArgs["result"]["muscleGroup"]>

  export type MuscleGroupSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MuscleGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "name" | "color" | "created_at" | "updated_at", ExtArgs["result"]["muscleGroup"]>
  export type MuscleGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MuscleGroup$userArgs<ExtArgs>
    exercises?: boolean | MuscleGroup$exercisesArgs<ExtArgs>
    _count?: boolean | MuscleGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MuscleGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MuscleGroup$userArgs<ExtArgs>
  }
  export type MuscleGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MuscleGroup$userArgs<ExtArgs>
  }

  export type $MuscleGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MuscleGroup"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string | null
      name: string
      color: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["muscleGroup"]>
    composites: {}
  }

  type MuscleGroupGetPayload<S extends boolean | null | undefined | MuscleGroupDefaultArgs> = $Result.GetResult<Prisma.$MuscleGroupPayload, S>

  type MuscleGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MuscleGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MuscleGroupCountAggregateInputType | true
    }

  export interface MuscleGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MuscleGroup'], meta: { name: 'MuscleGroup' } }
    /**
     * Find zero or one MuscleGroup that matches the filter.
     * @param {MuscleGroupFindUniqueArgs} args - Arguments to find a MuscleGroup
     * @example
     * // Get one MuscleGroup
     * const muscleGroup = await prisma.muscleGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MuscleGroupFindUniqueArgs>(args: SelectSubset<T, MuscleGroupFindUniqueArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MuscleGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MuscleGroupFindUniqueOrThrowArgs} args - Arguments to find a MuscleGroup
     * @example
     * // Get one MuscleGroup
     * const muscleGroup = await prisma.muscleGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MuscleGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, MuscleGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MuscleGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuscleGroupFindFirstArgs} args - Arguments to find a MuscleGroup
     * @example
     * // Get one MuscleGroup
     * const muscleGroup = await prisma.muscleGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MuscleGroupFindFirstArgs>(args?: SelectSubset<T, MuscleGroupFindFirstArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MuscleGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuscleGroupFindFirstOrThrowArgs} args - Arguments to find a MuscleGroup
     * @example
     * // Get one MuscleGroup
     * const muscleGroup = await prisma.muscleGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MuscleGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, MuscleGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MuscleGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuscleGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MuscleGroups
     * const muscleGroups = await prisma.muscleGroup.findMany()
     * 
     * // Get first 10 MuscleGroups
     * const muscleGroups = await prisma.muscleGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const muscleGroupWithIdOnly = await prisma.muscleGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MuscleGroupFindManyArgs>(args?: SelectSubset<T, MuscleGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MuscleGroup.
     * @param {MuscleGroupCreateArgs} args - Arguments to create a MuscleGroup.
     * @example
     * // Create one MuscleGroup
     * const MuscleGroup = await prisma.muscleGroup.create({
     *   data: {
     *     // ... data to create a MuscleGroup
     *   }
     * })
     * 
     */
    create<T extends MuscleGroupCreateArgs>(args: SelectSubset<T, MuscleGroupCreateArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MuscleGroups.
     * @param {MuscleGroupCreateManyArgs} args - Arguments to create many MuscleGroups.
     * @example
     * // Create many MuscleGroups
     * const muscleGroup = await prisma.muscleGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MuscleGroupCreateManyArgs>(args?: SelectSubset<T, MuscleGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MuscleGroups and returns the data saved in the database.
     * @param {MuscleGroupCreateManyAndReturnArgs} args - Arguments to create many MuscleGroups.
     * @example
     * // Create many MuscleGroups
     * const muscleGroup = await prisma.muscleGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MuscleGroups and only return the `id`
     * const muscleGroupWithIdOnly = await prisma.muscleGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MuscleGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, MuscleGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MuscleGroup.
     * @param {MuscleGroupDeleteArgs} args - Arguments to delete one MuscleGroup.
     * @example
     * // Delete one MuscleGroup
     * const MuscleGroup = await prisma.muscleGroup.delete({
     *   where: {
     *     // ... filter to delete one MuscleGroup
     *   }
     * })
     * 
     */
    delete<T extends MuscleGroupDeleteArgs>(args: SelectSubset<T, MuscleGroupDeleteArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MuscleGroup.
     * @param {MuscleGroupUpdateArgs} args - Arguments to update one MuscleGroup.
     * @example
     * // Update one MuscleGroup
     * const muscleGroup = await prisma.muscleGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MuscleGroupUpdateArgs>(args: SelectSubset<T, MuscleGroupUpdateArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MuscleGroups.
     * @param {MuscleGroupDeleteManyArgs} args - Arguments to filter MuscleGroups to delete.
     * @example
     * // Delete a few MuscleGroups
     * const { count } = await prisma.muscleGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MuscleGroupDeleteManyArgs>(args?: SelectSubset<T, MuscleGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MuscleGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuscleGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MuscleGroups
     * const muscleGroup = await prisma.muscleGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MuscleGroupUpdateManyArgs>(args: SelectSubset<T, MuscleGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MuscleGroups and returns the data updated in the database.
     * @param {MuscleGroupUpdateManyAndReturnArgs} args - Arguments to update many MuscleGroups.
     * @example
     * // Update many MuscleGroups
     * const muscleGroup = await prisma.muscleGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MuscleGroups and only return the `id`
     * const muscleGroupWithIdOnly = await prisma.muscleGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MuscleGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, MuscleGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MuscleGroup.
     * @param {MuscleGroupUpsertArgs} args - Arguments to update or create a MuscleGroup.
     * @example
     * // Update or create a MuscleGroup
     * const muscleGroup = await prisma.muscleGroup.upsert({
     *   create: {
     *     // ... data to create a MuscleGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MuscleGroup we want to update
     *   }
     * })
     */
    upsert<T extends MuscleGroupUpsertArgs>(args: SelectSubset<T, MuscleGroupUpsertArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MuscleGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuscleGroupCountArgs} args - Arguments to filter MuscleGroups to count.
     * @example
     * // Count the number of MuscleGroups
     * const count = await prisma.muscleGroup.count({
     *   where: {
     *     // ... the filter for the MuscleGroups we want to count
     *   }
     * })
    **/
    count<T extends MuscleGroupCountArgs>(
      args?: Subset<T, MuscleGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuscleGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MuscleGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuscleGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuscleGroupAggregateArgs>(args: Subset<T, MuscleGroupAggregateArgs>): Prisma.PrismaPromise<GetMuscleGroupAggregateType<T>>

    /**
     * Group by MuscleGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuscleGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuscleGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuscleGroupGroupByArgs['orderBy'] }
        : { orderBy?: MuscleGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuscleGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuscleGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MuscleGroup model
   */
  readonly fields: MuscleGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MuscleGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MuscleGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends MuscleGroup$userArgs<ExtArgs> = {}>(args?: Subset<T, MuscleGroup$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    exercises<T extends MuscleGroup$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, MuscleGroup$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MuscleGroup model
   */
  interface MuscleGroupFieldRefs {
    readonly id: FieldRef<"MuscleGroup", 'Int'>
    readonly uuid: FieldRef<"MuscleGroup", 'String'>
    readonly user_uuid: FieldRef<"MuscleGroup", 'String'>
    readonly name: FieldRef<"MuscleGroup", 'String'>
    readonly color: FieldRef<"MuscleGroup", 'String'>
    readonly created_at: FieldRef<"MuscleGroup", 'DateTime'>
    readonly updated_at: FieldRef<"MuscleGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MuscleGroup findUnique
   */
  export type MuscleGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * Filter, which MuscleGroup to fetch.
     */
    where: MuscleGroupWhereUniqueInput
  }

  /**
   * MuscleGroup findUniqueOrThrow
   */
  export type MuscleGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * Filter, which MuscleGroup to fetch.
     */
    where: MuscleGroupWhereUniqueInput
  }

  /**
   * MuscleGroup findFirst
   */
  export type MuscleGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * Filter, which MuscleGroup to fetch.
     */
    where?: MuscleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuscleGroups to fetch.
     */
    orderBy?: MuscleGroupOrderByWithRelationInput | MuscleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuscleGroups.
     */
    cursor?: MuscleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuscleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuscleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuscleGroups.
     */
    distinct?: MuscleGroupScalarFieldEnum | MuscleGroupScalarFieldEnum[]
  }

  /**
   * MuscleGroup findFirstOrThrow
   */
  export type MuscleGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * Filter, which MuscleGroup to fetch.
     */
    where?: MuscleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuscleGroups to fetch.
     */
    orderBy?: MuscleGroupOrderByWithRelationInput | MuscleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuscleGroups.
     */
    cursor?: MuscleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuscleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuscleGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuscleGroups.
     */
    distinct?: MuscleGroupScalarFieldEnum | MuscleGroupScalarFieldEnum[]
  }

  /**
   * MuscleGroup findMany
   */
  export type MuscleGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * Filter, which MuscleGroups to fetch.
     */
    where?: MuscleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuscleGroups to fetch.
     */
    orderBy?: MuscleGroupOrderByWithRelationInput | MuscleGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MuscleGroups.
     */
    cursor?: MuscleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuscleGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuscleGroups.
     */
    skip?: number
    distinct?: MuscleGroupScalarFieldEnum | MuscleGroupScalarFieldEnum[]
  }

  /**
   * MuscleGroup create
   */
  export type MuscleGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a MuscleGroup.
     */
    data: XOR<MuscleGroupCreateInput, MuscleGroupUncheckedCreateInput>
  }

  /**
   * MuscleGroup createMany
   */
  export type MuscleGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MuscleGroups.
     */
    data: MuscleGroupCreateManyInput | MuscleGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MuscleGroup createManyAndReturn
   */
  export type MuscleGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * The data used to create many MuscleGroups.
     */
    data: MuscleGroupCreateManyInput | MuscleGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MuscleGroup update
   */
  export type MuscleGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a MuscleGroup.
     */
    data: XOR<MuscleGroupUpdateInput, MuscleGroupUncheckedUpdateInput>
    /**
     * Choose, which MuscleGroup to update.
     */
    where: MuscleGroupWhereUniqueInput
  }

  /**
   * MuscleGroup updateMany
   */
  export type MuscleGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MuscleGroups.
     */
    data: XOR<MuscleGroupUpdateManyMutationInput, MuscleGroupUncheckedUpdateManyInput>
    /**
     * Filter which MuscleGroups to update
     */
    where?: MuscleGroupWhereInput
    /**
     * Limit how many MuscleGroups to update.
     */
    limit?: number
  }

  /**
   * MuscleGroup updateManyAndReturn
   */
  export type MuscleGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * The data used to update MuscleGroups.
     */
    data: XOR<MuscleGroupUpdateManyMutationInput, MuscleGroupUncheckedUpdateManyInput>
    /**
     * Filter which MuscleGroups to update
     */
    where?: MuscleGroupWhereInput
    /**
     * Limit how many MuscleGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MuscleGroup upsert
   */
  export type MuscleGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the MuscleGroup to update in case it exists.
     */
    where: MuscleGroupWhereUniqueInput
    /**
     * In case the MuscleGroup found by the `where` argument doesn't exist, create a new MuscleGroup with this data.
     */
    create: XOR<MuscleGroupCreateInput, MuscleGroupUncheckedCreateInput>
    /**
     * In case the MuscleGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MuscleGroupUpdateInput, MuscleGroupUncheckedUpdateInput>
  }

  /**
   * MuscleGroup delete
   */
  export type MuscleGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
    /**
     * Filter which MuscleGroup to delete.
     */
    where: MuscleGroupWhereUniqueInput
  }

  /**
   * MuscleGroup deleteMany
   */
  export type MuscleGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MuscleGroups to delete
     */
    where?: MuscleGroupWhereInput
    /**
     * Limit how many MuscleGroups to delete.
     */
    limit?: number
  }

  /**
   * MuscleGroup.user
   */
  export type MuscleGroup$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MuscleGroup.exercises
   */
  export type MuscleGroup$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * MuscleGroup without action
   */
  export type MuscleGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuscleGroup
     */
    select?: MuscleGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MuscleGroup
     */
    omit?: MuscleGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuscleGroupInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    id: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    id: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    muscle_group_uuid: string | null
    name: string | null
    description: string | null
    type: $Enums.ExerciseType | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    muscle_group_uuid: string | null
    name: string | null
    description: string | null
    type: $Enums.ExerciseType | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    muscle_group_uuid: number
    name: number
    description: number
    type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    id?: true
  }

  export type ExerciseSumAggregateInputType = {
    id?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    muscle_group_uuid?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    muscle_group_uuid?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    muscle_group_uuid?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string | null
    muscle_group_uuid: string
    name: string
    description: string | null
    type: $Enums.ExerciseType
    created_at: Date
    updated_at: Date
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    muscle_group_uuid?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | Exercise$userArgs<ExtArgs>
    muscle_group?: boolean | MuscleGroupDefaultArgs<ExtArgs>
    entries?: boolean | Exercise$entriesArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    muscle_group_uuid?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | Exercise$userArgs<ExtArgs>
    muscle_group?: boolean | MuscleGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    muscle_group_uuid?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | Exercise$userArgs<ExtArgs>
    muscle_group?: boolean | MuscleGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    muscle_group_uuid?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "muscle_group_uuid" | "name" | "description" | "type" | "created_at" | "updated_at", ExtArgs["result"]["exercise"]>
  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Exercise$userArgs<ExtArgs>
    muscle_group?: boolean | MuscleGroupDefaultArgs<ExtArgs>
    entries?: boolean | Exercise$entriesArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Exercise$userArgs<ExtArgs>
    muscle_group?: boolean | MuscleGroupDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Exercise$userArgs<ExtArgs>
    muscle_group?: boolean | MuscleGroupDefaultArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      muscle_group: Prisma.$MuscleGroupPayload<ExtArgs>
      entries: Prisma.$WorkoutEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string | null
      muscle_group_uuid: string
      name: string
      description: string | null
      type: $Enums.ExerciseType
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises and returns the data updated in the database.
     * @param {ExerciseUpdateManyAndReturnArgs} args - Arguments to update many Exercises.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Exercise$userArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    muscle_group<T extends MuscleGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MuscleGroupDefaultArgs<ExtArgs>>): Prisma__MuscleGroupClient<$Result.GetResult<Prisma.$MuscleGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entries<T extends Exercise$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'Int'>
    readonly uuid: FieldRef<"Exercise", 'String'>
    readonly user_uuid: FieldRef<"Exercise", 'String'>
    readonly muscle_group_uuid: FieldRef<"Exercise", 'String'>
    readonly name: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly type: FieldRef<"Exercise", 'ExerciseType'>
    readonly created_at: FieldRef<"Exercise", 'DateTime'>
    readonly updated_at: FieldRef<"Exercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
  }

  /**
   * Exercise updateManyAndReturn
   */
  export type ExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to delete.
     */
    limit?: number
  }

  /**
   * Exercise.user
   */
  export type Exercise$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Exercise.entries
   */
  export type Exercise$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    where?: WorkoutEntryWhereInput
    orderBy?: WorkoutEntryOrderByWithRelationInput | WorkoutEntryOrderByWithRelationInput[]
    cursor?: WorkoutEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutEntryScalarFieldEnum | WorkoutEntryScalarFieldEnum[]
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model Workout
   */

  export type AggregateWorkout = {
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  export type WorkoutAvgAggregateOutputType = {
    id: number | null
  }

  export type WorkoutSumAggregateOutputType = {
    id: number | null
  }

  export type WorkoutMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    notes: string | null
    started_at: Date | null
    finished_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkoutMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    user_uuid: string | null
    name: string | null
    notes: string | null
    started_at: Date | null
    finished_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkoutCountAggregateOutputType = {
    id: number
    uuid: number
    user_uuid: number
    name: number
    notes: number
    started_at: number
    finished_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WorkoutAvgAggregateInputType = {
    id?: true
  }

  export type WorkoutSumAggregateInputType = {
    id?: true
  }

  export type WorkoutMinAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    notes?: true
    started_at?: true
    finished_at?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkoutMaxAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    notes?: true
    started_at?: true
    finished_at?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkoutCountAggregateInputType = {
    id?: true
    uuid?: true
    user_uuid?: true
    name?: true
    notes?: true
    started_at?: true
    finished_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WorkoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workout to aggregate.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workouts
    **/
    _count?: true | WorkoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutMaxAggregateInputType
  }

  export type GetWorkoutAggregateType<T extends WorkoutAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkout[P]>
      : GetScalarType<T[P], AggregateWorkout[P]>
  }




  export type WorkoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutWhereInput
    orderBy?: WorkoutOrderByWithAggregationInput | WorkoutOrderByWithAggregationInput[]
    by: WorkoutScalarFieldEnum[] | WorkoutScalarFieldEnum
    having?: WorkoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutCountAggregateInputType | true
    _avg?: WorkoutAvgAggregateInputType
    _sum?: WorkoutSumAggregateInputType
    _min?: WorkoutMinAggregateInputType
    _max?: WorkoutMaxAggregateInputType
  }

  export type WorkoutGroupByOutputType = {
    id: number
    uuid: string
    user_uuid: string | null
    name: string | null
    notes: string | null
    started_at: Date
    finished_at: Date
    created_at: Date
    updated_at: Date
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  type GetWorkoutGroupByPayload<T extends WorkoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    notes?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | Workout$userArgs<ExtArgs>
    entries?: boolean | Workout$entriesArgs<ExtArgs>
    _count?: boolean | WorkoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workout"]>

  export type WorkoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    notes?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | Workout$userArgs<ExtArgs>
  }, ExtArgs["result"]["workout"]>

  export type WorkoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    notes?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | Workout$userArgs<ExtArgs>
  }, ExtArgs["result"]["workout"]>

  export type WorkoutSelectScalar = {
    id?: boolean
    uuid?: boolean
    user_uuid?: boolean
    name?: boolean
    notes?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WorkoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "user_uuid" | "name" | "notes" | "started_at" | "finished_at" | "created_at" | "updated_at", ExtArgs["result"]["workout"]>
  export type WorkoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Workout$userArgs<ExtArgs>
    entries?: boolean | Workout$entriesArgs<ExtArgs>
    _count?: boolean | WorkoutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Workout$userArgs<ExtArgs>
  }
  export type WorkoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Workout$userArgs<ExtArgs>
  }

  export type $WorkoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workout"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      entries: Prisma.$WorkoutEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      user_uuid: string | null
      name: string | null
      notes: string | null
      started_at: Date
      finished_at: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["workout"]>
    composites: {}
  }

  type WorkoutGetPayload<S extends boolean | null | undefined | WorkoutDefaultArgs> = $Result.GetResult<Prisma.$WorkoutPayload, S>

  type WorkoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutCountAggregateInputType | true
    }

  export interface WorkoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workout'], meta: { name: 'Workout' } }
    /**
     * Find zero or one Workout that matches the filter.
     * @param {WorkoutFindUniqueArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutFindUniqueArgs>(args: SelectSubset<T, WorkoutFindUniqueArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutFindUniqueOrThrowArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutFindFirstArgs>(args?: SelectSubset<T, WorkoutFindFirstArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstOrThrowArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workouts
     * const workouts = await prisma.workout.findMany()
     * 
     * // Get first 10 Workouts
     * const workouts = await prisma.workout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutWithIdOnly = await prisma.workout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutFindManyArgs>(args?: SelectSubset<T, WorkoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workout.
     * @param {WorkoutCreateArgs} args - Arguments to create a Workout.
     * @example
     * // Create one Workout
     * const Workout = await prisma.workout.create({
     *   data: {
     *     // ... data to create a Workout
     *   }
     * })
     * 
     */
    create<T extends WorkoutCreateArgs>(args: SelectSubset<T, WorkoutCreateArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workouts.
     * @param {WorkoutCreateManyArgs} args - Arguments to create many Workouts.
     * @example
     * // Create many Workouts
     * const workout = await prisma.workout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutCreateManyArgs>(args?: SelectSubset<T, WorkoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workouts and returns the data saved in the database.
     * @param {WorkoutCreateManyAndReturnArgs} args - Arguments to create many Workouts.
     * @example
     * // Create many Workouts
     * const workout = await prisma.workout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workouts and only return the `id`
     * const workoutWithIdOnly = await prisma.workout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workout.
     * @param {WorkoutDeleteArgs} args - Arguments to delete one Workout.
     * @example
     * // Delete one Workout
     * const Workout = await prisma.workout.delete({
     *   where: {
     *     // ... filter to delete one Workout
     *   }
     * })
     * 
     */
    delete<T extends WorkoutDeleteArgs>(args: SelectSubset<T, WorkoutDeleteArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workout.
     * @param {WorkoutUpdateArgs} args - Arguments to update one Workout.
     * @example
     * // Update one Workout
     * const workout = await prisma.workout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutUpdateArgs>(args: SelectSubset<T, WorkoutUpdateArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workouts.
     * @param {WorkoutDeleteManyArgs} args - Arguments to filter Workouts to delete.
     * @example
     * // Delete a few Workouts
     * const { count } = await prisma.workout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutDeleteManyArgs>(args?: SelectSubset<T, WorkoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workouts
     * const workout = await prisma.workout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutUpdateManyArgs>(args: SelectSubset<T, WorkoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workouts and returns the data updated in the database.
     * @param {WorkoutUpdateManyAndReturnArgs} args - Arguments to update many Workouts.
     * @example
     * // Update many Workouts
     * const workout = await prisma.workout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workouts and only return the `id`
     * const workoutWithIdOnly = await prisma.workout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workout.
     * @param {WorkoutUpsertArgs} args - Arguments to update or create a Workout.
     * @example
     * // Update or create a Workout
     * const workout = await prisma.workout.upsert({
     *   create: {
     *     // ... data to create a Workout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workout we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutUpsertArgs>(args: SelectSubset<T, WorkoutUpsertArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutCountArgs} args - Arguments to filter Workouts to count.
     * @example
     * // Count the number of Workouts
     * const count = await prisma.workout.count({
     *   where: {
     *     // ... the filter for the Workouts we want to count
     *   }
     * })
    **/
    count<T extends WorkoutCountArgs>(
      args?: Subset<T, WorkoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutAggregateArgs>(args: Subset<T, WorkoutAggregateArgs>): Prisma.PrismaPromise<GetWorkoutAggregateType<T>>

    /**
     * Group by Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workout model
   */
  readonly fields: WorkoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Workout$userArgs<ExtArgs> = {}>(args?: Subset<T, Workout$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    entries<T extends Workout$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Workout$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workout model
   */
  interface WorkoutFieldRefs {
    readonly id: FieldRef<"Workout", 'Int'>
    readonly uuid: FieldRef<"Workout", 'String'>
    readonly user_uuid: FieldRef<"Workout", 'String'>
    readonly name: FieldRef<"Workout", 'String'>
    readonly notes: FieldRef<"Workout", 'String'>
    readonly started_at: FieldRef<"Workout", 'DateTime'>
    readonly finished_at: FieldRef<"Workout", 'DateTime'>
    readonly created_at: FieldRef<"Workout", 'DateTime'>
    readonly updated_at: FieldRef<"Workout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workout findUnique
   */
  export type WorkoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout findUniqueOrThrow
   */
  export type WorkoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout findFirst
   */
  export type WorkoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     */
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout findFirstOrThrow
   */
  export type WorkoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     */
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout findMany
   */
  export type WorkoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workouts to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout create
   */
  export type WorkoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Workout.
     */
    data: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
  }

  /**
   * Workout createMany
   */
  export type WorkoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workouts.
     */
    data: WorkoutCreateManyInput | WorkoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workout createManyAndReturn
   */
  export type WorkoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * The data used to create many Workouts.
     */
    data: WorkoutCreateManyInput | WorkoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workout update
   */
  export type WorkoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Workout.
     */
    data: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
    /**
     * Choose, which Workout to update.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout updateMany
   */
  export type WorkoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workouts.
     */
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyInput>
    /**
     * Filter which Workouts to update
     */
    where?: WorkoutWhereInput
    /**
     * Limit how many Workouts to update.
     */
    limit?: number
  }

  /**
   * Workout updateManyAndReturn
   */
  export type WorkoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * The data used to update Workouts.
     */
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyInput>
    /**
     * Filter which Workouts to update
     */
    where?: WorkoutWhereInput
    /**
     * Limit how many Workouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workout upsert
   */
  export type WorkoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Workout to update in case it exists.
     */
    where: WorkoutWhereUniqueInput
    /**
     * In case the Workout found by the `where` argument doesn't exist, create a new Workout with this data.
     */
    create: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
    /**
     * In case the Workout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
  }

  /**
   * Workout delete
   */
  export type WorkoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter which Workout to delete.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout deleteMany
   */
  export type WorkoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workouts to delete
     */
    where?: WorkoutWhereInput
    /**
     * Limit how many Workouts to delete.
     */
    limit?: number
  }

  /**
   * Workout.user
   */
  export type Workout$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Workout.entries
   */
  export type Workout$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    where?: WorkoutEntryWhereInput
    orderBy?: WorkoutEntryOrderByWithRelationInput | WorkoutEntryOrderByWithRelationInput[]
    cursor?: WorkoutEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutEntryScalarFieldEnum | WorkoutEntryScalarFieldEnum[]
  }

  /**
   * Workout without action
   */
  export type WorkoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutEntry
   */

  export type AggregateWorkoutEntry = {
    _count: WorkoutEntryCountAggregateOutputType | null
    _avg: WorkoutEntryAvgAggregateOutputType | null
    _sum: WorkoutEntrySumAggregateOutputType | null
    _min: WorkoutEntryMinAggregateOutputType | null
    _max: WorkoutEntryMaxAggregateOutputType | null
  }

  export type WorkoutEntryAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type WorkoutEntrySumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type WorkoutEntryMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    workout_uuid: string | null
    exercise_uuid: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkoutEntryMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    workout_uuid: string | null
    exercise_uuid: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkoutEntryCountAggregateOutputType = {
    id: number
    uuid: number
    workout_uuid: number
    exercise_uuid: number
    order: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WorkoutEntryAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type WorkoutEntrySumAggregateInputType = {
    id?: true
    order?: true
  }

  export type WorkoutEntryMinAggregateInputType = {
    id?: true
    uuid?: true
    workout_uuid?: true
    exercise_uuid?: true
    order?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkoutEntryMaxAggregateInputType = {
    id?: true
    uuid?: true
    workout_uuid?: true
    exercise_uuid?: true
    order?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkoutEntryCountAggregateInputType = {
    id?: true
    uuid?: true
    workout_uuid?: true
    exercise_uuid?: true
    order?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WorkoutEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutEntry to aggregate.
     */
    where?: WorkoutEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutEntries to fetch.
     */
    orderBy?: WorkoutEntryOrderByWithRelationInput | WorkoutEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutEntries
    **/
    _count?: true | WorkoutEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutEntryMaxAggregateInputType
  }

  export type GetWorkoutEntryAggregateType<T extends WorkoutEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutEntry[P]>
      : GetScalarType<T[P], AggregateWorkoutEntry[P]>
  }




  export type WorkoutEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutEntryWhereInput
    orderBy?: WorkoutEntryOrderByWithAggregationInput | WorkoutEntryOrderByWithAggregationInput[]
    by: WorkoutEntryScalarFieldEnum[] | WorkoutEntryScalarFieldEnum
    having?: WorkoutEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutEntryCountAggregateInputType | true
    _avg?: WorkoutEntryAvgAggregateInputType
    _sum?: WorkoutEntrySumAggregateInputType
    _min?: WorkoutEntryMinAggregateInputType
    _max?: WorkoutEntryMaxAggregateInputType
  }

  export type WorkoutEntryGroupByOutputType = {
    id: number
    uuid: string
    workout_uuid: string
    exercise_uuid: string
    order: number
    created_at: Date
    updated_at: Date
    _count: WorkoutEntryCountAggregateOutputType | null
    _avg: WorkoutEntryAvgAggregateOutputType | null
    _sum: WorkoutEntrySumAggregateOutputType | null
    _min: WorkoutEntryMinAggregateOutputType | null
    _max: WorkoutEntryMaxAggregateOutputType | null
  }

  type GetWorkoutEntryGroupByPayload<T extends WorkoutEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutEntryGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutEntryGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    workout_uuid?: boolean
    exercise_uuid?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    sets?: boolean | WorkoutEntry$setsArgs<ExtArgs>
    _count?: boolean | WorkoutEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutEntry"]>

  export type WorkoutEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    workout_uuid?: boolean
    exercise_uuid?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutEntry"]>

  export type WorkoutEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    workout_uuid?: boolean
    exercise_uuid?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutEntry"]>

  export type WorkoutEntrySelectScalar = {
    id?: boolean
    uuid?: boolean
    workout_uuid?: boolean
    exercise_uuid?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WorkoutEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "workout_uuid" | "exercise_uuid" | "order" | "created_at" | "updated_at", ExtArgs["result"]["workoutEntry"]>
  export type WorkoutEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    sets?: boolean | WorkoutEntry$setsArgs<ExtArgs>
    _count?: boolean | WorkoutEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkoutEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type WorkoutEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $WorkoutEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutEntry"
    objects: {
      workout: Prisma.$WorkoutPayload<ExtArgs>
      exercise: Prisma.$ExercisePayload<ExtArgs>
      sets: Prisma.$WorkoutSetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      workout_uuid: string
      exercise_uuid: string
      order: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["workoutEntry"]>
    composites: {}
  }

  type WorkoutEntryGetPayload<S extends boolean | null | undefined | WorkoutEntryDefaultArgs> = $Result.GetResult<Prisma.$WorkoutEntryPayload, S>

  type WorkoutEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutEntryCountAggregateInputType | true
    }

  export interface WorkoutEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutEntry'], meta: { name: 'WorkoutEntry' } }
    /**
     * Find zero or one WorkoutEntry that matches the filter.
     * @param {WorkoutEntryFindUniqueArgs} args - Arguments to find a WorkoutEntry
     * @example
     * // Get one WorkoutEntry
     * const workoutEntry = await prisma.workoutEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutEntryFindUniqueArgs>(args: SelectSubset<T, WorkoutEntryFindUniqueArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkoutEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutEntryFindUniqueOrThrowArgs} args - Arguments to find a WorkoutEntry
     * @example
     * // Get one WorkoutEntry
     * const workoutEntry = await prisma.workoutEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutEntryFindFirstArgs} args - Arguments to find a WorkoutEntry
     * @example
     * // Get one WorkoutEntry
     * const workoutEntry = await prisma.workoutEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutEntryFindFirstArgs>(args?: SelectSubset<T, WorkoutEntryFindFirstArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutEntryFindFirstOrThrowArgs} args - Arguments to find a WorkoutEntry
     * @example
     * // Get one WorkoutEntry
     * const workoutEntry = await prisma.workoutEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkoutEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutEntries
     * const workoutEntries = await prisma.workoutEntry.findMany()
     * 
     * // Get first 10 WorkoutEntries
     * const workoutEntries = await prisma.workoutEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutEntryWithIdOnly = await prisma.workoutEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutEntryFindManyArgs>(args?: SelectSubset<T, WorkoutEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkoutEntry.
     * @param {WorkoutEntryCreateArgs} args - Arguments to create a WorkoutEntry.
     * @example
     * // Create one WorkoutEntry
     * const WorkoutEntry = await prisma.workoutEntry.create({
     *   data: {
     *     // ... data to create a WorkoutEntry
     *   }
     * })
     * 
     */
    create<T extends WorkoutEntryCreateArgs>(args: SelectSubset<T, WorkoutEntryCreateArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkoutEntries.
     * @param {WorkoutEntryCreateManyArgs} args - Arguments to create many WorkoutEntries.
     * @example
     * // Create many WorkoutEntries
     * const workoutEntry = await prisma.workoutEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutEntryCreateManyArgs>(args?: SelectSubset<T, WorkoutEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutEntries and returns the data saved in the database.
     * @param {WorkoutEntryCreateManyAndReturnArgs} args - Arguments to create many WorkoutEntries.
     * @example
     * // Create many WorkoutEntries
     * const workoutEntry = await prisma.workoutEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutEntries and only return the `id`
     * const workoutEntryWithIdOnly = await prisma.workoutEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkoutEntry.
     * @param {WorkoutEntryDeleteArgs} args - Arguments to delete one WorkoutEntry.
     * @example
     * // Delete one WorkoutEntry
     * const WorkoutEntry = await prisma.workoutEntry.delete({
     *   where: {
     *     // ... filter to delete one WorkoutEntry
     *   }
     * })
     * 
     */
    delete<T extends WorkoutEntryDeleteArgs>(args: SelectSubset<T, WorkoutEntryDeleteArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkoutEntry.
     * @param {WorkoutEntryUpdateArgs} args - Arguments to update one WorkoutEntry.
     * @example
     * // Update one WorkoutEntry
     * const workoutEntry = await prisma.workoutEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutEntryUpdateArgs>(args: SelectSubset<T, WorkoutEntryUpdateArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkoutEntries.
     * @param {WorkoutEntryDeleteManyArgs} args - Arguments to filter WorkoutEntries to delete.
     * @example
     * // Delete a few WorkoutEntries
     * const { count } = await prisma.workoutEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutEntryDeleteManyArgs>(args?: SelectSubset<T, WorkoutEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutEntries
     * const workoutEntry = await prisma.workoutEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutEntryUpdateManyArgs>(args: SelectSubset<T, WorkoutEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutEntries and returns the data updated in the database.
     * @param {WorkoutEntryUpdateManyAndReturnArgs} args - Arguments to update many WorkoutEntries.
     * @example
     * // Update many WorkoutEntries
     * const workoutEntry = await prisma.workoutEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkoutEntries and only return the `id`
     * const workoutEntryWithIdOnly = await prisma.workoutEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkoutEntry.
     * @param {WorkoutEntryUpsertArgs} args - Arguments to update or create a WorkoutEntry.
     * @example
     * // Update or create a WorkoutEntry
     * const workoutEntry = await prisma.workoutEntry.upsert({
     *   create: {
     *     // ... data to create a WorkoutEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutEntry we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutEntryUpsertArgs>(args: SelectSubset<T, WorkoutEntryUpsertArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkoutEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutEntryCountArgs} args - Arguments to filter WorkoutEntries to count.
     * @example
     * // Count the number of WorkoutEntries
     * const count = await prisma.workoutEntry.count({
     *   where: {
     *     // ... the filter for the WorkoutEntries we want to count
     *   }
     * })
    **/
    count<T extends WorkoutEntryCountArgs>(
      args?: Subset<T, WorkoutEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutEntryAggregateArgs>(args: Subset<T, WorkoutEntryAggregateArgs>): Prisma.PrismaPromise<GetWorkoutEntryAggregateType<T>>

    /**
     * Group by WorkoutEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutEntryGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutEntry model
   */
  readonly fields: WorkoutEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workout<T extends WorkoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutDefaultArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sets<T extends WorkoutEntry$setsArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutEntry$setsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutEntry model
   */
  interface WorkoutEntryFieldRefs {
    readonly id: FieldRef<"WorkoutEntry", 'Int'>
    readonly uuid: FieldRef<"WorkoutEntry", 'String'>
    readonly workout_uuid: FieldRef<"WorkoutEntry", 'String'>
    readonly exercise_uuid: FieldRef<"WorkoutEntry", 'String'>
    readonly order: FieldRef<"WorkoutEntry", 'Int'>
    readonly created_at: FieldRef<"WorkoutEntry", 'DateTime'>
    readonly updated_at: FieldRef<"WorkoutEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutEntry findUnique
   */
  export type WorkoutEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutEntry to fetch.
     */
    where: WorkoutEntryWhereUniqueInput
  }

  /**
   * WorkoutEntry findUniqueOrThrow
   */
  export type WorkoutEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutEntry to fetch.
     */
    where: WorkoutEntryWhereUniqueInput
  }

  /**
   * WorkoutEntry findFirst
   */
  export type WorkoutEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutEntry to fetch.
     */
    where?: WorkoutEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutEntries to fetch.
     */
    orderBy?: WorkoutEntryOrderByWithRelationInput | WorkoutEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutEntries.
     */
    cursor?: WorkoutEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutEntries.
     */
    distinct?: WorkoutEntryScalarFieldEnum | WorkoutEntryScalarFieldEnum[]
  }

  /**
   * WorkoutEntry findFirstOrThrow
   */
  export type WorkoutEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutEntry to fetch.
     */
    where?: WorkoutEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutEntries to fetch.
     */
    orderBy?: WorkoutEntryOrderByWithRelationInput | WorkoutEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutEntries.
     */
    cursor?: WorkoutEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutEntries.
     */
    distinct?: WorkoutEntryScalarFieldEnum | WorkoutEntryScalarFieldEnum[]
  }

  /**
   * WorkoutEntry findMany
   */
  export type WorkoutEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutEntries to fetch.
     */
    where?: WorkoutEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutEntries to fetch.
     */
    orderBy?: WorkoutEntryOrderByWithRelationInput | WorkoutEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutEntries.
     */
    cursor?: WorkoutEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutEntries.
     */
    skip?: number
    distinct?: WorkoutEntryScalarFieldEnum | WorkoutEntryScalarFieldEnum[]
  }

  /**
   * WorkoutEntry create
   */
  export type WorkoutEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutEntry.
     */
    data: XOR<WorkoutEntryCreateInput, WorkoutEntryUncheckedCreateInput>
  }

  /**
   * WorkoutEntry createMany
   */
  export type WorkoutEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutEntries.
     */
    data: WorkoutEntryCreateManyInput | WorkoutEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutEntry createManyAndReturn
   */
  export type WorkoutEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * The data used to create many WorkoutEntries.
     */
    data: WorkoutEntryCreateManyInput | WorkoutEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutEntry update
   */
  export type WorkoutEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutEntry.
     */
    data: XOR<WorkoutEntryUpdateInput, WorkoutEntryUncheckedUpdateInput>
    /**
     * Choose, which WorkoutEntry to update.
     */
    where: WorkoutEntryWhereUniqueInput
  }

  /**
   * WorkoutEntry updateMany
   */
  export type WorkoutEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutEntries.
     */
    data: XOR<WorkoutEntryUpdateManyMutationInput, WorkoutEntryUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutEntries to update
     */
    where?: WorkoutEntryWhereInput
    /**
     * Limit how many WorkoutEntries to update.
     */
    limit?: number
  }

  /**
   * WorkoutEntry updateManyAndReturn
   */
  export type WorkoutEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * The data used to update WorkoutEntries.
     */
    data: XOR<WorkoutEntryUpdateManyMutationInput, WorkoutEntryUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutEntries to update
     */
    where?: WorkoutEntryWhereInput
    /**
     * Limit how many WorkoutEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutEntry upsert
   */
  export type WorkoutEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutEntry to update in case it exists.
     */
    where: WorkoutEntryWhereUniqueInput
    /**
     * In case the WorkoutEntry found by the `where` argument doesn't exist, create a new WorkoutEntry with this data.
     */
    create: XOR<WorkoutEntryCreateInput, WorkoutEntryUncheckedCreateInput>
    /**
     * In case the WorkoutEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutEntryUpdateInput, WorkoutEntryUncheckedUpdateInput>
  }

  /**
   * WorkoutEntry delete
   */
  export type WorkoutEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
    /**
     * Filter which WorkoutEntry to delete.
     */
    where: WorkoutEntryWhereUniqueInput
  }

  /**
   * WorkoutEntry deleteMany
   */
  export type WorkoutEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutEntries to delete
     */
    where?: WorkoutEntryWhereInput
    /**
     * Limit how many WorkoutEntries to delete.
     */
    limit?: number
  }

  /**
   * WorkoutEntry.sets
   */
  export type WorkoutEntry$setsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    where?: WorkoutSetWhereInput
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    cursor?: WorkoutSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutSetScalarFieldEnum | WorkoutSetScalarFieldEnum[]
  }

  /**
   * WorkoutEntry without action
   */
  export type WorkoutEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutEntry
     */
    select?: WorkoutEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutEntry
     */
    omit?: WorkoutEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutEntryInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutSet
   */

  export type AggregateWorkoutSet = {
    _count: WorkoutSetCountAggregateOutputType | null
    _avg: WorkoutSetAvgAggregateOutputType | null
    _sum: WorkoutSetSumAggregateOutputType | null
    _min: WorkoutSetMinAggregateOutputType | null
    _max: WorkoutSetMaxAggregateOutputType | null
  }

  export type WorkoutSetAvgAggregateOutputType = {
    id: number | null
    reps: number | null
    weight: Decimal | null
    duration_seconds: number | null
    distance_meters: number | null
    rest_seconds: number | null
    order: number | null
  }

  export type WorkoutSetSumAggregateOutputType = {
    id: number | null
    reps: number | null
    weight: Decimal | null
    duration_seconds: number | null
    distance_meters: number | null
    rest_seconds: number | null
    order: number | null
  }

  export type WorkoutSetMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    workout_entry_uuid: string | null
    type: $Enums.ExerciseType | null
    reps: number | null
    weight: Decimal | null
    duration_seconds: number | null
    distance_meters: number | null
    rest_seconds: number | null
    notes: string | null
    is_dropset: boolean | null
    is_amrap: boolean | null
    is_rest: boolean | null
    is_warmup: boolean | null
    is_cooldown: boolean | null
    is_super_set: boolean | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkoutSetMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    workout_entry_uuid: string | null
    type: $Enums.ExerciseType | null
    reps: number | null
    weight: Decimal | null
    duration_seconds: number | null
    distance_meters: number | null
    rest_seconds: number | null
    notes: string | null
    is_dropset: boolean | null
    is_amrap: boolean | null
    is_rest: boolean | null
    is_warmup: boolean | null
    is_cooldown: boolean | null
    is_super_set: boolean | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkoutSetCountAggregateOutputType = {
    id: number
    uuid: number
    workout_entry_uuid: number
    type: number
    reps: number
    weight: number
    duration_seconds: number
    distance_meters: number
    rest_seconds: number
    notes: number
    is_dropset: number
    is_amrap: number
    is_rest: number
    is_warmup: number
    is_cooldown: number
    is_super_set: number
    order: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WorkoutSetAvgAggregateInputType = {
    id?: true
    reps?: true
    weight?: true
    duration_seconds?: true
    distance_meters?: true
    rest_seconds?: true
    order?: true
  }

  export type WorkoutSetSumAggregateInputType = {
    id?: true
    reps?: true
    weight?: true
    duration_seconds?: true
    distance_meters?: true
    rest_seconds?: true
    order?: true
  }

  export type WorkoutSetMinAggregateInputType = {
    id?: true
    uuid?: true
    workout_entry_uuid?: true
    type?: true
    reps?: true
    weight?: true
    duration_seconds?: true
    distance_meters?: true
    rest_seconds?: true
    notes?: true
    is_dropset?: true
    is_amrap?: true
    is_rest?: true
    is_warmup?: true
    is_cooldown?: true
    is_super_set?: true
    order?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkoutSetMaxAggregateInputType = {
    id?: true
    uuid?: true
    workout_entry_uuid?: true
    type?: true
    reps?: true
    weight?: true
    duration_seconds?: true
    distance_meters?: true
    rest_seconds?: true
    notes?: true
    is_dropset?: true
    is_amrap?: true
    is_rest?: true
    is_warmup?: true
    is_cooldown?: true
    is_super_set?: true
    order?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkoutSetCountAggregateInputType = {
    id?: true
    uuid?: true
    workout_entry_uuid?: true
    type?: true
    reps?: true
    weight?: true
    duration_seconds?: true
    distance_meters?: true
    rest_seconds?: true
    notes?: true
    is_dropset?: true
    is_amrap?: true
    is_rest?: true
    is_warmup?: true
    is_cooldown?: true
    is_super_set?: true
    order?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WorkoutSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutSet to aggregate.
     */
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     */
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutSets
    **/
    _count?: true | WorkoutSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutSetMaxAggregateInputType
  }

  export type GetWorkoutSetAggregateType<T extends WorkoutSetAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutSet[P]>
      : GetScalarType<T[P], AggregateWorkoutSet[P]>
  }




  export type WorkoutSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutSetWhereInput
    orderBy?: WorkoutSetOrderByWithAggregationInput | WorkoutSetOrderByWithAggregationInput[]
    by: WorkoutSetScalarFieldEnum[] | WorkoutSetScalarFieldEnum
    having?: WorkoutSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutSetCountAggregateInputType | true
    _avg?: WorkoutSetAvgAggregateInputType
    _sum?: WorkoutSetSumAggregateInputType
    _min?: WorkoutSetMinAggregateInputType
    _max?: WorkoutSetMaxAggregateInputType
  }

  export type WorkoutSetGroupByOutputType = {
    id: number
    uuid: string
    workout_entry_uuid: string
    type: $Enums.ExerciseType
    reps: number | null
    weight: Decimal | null
    duration_seconds: number | null
    distance_meters: number | null
    rest_seconds: number | null
    notes: string | null
    is_dropset: boolean
    is_amrap: boolean
    is_rest: boolean
    is_warmup: boolean
    is_cooldown: boolean
    is_super_set: boolean
    order: number
    created_at: Date
    updated_at: Date
    _count: WorkoutSetCountAggregateOutputType | null
    _avg: WorkoutSetAvgAggregateOutputType | null
    _sum: WorkoutSetSumAggregateOutputType | null
    _min: WorkoutSetMinAggregateOutputType | null
    _max: WorkoutSetMaxAggregateOutputType | null
  }

  type GetWorkoutSetGroupByPayload<T extends WorkoutSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutSetGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutSetGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    workout_entry_uuid?: boolean
    type?: boolean
    reps?: boolean
    weight?: boolean
    duration_seconds?: boolean
    distance_meters?: boolean
    rest_seconds?: boolean
    notes?: boolean
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    workout_entry?: boolean | WorkoutEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutSet"]>

  export type WorkoutSetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    workout_entry_uuid?: boolean
    type?: boolean
    reps?: boolean
    weight?: boolean
    duration_seconds?: boolean
    distance_meters?: boolean
    rest_seconds?: boolean
    notes?: boolean
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    workout_entry?: boolean | WorkoutEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutSet"]>

  export type WorkoutSetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    workout_entry_uuid?: boolean
    type?: boolean
    reps?: boolean
    weight?: boolean
    duration_seconds?: boolean
    distance_meters?: boolean
    rest_seconds?: boolean
    notes?: boolean
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    workout_entry?: boolean | WorkoutEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutSet"]>

  export type WorkoutSetSelectScalar = {
    id?: boolean
    uuid?: boolean
    workout_entry_uuid?: boolean
    type?: boolean
    reps?: boolean
    weight?: boolean
    duration_seconds?: boolean
    distance_meters?: boolean
    rest_seconds?: boolean
    notes?: boolean
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WorkoutSetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "workout_entry_uuid" | "type" | "reps" | "weight" | "duration_seconds" | "distance_meters" | "rest_seconds" | "notes" | "is_dropset" | "is_amrap" | "is_rest" | "is_warmup" | "is_cooldown" | "is_super_set" | "order" | "created_at" | "updated_at", ExtArgs["result"]["workoutSet"]>
  export type WorkoutSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout_entry?: boolean | WorkoutEntryDefaultArgs<ExtArgs>
  }
  export type WorkoutSetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout_entry?: boolean | WorkoutEntryDefaultArgs<ExtArgs>
  }
  export type WorkoutSetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout_entry?: boolean | WorkoutEntryDefaultArgs<ExtArgs>
  }

  export type $WorkoutSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutSet"
    objects: {
      workout_entry: Prisma.$WorkoutEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      workout_entry_uuid: string
      type: $Enums.ExerciseType
      reps: number | null
      weight: Prisma.Decimal | null
      duration_seconds: number | null
      distance_meters: number | null
      rest_seconds: number | null
      notes: string | null
      is_dropset: boolean
      is_amrap: boolean
      is_rest: boolean
      is_warmup: boolean
      is_cooldown: boolean
      is_super_set: boolean
      order: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["workoutSet"]>
    composites: {}
  }

  type WorkoutSetGetPayload<S extends boolean | null | undefined | WorkoutSetDefaultArgs> = $Result.GetResult<Prisma.$WorkoutSetPayload, S>

  type WorkoutSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutSetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutSetCountAggregateInputType | true
    }

  export interface WorkoutSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutSet'], meta: { name: 'WorkoutSet' } }
    /**
     * Find zero or one WorkoutSet that matches the filter.
     * @param {WorkoutSetFindUniqueArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutSetFindUniqueArgs>(args: SelectSubset<T, WorkoutSetFindUniqueArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkoutSet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutSetFindUniqueOrThrowArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutSetFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutSetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetFindFirstArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutSetFindFirstArgs>(args?: SelectSubset<T, WorkoutSetFindFirstArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetFindFirstOrThrowArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutSetFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutSetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkoutSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutSets
     * const workoutSets = await prisma.workoutSet.findMany()
     * 
     * // Get first 10 WorkoutSets
     * const workoutSets = await prisma.workoutSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutSetWithIdOnly = await prisma.workoutSet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutSetFindManyArgs>(args?: SelectSubset<T, WorkoutSetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkoutSet.
     * @param {WorkoutSetCreateArgs} args - Arguments to create a WorkoutSet.
     * @example
     * // Create one WorkoutSet
     * const WorkoutSet = await prisma.workoutSet.create({
     *   data: {
     *     // ... data to create a WorkoutSet
     *   }
     * })
     * 
     */
    create<T extends WorkoutSetCreateArgs>(args: SelectSubset<T, WorkoutSetCreateArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkoutSets.
     * @param {WorkoutSetCreateManyArgs} args - Arguments to create many WorkoutSets.
     * @example
     * // Create many WorkoutSets
     * const workoutSet = await prisma.workoutSet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutSetCreateManyArgs>(args?: SelectSubset<T, WorkoutSetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutSets and returns the data saved in the database.
     * @param {WorkoutSetCreateManyAndReturnArgs} args - Arguments to create many WorkoutSets.
     * @example
     * // Create many WorkoutSets
     * const workoutSet = await prisma.workoutSet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutSets and only return the `id`
     * const workoutSetWithIdOnly = await prisma.workoutSet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutSetCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutSetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkoutSet.
     * @param {WorkoutSetDeleteArgs} args - Arguments to delete one WorkoutSet.
     * @example
     * // Delete one WorkoutSet
     * const WorkoutSet = await prisma.workoutSet.delete({
     *   where: {
     *     // ... filter to delete one WorkoutSet
     *   }
     * })
     * 
     */
    delete<T extends WorkoutSetDeleteArgs>(args: SelectSubset<T, WorkoutSetDeleteArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkoutSet.
     * @param {WorkoutSetUpdateArgs} args - Arguments to update one WorkoutSet.
     * @example
     * // Update one WorkoutSet
     * const workoutSet = await prisma.workoutSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutSetUpdateArgs>(args: SelectSubset<T, WorkoutSetUpdateArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkoutSets.
     * @param {WorkoutSetDeleteManyArgs} args - Arguments to filter WorkoutSets to delete.
     * @example
     * // Delete a few WorkoutSets
     * const { count } = await prisma.workoutSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutSetDeleteManyArgs>(args?: SelectSubset<T, WorkoutSetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutSets
     * const workoutSet = await prisma.workoutSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutSetUpdateManyArgs>(args: SelectSubset<T, WorkoutSetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutSets and returns the data updated in the database.
     * @param {WorkoutSetUpdateManyAndReturnArgs} args - Arguments to update many WorkoutSets.
     * @example
     * // Update many WorkoutSets
     * const workoutSet = await prisma.workoutSet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkoutSets and only return the `id`
     * const workoutSetWithIdOnly = await prisma.workoutSet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutSetUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutSetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkoutSet.
     * @param {WorkoutSetUpsertArgs} args - Arguments to update or create a WorkoutSet.
     * @example
     * // Update or create a WorkoutSet
     * const workoutSet = await prisma.workoutSet.upsert({
     *   create: {
     *     // ... data to create a WorkoutSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutSet we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutSetUpsertArgs>(args: SelectSubset<T, WorkoutSetUpsertArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkoutSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetCountArgs} args - Arguments to filter WorkoutSets to count.
     * @example
     * // Count the number of WorkoutSets
     * const count = await prisma.workoutSet.count({
     *   where: {
     *     // ... the filter for the WorkoutSets we want to count
     *   }
     * })
    **/
    count<T extends WorkoutSetCountArgs>(
      args?: Subset<T, WorkoutSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutSetAggregateArgs>(args: Subset<T, WorkoutSetAggregateArgs>): Prisma.PrismaPromise<GetWorkoutSetAggregateType<T>>

    /**
     * Group by WorkoutSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutSetGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutSet model
   */
  readonly fields: WorkoutSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workout_entry<T extends WorkoutEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutEntryDefaultArgs<ExtArgs>>): Prisma__WorkoutEntryClient<$Result.GetResult<Prisma.$WorkoutEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutSet model
   */
  interface WorkoutSetFieldRefs {
    readonly id: FieldRef<"WorkoutSet", 'Int'>
    readonly uuid: FieldRef<"WorkoutSet", 'String'>
    readonly workout_entry_uuid: FieldRef<"WorkoutSet", 'String'>
    readonly type: FieldRef<"WorkoutSet", 'ExerciseType'>
    readonly reps: FieldRef<"WorkoutSet", 'Int'>
    readonly weight: FieldRef<"WorkoutSet", 'Decimal'>
    readonly duration_seconds: FieldRef<"WorkoutSet", 'Int'>
    readonly distance_meters: FieldRef<"WorkoutSet", 'Int'>
    readonly rest_seconds: FieldRef<"WorkoutSet", 'Int'>
    readonly notes: FieldRef<"WorkoutSet", 'String'>
    readonly is_dropset: FieldRef<"WorkoutSet", 'Boolean'>
    readonly is_amrap: FieldRef<"WorkoutSet", 'Boolean'>
    readonly is_rest: FieldRef<"WorkoutSet", 'Boolean'>
    readonly is_warmup: FieldRef<"WorkoutSet", 'Boolean'>
    readonly is_cooldown: FieldRef<"WorkoutSet", 'Boolean'>
    readonly is_super_set: FieldRef<"WorkoutSet", 'Boolean'>
    readonly order: FieldRef<"WorkoutSet", 'Int'>
    readonly created_at: FieldRef<"WorkoutSet", 'DateTime'>
    readonly updated_at: FieldRef<"WorkoutSet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutSet findUnique
   */
  export type WorkoutSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSet to fetch.
     */
    where: WorkoutSetWhereUniqueInput
  }

  /**
   * WorkoutSet findUniqueOrThrow
   */
  export type WorkoutSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSet to fetch.
     */
    where: WorkoutSetWhereUniqueInput
  }

  /**
   * WorkoutSet findFirst
   */
  export type WorkoutSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSet to fetch.
     */
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     */
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSets.
     */
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSets.
     */
    distinct?: WorkoutSetScalarFieldEnum | WorkoutSetScalarFieldEnum[]
  }

  /**
   * WorkoutSet findFirstOrThrow
   */
  export type WorkoutSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSet to fetch.
     */
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     */
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSets.
     */
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSets.
     */
    distinct?: WorkoutSetScalarFieldEnum | WorkoutSetScalarFieldEnum[]
  }

  /**
   * WorkoutSet findMany
   */
  export type WorkoutSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSets to fetch.
     */
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     */
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutSets.
     */
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     */
    skip?: number
    distinct?: WorkoutSetScalarFieldEnum | WorkoutSetScalarFieldEnum[]
  }

  /**
   * WorkoutSet create
   */
  export type WorkoutSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutSet.
     */
    data: XOR<WorkoutSetCreateInput, WorkoutSetUncheckedCreateInput>
  }

  /**
   * WorkoutSet createMany
   */
  export type WorkoutSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutSets.
     */
    data: WorkoutSetCreateManyInput | WorkoutSetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutSet createManyAndReturn
   */
  export type WorkoutSetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * The data used to create many WorkoutSets.
     */
    data: WorkoutSetCreateManyInput | WorkoutSetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutSet update
   */
  export type WorkoutSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutSet.
     */
    data: XOR<WorkoutSetUpdateInput, WorkoutSetUncheckedUpdateInput>
    /**
     * Choose, which WorkoutSet to update.
     */
    where: WorkoutSetWhereUniqueInput
  }

  /**
   * WorkoutSet updateMany
   */
  export type WorkoutSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutSets.
     */
    data: XOR<WorkoutSetUpdateManyMutationInput, WorkoutSetUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutSets to update
     */
    where?: WorkoutSetWhereInput
    /**
     * Limit how many WorkoutSets to update.
     */
    limit?: number
  }

  /**
   * WorkoutSet updateManyAndReturn
   */
  export type WorkoutSetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * The data used to update WorkoutSets.
     */
    data: XOR<WorkoutSetUpdateManyMutationInput, WorkoutSetUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutSets to update
     */
    where?: WorkoutSetWhereInput
    /**
     * Limit how many WorkoutSets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutSet upsert
   */
  export type WorkoutSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutSet to update in case it exists.
     */
    where: WorkoutSetWhereUniqueInput
    /**
     * In case the WorkoutSet found by the `where` argument doesn't exist, create a new WorkoutSet with this data.
     */
    create: XOR<WorkoutSetCreateInput, WorkoutSetUncheckedCreateInput>
    /**
     * In case the WorkoutSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutSetUpdateInput, WorkoutSetUncheckedUpdateInput>
  }

  /**
   * WorkoutSet delete
   */
  export type WorkoutSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter which WorkoutSet to delete.
     */
    where: WorkoutSetWhereUniqueInput
  }

  /**
   * WorkoutSet deleteMany
   */
  export type WorkoutSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutSets to delete
     */
    where?: WorkoutSetWhereInput
    /**
     * Limit how many WorkoutSets to delete.
     */
    limit?: number
  }

  /**
   * WorkoutSet without action
   */
  export type WorkoutSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutSet
     */
    omit?: WorkoutSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    email: 'email',
    phone: 'phone',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    role: 'role',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color',
    visible: 'visible',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const ScheduleSlotScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    activity_uuid: 'activity_uuid',
    day: 'day',
    start_time: 'start_time',
    end_time: 'end_time',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ScheduleSlotScalarFieldEnum = (typeof ScheduleSlotScalarFieldEnum)[keyof typeof ScheduleSlotScalarFieldEnum]


  export const ActivityScheduleScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    activity_uuid: 'activity_uuid',
    valid_from: 'valid_from',
    valid_until: 'valid_until',
    repeat_type: 'repeat_type',
    interval_days: 'interval_days',
    time_of_day: 'time_of_day',
    frequency_value: 'frequency_value',
    frequency_period: 'frequency_period',
    target_type: 'target_type',
    target_value: 'target_value',
    target_unit: 'target_unit',
    target_unit_label: 'target_unit_label',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivityScheduleScalarFieldEnum = (typeof ActivityScheduleScalarFieldEnum)[keyof typeof ActivityScheduleScalarFieldEnum]


  export const ActivityScheduleWeekdayScalarFieldEnum: {
    id: 'id',
    schedule_uuid: 'schedule_uuid',
    weekday: 'weekday'
  };

  export type ActivityScheduleWeekdayScalarFieldEnum = (typeof ActivityScheduleWeekdayScalarFieldEnum)[keyof typeof ActivityScheduleWeekdayScalarFieldEnum]


  export const ActivityScheduleDateScalarFieldEnum: {
    id: 'id',
    schedule_uuid: 'schedule_uuid',
    date: 'date'
  };

  export type ActivityScheduleDateScalarFieldEnum = (typeof ActivityScheduleDateScalarFieldEnum)[keyof typeof ActivityScheduleDateScalarFieldEnum]


  export const ActivityOccurrenceScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    activity_uuid: 'activity_uuid',
    schedule_uuid: 'schedule_uuid',
    scheduled_for: 'scheduled_for',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivityOccurrenceScalarFieldEnum = (typeof ActivityOccurrenceScalarFieldEnum)[keyof typeof ActivityOccurrenceScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    activity_uuid: 'activity_uuid',
    schedule_uuid: 'schedule_uuid',
    occurrence_uuid: 'occurrence_uuid',
    snapshot_target_type: 'snapshot_target_type',
    snapshot_target_value: 'snapshot_target_value',
    snapshot_target_unit: 'snapshot_target_unit',
    snapshot_target_unit_label: 'snapshot_target_unit_label',
    value: 'value',
    completed: 'completed',
    completed_at: 'completed_at',
    skipped: 'skipped',
    skip_reason: 'skip_reason',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const ExpenseAccountScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    name: 'name',
    icon: 'icon',
    color: 'color',
    balance: 'balance',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExpenseAccountScalarFieldEnum = (typeof ExpenseAccountScalarFieldEnum)[keyof typeof ExpenseAccountScalarFieldEnum]


  export const ExpenseCategoryScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    name: 'name',
    icon: 'icon',
    color: 'color',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExpenseCategoryScalarFieldEnum = (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum]


  export const ExpenseSubcategoryScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    category_uuid: 'category_uuid',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExpenseSubcategoryScalarFieldEnum = (typeof ExpenseSubcategoryScalarFieldEnum)[keyof typeof ExpenseSubcategoryScalarFieldEnum]


  export const ExpenseEntryScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    type: 'type',
    amount: 'amount',
    description: 'description',
    from_account_uuid: 'from_account_uuid',
    to_account_uuid: 'to_account_uuid',
    category_uuid: 'category_uuid',
    subcategory_uuid: 'subcategory_uuid',
    entry_date: 'entry_date',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExpenseEntryScalarFieldEnum = (typeof ExpenseEntryScalarFieldEnum)[keyof typeof ExpenseEntryScalarFieldEnum]


  export const ExpenseStoreScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExpenseStoreScalarFieldEnum = (typeof ExpenseStoreScalarFieldEnum)[keyof typeof ExpenseStoreScalarFieldEnum]


  export const ExpenseReceiptScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    store_uuid: 'store_uuid',
    expense_entry_uuid: 'expense_entry_uuid',
    receipt_date: 'receipt_date',
    total_amount: 'total_amount',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExpenseReceiptScalarFieldEnum = (typeof ExpenseReceiptScalarFieldEnum)[keyof typeof ExpenseReceiptScalarFieldEnum]


  export const ExpenseProductScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    name: 'name',
    brand: 'brand',
    unit: 'unit',
    size: 'size',
    category_uuid: 'category_uuid',
    subcategory_uuid: 'subcategory_uuid',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExpenseProductScalarFieldEnum = (typeof ExpenseProductScalarFieldEnum)[keyof typeof ExpenseProductScalarFieldEnum]


  export const ExpenseReceiptItemScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    receipt_uuid: 'receipt_uuid',
    product_uuid: 'product_uuid',
    quantity: 'quantity',
    unit_price: 'unit_price',
    total_price: 'total_price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExpenseReceiptItemScalarFieldEnum = (typeof ExpenseReceiptItemScalarFieldEnum)[keyof typeof ExpenseReceiptItemScalarFieldEnum]


  export const MuscleGroupScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    name: 'name',
    color: 'color',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MuscleGroupScalarFieldEnum = (typeof MuscleGroupScalarFieldEnum)[keyof typeof MuscleGroupScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    muscle_group_uuid: 'muscle_group_uuid',
    name: 'name',
    description: 'description',
    type: 'type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const WorkoutScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    user_uuid: 'user_uuid',
    name: 'name',
    notes: 'notes',
    started_at: 'started_at',
    finished_at: 'finished_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WorkoutScalarFieldEnum = (typeof WorkoutScalarFieldEnum)[keyof typeof WorkoutScalarFieldEnum]


  export const WorkoutEntryScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    workout_uuid: 'workout_uuid',
    exercise_uuid: 'exercise_uuid',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WorkoutEntryScalarFieldEnum = (typeof WorkoutEntryScalarFieldEnum)[keyof typeof WorkoutEntryScalarFieldEnum]


  export const WorkoutSetScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    workout_entry_uuid: 'workout_entry_uuid',
    type: 'type',
    reps: 'reps',
    weight: 'weight',
    duration_seconds: 'duration_seconds',
    distance_meters: 'distance_meters',
    rest_seconds: 'rest_seconds',
    notes: 'notes',
    is_dropset: 'is_dropset',
    is_amrap: 'is_amrap',
    is_rest: 'is_rest',
    is_warmup: 'is_warmup',
    is_cooldown: 'is_cooldown',
    is_super_set: 'is_super_set',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WorkoutSetScalarFieldEnum = (typeof WorkoutSetScalarFieldEnum)[keyof typeof WorkoutSetScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AuthRole'
   */
  export type EnumAuthRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthRole'>
    


  /**
   * Reference to a field of type 'AuthRole[]'
   */
  export type ListEnumAuthRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ScheduleDay'
   */
  export type EnumScheduleDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleDay'>
    


  /**
   * Reference to a field of type 'ScheduleDay[]'
   */
  export type ListEnumScheduleDayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleDay[]'>
    


  /**
   * Reference to a field of type 'ActivityRepeatType'
   */
  export type EnumActivityRepeatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityRepeatType'>
    


  /**
   * Reference to a field of type 'ActivityRepeatType[]'
   */
  export type ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityRepeatType[]'>
    


  /**
   * Reference to a field of type 'FrequencyPeriod'
   */
  export type EnumFrequencyPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FrequencyPeriod'>
    


  /**
   * Reference to a field of type 'FrequencyPeriod[]'
   */
  export type ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FrequencyPeriod[]'>
    


  /**
   * Reference to a field of type 'ActivityTargetType'
   */
  export type EnumActivityTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityTargetType'>
    


  /**
   * Reference to a field of type 'ActivityTargetType[]'
   */
  export type ListEnumActivityTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityTargetType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ActivityTargetUnit'
   */
  export type EnumActivityTargetUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityTargetUnit'>
    


  /**
   * Reference to a field of type 'ActivityTargetUnit[]'
   */
  export type ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityTargetUnit[]'>
    


  /**
   * Reference to a field of type 'OccurrenceStatus'
   */
  export type EnumOccurrenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccurrenceStatus'>
    


  /**
   * Reference to a field of type 'OccurrenceStatus[]'
   */
  export type ListEnumOccurrenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccurrenceStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ExpenseEntryType'
   */
  export type EnumExpenseEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseEntryType'>
    


  /**
   * Reference to a field of type 'ExpenseEntryType[]'
   */
  export type ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseEntryType[]'>
    


  /**
   * Reference to a field of type 'ExerciseType'
   */
  export type EnumExerciseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseType'>
    


  /**
   * Reference to a field of type 'ExerciseType[]'
   */
  export type ListEnumExerciseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    uuid?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    role?: EnumAuthRoleFilter<"User"> | $Enums.AuthRole
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    activities?: ActivityListRelationFilter
    schedule_slots?: ScheduleSlotListRelationFilter
    activity_schedules?: ActivityScheduleListRelationFilter
    activity_logs?: ActivityLogListRelationFilter
    activity_occurrences?: ActivityOccurrenceListRelationFilter
    expense_accounts?: ExpenseAccountListRelationFilter
    expense_entries?: ExpenseEntryListRelationFilter
    categories?: ExpenseCategoryListRelationFilter
    subcategories?: ExpenseSubcategoryListRelationFilter
    expense_receipts?: ExpenseReceiptListRelationFilter
    expense_stores?: ExpenseStoreListRelationFilter
    expense_products?: ExpenseProductListRelationFilter
    muscle_groups?: MuscleGroupListRelationFilter
    exercises?: ExerciseListRelationFilter
    workouts?: WorkoutListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    schedule_slots?: ScheduleSlotOrderByRelationAggregateInput
    activity_schedules?: ActivityScheduleOrderByRelationAggregateInput
    activity_logs?: ActivityLogOrderByRelationAggregateInput
    activity_occurrences?: ActivityOccurrenceOrderByRelationAggregateInput
    expense_accounts?: ExpenseAccountOrderByRelationAggregateInput
    expense_entries?: ExpenseEntryOrderByRelationAggregateInput
    categories?: ExpenseCategoryOrderByRelationAggregateInput
    subcategories?: ExpenseSubcategoryOrderByRelationAggregateInput
    expense_receipts?: ExpenseReceiptOrderByRelationAggregateInput
    expense_stores?: ExpenseStoreOrderByRelationAggregateInput
    expense_products?: ExpenseProductOrderByRelationAggregateInput
    muscle_groups?: MuscleGroupOrderByRelationAggregateInput
    exercises?: ExerciseOrderByRelationAggregateInput
    workouts?: WorkoutOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    role?: EnumAuthRoleFilter<"User"> | $Enums.AuthRole
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    activities?: ActivityListRelationFilter
    schedule_slots?: ScheduleSlotListRelationFilter
    activity_schedules?: ActivityScheduleListRelationFilter
    activity_logs?: ActivityLogListRelationFilter
    activity_occurrences?: ActivityOccurrenceListRelationFilter
    expense_accounts?: ExpenseAccountListRelationFilter
    expense_entries?: ExpenseEntryListRelationFilter
    categories?: ExpenseCategoryListRelationFilter
    subcategories?: ExpenseSubcategoryListRelationFilter
    expense_receipts?: ExpenseReceiptListRelationFilter
    expense_stores?: ExpenseStoreListRelationFilter
    expense_products?: ExpenseProductListRelationFilter
    muscle_groups?: MuscleGroupListRelationFilter
    exercises?: ExerciseListRelationFilter
    workouts?: WorkoutListRelationFilter
  }, "id" | "uuid" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    uuid?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    first_name?: StringWithAggregatesFilter<"User"> | string
    last_name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumAuthRoleWithAggregatesFilter<"User"> | $Enums.AuthRole
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: IntFilter<"Activity"> | number
    uuid?: StringFilter<"Activity"> | string
    user_uuid?: StringFilter<"Activity"> | string
    name?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    icon?: StringNullableFilter<"Activity"> | string | null
    color?: StringNullableFilter<"Activity"> | string | null
    visible?: BoolFilter<"Activity"> | boolean
    created_at?: DateTimeFilter<"Activity"> | Date | string
    updated_at?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedule_slots?: ScheduleSlotListRelationFilter
    activity_schedules?: ActivityScheduleListRelationFilter
    activity_logs?: ActivityLogListRelationFilter
    activity_occurrences?: ActivityOccurrenceListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    visible?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    schedule_slots?: ScheduleSlotOrderByRelationAggregateInput
    activity_schedules?: ActivityScheduleOrderByRelationAggregateInput
    activity_logs?: ActivityLogOrderByRelationAggregateInput
    activity_occurrences?: ActivityOccurrenceOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    user_uuid?: StringFilter<"Activity"> | string
    name?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    icon?: StringNullableFilter<"Activity"> | string | null
    color?: StringNullableFilter<"Activity"> | string | null
    visible?: BoolFilter<"Activity"> | boolean
    created_at?: DateTimeFilter<"Activity"> | Date | string
    updated_at?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedule_slots?: ScheduleSlotListRelationFilter
    activity_schedules?: ActivityScheduleListRelationFilter
    activity_logs?: ActivityLogListRelationFilter
    activity_occurrences?: ActivityOccurrenceListRelationFilter
  }, "id" | "uuid">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    visible?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Activity"> | number
    uuid?: StringWithAggregatesFilter<"Activity"> | string
    user_uuid?: StringWithAggregatesFilter<"Activity"> | string
    name?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    color?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    visible?: BoolWithAggregatesFilter<"Activity"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type ScheduleSlotWhereInput = {
    AND?: ScheduleSlotWhereInput | ScheduleSlotWhereInput[]
    OR?: ScheduleSlotWhereInput[]
    NOT?: ScheduleSlotWhereInput | ScheduleSlotWhereInput[]
    id?: IntFilter<"ScheduleSlot"> | number
    uuid?: StringFilter<"ScheduleSlot"> | string
    user_uuid?: StringFilter<"ScheduleSlot"> | string
    activity_uuid?: StringFilter<"ScheduleSlot"> | string
    day?: EnumScheduleDayFilter<"ScheduleSlot"> | $Enums.ScheduleDay
    start_time?: StringFilter<"ScheduleSlot"> | string
    end_time?: StringFilter<"ScheduleSlot"> | string
    created_at?: DateTimeFilter<"ScheduleSlot"> | Date | string
    updated_at?: DateTimeFilter<"ScheduleSlot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
  }

  export type ScheduleSlotOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type ScheduleSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ScheduleSlotWhereInput | ScheduleSlotWhereInput[]
    OR?: ScheduleSlotWhereInput[]
    NOT?: ScheduleSlotWhereInput | ScheduleSlotWhereInput[]
    user_uuid?: StringFilter<"ScheduleSlot"> | string
    activity_uuid?: StringFilter<"ScheduleSlot"> | string
    day?: EnumScheduleDayFilter<"ScheduleSlot"> | $Enums.ScheduleDay
    start_time?: StringFilter<"ScheduleSlot"> | string
    end_time?: StringFilter<"ScheduleSlot"> | string
    created_at?: DateTimeFilter<"ScheduleSlot"> | Date | string
    updated_at?: DateTimeFilter<"ScheduleSlot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
  }, "id" | "uuid">

  export type ScheduleSlotOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ScheduleSlotCountOrderByAggregateInput
    _avg?: ScheduleSlotAvgOrderByAggregateInput
    _max?: ScheduleSlotMaxOrderByAggregateInput
    _min?: ScheduleSlotMinOrderByAggregateInput
    _sum?: ScheduleSlotSumOrderByAggregateInput
  }

  export type ScheduleSlotScalarWhereWithAggregatesInput = {
    AND?: ScheduleSlotScalarWhereWithAggregatesInput | ScheduleSlotScalarWhereWithAggregatesInput[]
    OR?: ScheduleSlotScalarWhereWithAggregatesInput[]
    NOT?: ScheduleSlotScalarWhereWithAggregatesInput | ScheduleSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScheduleSlot"> | number
    uuid?: StringWithAggregatesFilter<"ScheduleSlot"> | string
    user_uuid?: StringWithAggregatesFilter<"ScheduleSlot"> | string
    activity_uuid?: StringWithAggregatesFilter<"ScheduleSlot"> | string
    day?: EnumScheduleDayWithAggregatesFilter<"ScheduleSlot"> | $Enums.ScheduleDay
    start_time?: StringWithAggregatesFilter<"ScheduleSlot"> | string
    end_time?: StringWithAggregatesFilter<"ScheduleSlot"> | string
    created_at?: DateTimeWithAggregatesFilter<"ScheduleSlot"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ScheduleSlot"> | Date | string
  }

  export type ActivityScheduleWhereInput = {
    AND?: ActivityScheduleWhereInput | ActivityScheduleWhereInput[]
    OR?: ActivityScheduleWhereInput[]
    NOT?: ActivityScheduleWhereInput | ActivityScheduleWhereInput[]
    id?: IntFilter<"ActivitySchedule"> | number
    uuid?: StringFilter<"ActivitySchedule"> | string
    user_uuid?: StringFilter<"ActivitySchedule"> | string
    activity_uuid?: StringFilter<"ActivitySchedule"> | string
    valid_from?: DateTimeFilter<"ActivitySchedule"> | Date | string
    valid_until?: DateTimeNullableFilter<"ActivitySchedule"> | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFilter<"ActivitySchedule"> | $Enums.ActivityRepeatType
    interval_days?: IntNullableFilter<"ActivitySchedule"> | number | null
    time_of_day?: StringNullableFilter<"ActivitySchedule"> | string | null
    frequency_value?: IntNullableFilter<"ActivitySchedule"> | number | null
    frequency_period?: EnumFrequencyPeriodNullableFilter<"ActivitySchedule"> | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFilter<"ActivitySchedule"> | $Enums.ActivityTargetType
    target_value?: FloatNullableFilter<"ActivitySchedule"> | number | null
    target_unit?: EnumActivityTargetUnitNullableFilter<"ActivitySchedule"> | $Enums.ActivityTargetUnit | null
    target_unit_label?: StringNullableFilter<"ActivitySchedule"> | string | null
    is_active?: BoolFilter<"ActivitySchedule"> | boolean
    created_at?: DateTimeFilter<"ActivitySchedule"> | Date | string
    updated_at?: DateTimeFilter<"ActivitySchedule"> | Date | string
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    weekdays?: ActivityScheduleWeekdayListRelationFilter
    specific_dates?: ActivityScheduleDateListRelationFilter
    occurrences?: ActivityOccurrenceListRelationFilter
    logs?: ActivityLogListRelationFilter
  }

  export type ActivityScheduleOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrderInput | SortOrder
    repeat_type?: SortOrder
    interval_days?: SortOrderInput | SortOrder
    time_of_day?: SortOrderInput | SortOrder
    frequency_value?: SortOrderInput | SortOrder
    frequency_period?: SortOrderInput | SortOrder
    target_type?: SortOrder
    target_value?: SortOrderInput | SortOrder
    target_unit?: SortOrderInput | SortOrder
    target_unit_label?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    weekdays?: ActivityScheduleWeekdayOrderByRelationAggregateInput
    specific_dates?: ActivityScheduleDateOrderByRelationAggregateInput
    occurrences?: ActivityOccurrenceOrderByRelationAggregateInput
    logs?: ActivityLogOrderByRelationAggregateInput
  }

  export type ActivityScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ActivityScheduleWhereInput | ActivityScheduleWhereInput[]
    OR?: ActivityScheduleWhereInput[]
    NOT?: ActivityScheduleWhereInput | ActivityScheduleWhereInput[]
    user_uuid?: StringFilter<"ActivitySchedule"> | string
    activity_uuid?: StringFilter<"ActivitySchedule"> | string
    valid_from?: DateTimeFilter<"ActivitySchedule"> | Date | string
    valid_until?: DateTimeNullableFilter<"ActivitySchedule"> | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFilter<"ActivitySchedule"> | $Enums.ActivityRepeatType
    interval_days?: IntNullableFilter<"ActivitySchedule"> | number | null
    time_of_day?: StringNullableFilter<"ActivitySchedule"> | string | null
    frequency_value?: IntNullableFilter<"ActivitySchedule"> | number | null
    frequency_period?: EnumFrequencyPeriodNullableFilter<"ActivitySchedule"> | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFilter<"ActivitySchedule"> | $Enums.ActivityTargetType
    target_value?: FloatNullableFilter<"ActivitySchedule"> | number | null
    target_unit?: EnumActivityTargetUnitNullableFilter<"ActivitySchedule"> | $Enums.ActivityTargetUnit | null
    target_unit_label?: StringNullableFilter<"ActivitySchedule"> | string | null
    is_active?: BoolFilter<"ActivitySchedule"> | boolean
    created_at?: DateTimeFilter<"ActivitySchedule"> | Date | string
    updated_at?: DateTimeFilter<"ActivitySchedule"> | Date | string
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    weekdays?: ActivityScheduleWeekdayListRelationFilter
    specific_dates?: ActivityScheduleDateListRelationFilter
    occurrences?: ActivityOccurrenceListRelationFilter
    logs?: ActivityLogListRelationFilter
  }, "id" | "uuid">

  export type ActivityScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrderInput | SortOrder
    repeat_type?: SortOrder
    interval_days?: SortOrderInput | SortOrder
    time_of_day?: SortOrderInput | SortOrder
    frequency_value?: SortOrderInput | SortOrder
    frequency_period?: SortOrderInput | SortOrder
    target_type?: SortOrder
    target_value?: SortOrderInput | SortOrder
    target_unit?: SortOrderInput | SortOrder
    target_unit_label?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ActivityScheduleCountOrderByAggregateInput
    _avg?: ActivityScheduleAvgOrderByAggregateInput
    _max?: ActivityScheduleMaxOrderByAggregateInput
    _min?: ActivityScheduleMinOrderByAggregateInput
    _sum?: ActivityScheduleSumOrderByAggregateInput
  }

  export type ActivityScheduleScalarWhereWithAggregatesInput = {
    AND?: ActivityScheduleScalarWhereWithAggregatesInput | ActivityScheduleScalarWhereWithAggregatesInput[]
    OR?: ActivityScheduleScalarWhereWithAggregatesInput[]
    NOT?: ActivityScheduleScalarWhereWithAggregatesInput | ActivityScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivitySchedule"> | number
    uuid?: StringWithAggregatesFilter<"ActivitySchedule"> | string
    user_uuid?: StringWithAggregatesFilter<"ActivitySchedule"> | string
    activity_uuid?: StringWithAggregatesFilter<"ActivitySchedule"> | string
    valid_from?: DateTimeWithAggregatesFilter<"ActivitySchedule"> | Date | string
    valid_until?: DateTimeNullableWithAggregatesFilter<"ActivitySchedule"> | Date | string | null
    repeat_type?: EnumActivityRepeatTypeWithAggregatesFilter<"ActivitySchedule"> | $Enums.ActivityRepeatType
    interval_days?: IntNullableWithAggregatesFilter<"ActivitySchedule"> | number | null
    time_of_day?: StringNullableWithAggregatesFilter<"ActivitySchedule"> | string | null
    frequency_value?: IntNullableWithAggregatesFilter<"ActivitySchedule"> | number | null
    frequency_period?: EnumFrequencyPeriodNullableWithAggregatesFilter<"ActivitySchedule"> | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeWithAggregatesFilter<"ActivitySchedule"> | $Enums.ActivityTargetType
    target_value?: FloatNullableWithAggregatesFilter<"ActivitySchedule"> | number | null
    target_unit?: EnumActivityTargetUnitNullableWithAggregatesFilter<"ActivitySchedule"> | $Enums.ActivityTargetUnit | null
    target_unit_label?: StringNullableWithAggregatesFilter<"ActivitySchedule"> | string | null
    is_active?: BoolWithAggregatesFilter<"ActivitySchedule"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ActivitySchedule"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ActivitySchedule"> | Date | string
  }

  export type ActivityScheduleWeekdayWhereInput = {
    AND?: ActivityScheduleWeekdayWhereInput | ActivityScheduleWeekdayWhereInput[]
    OR?: ActivityScheduleWeekdayWhereInput[]
    NOT?: ActivityScheduleWeekdayWhereInput | ActivityScheduleWeekdayWhereInput[]
    id?: IntFilter<"ActivityScheduleWeekday"> | number
    schedule_uuid?: StringFilter<"ActivityScheduleWeekday"> | string
    weekday?: IntFilter<"ActivityScheduleWeekday"> | number
    schedule?: XOR<ActivityScheduleScalarRelationFilter, ActivityScheduleWhereInput>
  }

  export type ActivityScheduleWeekdayOrderByWithRelationInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    weekday?: SortOrder
    schedule?: ActivityScheduleOrderByWithRelationInput
  }

  export type ActivityScheduleWeekdayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    schedule_uuid_weekday?: ActivityScheduleWeekdaySchedule_uuidWeekdayCompoundUniqueInput
    AND?: ActivityScheduleWeekdayWhereInput | ActivityScheduleWeekdayWhereInput[]
    OR?: ActivityScheduleWeekdayWhereInput[]
    NOT?: ActivityScheduleWeekdayWhereInput | ActivityScheduleWeekdayWhereInput[]
    schedule_uuid?: StringFilter<"ActivityScheduleWeekday"> | string
    weekday?: IntFilter<"ActivityScheduleWeekday"> | number
    schedule?: XOR<ActivityScheduleScalarRelationFilter, ActivityScheduleWhereInput>
  }, "id" | "schedule_uuid_weekday">

  export type ActivityScheduleWeekdayOrderByWithAggregationInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    weekday?: SortOrder
    _count?: ActivityScheduleWeekdayCountOrderByAggregateInput
    _avg?: ActivityScheduleWeekdayAvgOrderByAggregateInput
    _max?: ActivityScheduleWeekdayMaxOrderByAggregateInput
    _min?: ActivityScheduleWeekdayMinOrderByAggregateInput
    _sum?: ActivityScheduleWeekdaySumOrderByAggregateInput
  }

  export type ActivityScheduleWeekdayScalarWhereWithAggregatesInput = {
    AND?: ActivityScheduleWeekdayScalarWhereWithAggregatesInput | ActivityScheduleWeekdayScalarWhereWithAggregatesInput[]
    OR?: ActivityScheduleWeekdayScalarWhereWithAggregatesInput[]
    NOT?: ActivityScheduleWeekdayScalarWhereWithAggregatesInput | ActivityScheduleWeekdayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityScheduleWeekday"> | number
    schedule_uuid?: StringWithAggregatesFilter<"ActivityScheduleWeekday"> | string
    weekday?: IntWithAggregatesFilter<"ActivityScheduleWeekday"> | number
  }

  export type ActivityScheduleDateWhereInput = {
    AND?: ActivityScheduleDateWhereInput | ActivityScheduleDateWhereInput[]
    OR?: ActivityScheduleDateWhereInput[]
    NOT?: ActivityScheduleDateWhereInput | ActivityScheduleDateWhereInput[]
    id?: IntFilter<"ActivityScheduleDate"> | number
    schedule_uuid?: StringFilter<"ActivityScheduleDate"> | string
    date?: DateTimeFilter<"ActivityScheduleDate"> | Date | string
    schedule?: XOR<ActivityScheduleScalarRelationFilter, ActivityScheduleWhereInput>
  }

  export type ActivityScheduleDateOrderByWithRelationInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    date?: SortOrder
    schedule?: ActivityScheduleOrderByWithRelationInput
  }

  export type ActivityScheduleDateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    schedule_uuid_date?: ActivityScheduleDateSchedule_uuidDateCompoundUniqueInput
    AND?: ActivityScheduleDateWhereInput | ActivityScheduleDateWhereInput[]
    OR?: ActivityScheduleDateWhereInput[]
    NOT?: ActivityScheduleDateWhereInput | ActivityScheduleDateWhereInput[]
    schedule_uuid?: StringFilter<"ActivityScheduleDate"> | string
    date?: DateTimeFilter<"ActivityScheduleDate"> | Date | string
    schedule?: XOR<ActivityScheduleScalarRelationFilter, ActivityScheduleWhereInput>
  }, "id" | "schedule_uuid_date">

  export type ActivityScheduleDateOrderByWithAggregationInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    date?: SortOrder
    _count?: ActivityScheduleDateCountOrderByAggregateInput
    _avg?: ActivityScheduleDateAvgOrderByAggregateInput
    _max?: ActivityScheduleDateMaxOrderByAggregateInput
    _min?: ActivityScheduleDateMinOrderByAggregateInput
    _sum?: ActivityScheduleDateSumOrderByAggregateInput
  }

  export type ActivityScheduleDateScalarWhereWithAggregatesInput = {
    AND?: ActivityScheduleDateScalarWhereWithAggregatesInput | ActivityScheduleDateScalarWhereWithAggregatesInput[]
    OR?: ActivityScheduleDateScalarWhereWithAggregatesInput[]
    NOT?: ActivityScheduleDateScalarWhereWithAggregatesInput | ActivityScheduleDateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityScheduleDate"> | number
    schedule_uuid?: StringWithAggregatesFilter<"ActivityScheduleDate"> | string
    date?: DateTimeWithAggregatesFilter<"ActivityScheduleDate"> | Date | string
  }

  export type ActivityOccurrenceWhereInput = {
    AND?: ActivityOccurrenceWhereInput | ActivityOccurrenceWhereInput[]
    OR?: ActivityOccurrenceWhereInput[]
    NOT?: ActivityOccurrenceWhereInput | ActivityOccurrenceWhereInput[]
    id?: IntFilter<"ActivityOccurrence"> | number
    uuid?: StringFilter<"ActivityOccurrence"> | string
    user_uuid?: StringFilter<"ActivityOccurrence"> | string
    activity_uuid?: StringFilter<"ActivityOccurrence"> | string
    schedule_uuid?: StringFilter<"ActivityOccurrence"> | string
    scheduled_for?: DateTimeFilter<"ActivityOccurrence"> | Date | string
    status?: EnumOccurrenceStatusFilter<"ActivityOccurrence"> | $Enums.OccurrenceStatus
    created_at?: DateTimeFilter<"ActivityOccurrence"> | Date | string
    updated_at?: DateTimeFilter<"ActivityOccurrence"> | Date | string
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    schedule?: XOR<ActivityScheduleScalarRelationFilter, ActivityScheduleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    log?: XOR<ActivityLogNullableScalarRelationFilter, ActivityLogWhereInput> | null
  }

  export type ActivityOccurrenceOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    scheduled_for?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    schedule?: ActivityScheduleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    log?: ActivityLogOrderByWithRelationInput
  }

  export type ActivityOccurrenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    schedule_uuid_scheduled_for?: ActivityOccurrenceSchedule_uuidScheduled_forCompoundUniqueInput
    AND?: ActivityOccurrenceWhereInput | ActivityOccurrenceWhereInput[]
    OR?: ActivityOccurrenceWhereInput[]
    NOT?: ActivityOccurrenceWhereInput | ActivityOccurrenceWhereInput[]
    user_uuid?: StringFilter<"ActivityOccurrence"> | string
    activity_uuid?: StringFilter<"ActivityOccurrence"> | string
    schedule_uuid?: StringFilter<"ActivityOccurrence"> | string
    scheduled_for?: DateTimeFilter<"ActivityOccurrence"> | Date | string
    status?: EnumOccurrenceStatusFilter<"ActivityOccurrence"> | $Enums.OccurrenceStatus
    created_at?: DateTimeFilter<"ActivityOccurrence"> | Date | string
    updated_at?: DateTimeFilter<"ActivityOccurrence"> | Date | string
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    schedule?: XOR<ActivityScheduleScalarRelationFilter, ActivityScheduleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    log?: XOR<ActivityLogNullableScalarRelationFilter, ActivityLogWhereInput> | null
  }, "id" | "uuid" | "schedule_uuid_scheduled_for">

  export type ActivityOccurrenceOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    scheduled_for?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ActivityOccurrenceCountOrderByAggregateInput
    _avg?: ActivityOccurrenceAvgOrderByAggregateInput
    _max?: ActivityOccurrenceMaxOrderByAggregateInput
    _min?: ActivityOccurrenceMinOrderByAggregateInput
    _sum?: ActivityOccurrenceSumOrderByAggregateInput
  }

  export type ActivityOccurrenceScalarWhereWithAggregatesInput = {
    AND?: ActivityOccurrenceScalarWhereWithAggregatesInput | ActivityOccurrenceScalarWhereWithAggregatesInput[]
    OR?: ActivityOccurrenceScalarWhereWithAggregatesInput[]
    NOT?: ActivityOccurrenceScalarWhereWithAggregatesInput | ActivityOccurrenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityOccurrence"> | number
    uuid?: StringWithAggregatesFilter<"ActivityOccurrence"> | string
    user_uuid?: StringWithAggregatesFilter<"ActivityOccurrence"> | string
    activity_uuid?: StringWithAggregatesFilter<"ActivityOccurrence"> | string
    schedule_uuid?: StringWithAggregatesFilter<"ActivityOccurrence"> | string
    scheduled_for?: DateTimeWithAggregatesFilter<"ActivityOccurrence"> | Date | string
    status?: EnumOccurrenceStatusWithAggregatesFilter<"ActivityOccurrence"> | $Enums.OccurrenceStatus
    created_at?: DateTimeWithAggregatesFilter<"ActivityOccurrence"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ActivityOccurrence"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    uuid?: StringFilter<"ActivityLog"> | string
    user_uuid?: StringFilter<"ActivityLog"> | string
    activity_uuid?: StringFilter<"ActivityLog"> | string
    schedule_uuid?: StringFilter<"ActivityLog"> | string
    occurrence_uuid?: StringFilter<"ActivityLog"> | string
    snapshot_target_type?: EnumActivityTargetTypeFilter<"ActivityLog"> | $Enums.ActivityTargetType
    snapshot_target_value?: FloatNullableFilter<"ActivityLog"> | number | null
    snapshot_target_unit?: EnumActivityTargetUnitNullableFilter<"ActivityLog"> | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: StringNullableFilter<"ActivityLog"> | string | null
    value?: FloatNullableFilter<"ActivityLog"> | number | null
    completed?: BoolFilter<"ActivityLog"> | boolean
    completed_at?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
    skipped?: BoolFilter<"ActivityLog"> | boolean
    skip_reason?: StringNullableFilter<"ActivityLog"> | string | null
    notes?: StringNullableFilter<"ActivityLog"> | string | null
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
    updated_at?: DateTimeFilter<"ActivityLog"> | Date | string
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    schedule?: XOR<ActivityScheduleScalarRelationFilter, ActivityScheduleWhereInput>
    occurrence?: XOR<ActivityOccurrenceScalarRelationFilter, ActivityOccurrenceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    occurrence_uuid?: SortOrder
    snapshot_target_type?: SortOrder
    snapshot_target_value?: SortOrderInput | SortOrder
    snapshot_target_unit?: SortOrderInput | SortOrder
    snapshot_target_unit_label?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    completed?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    skipped?: SortOrder
    skip_reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    schedule?: ActivityScheduleOrderByWithRelationInput
    occurrence?: ActivityOccurrenceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    occurrence_uuid?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    user_uuid?: StringFilter<"ActivityLog"> | string
    activity_uuid?: StringFilter<"ActivityLog"> | string
    schedule_uuid?: StringFilter<"ActivityLog"> | string
    snapshot_target_type?: EnumActivityTargetTypeFilter<"ActivityLog"> | $Enums.ActivityTargetType
    snapshot_target_value?: FloatNullableFilter<"ActivityLog"> | number | null
    snapshot_target_unit?: EnumActivityTargetUnitNullableFilter<"ActivityLog"> | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: StringNullableFilter<"ActivityLog"> | string | null
    value?: FloatNullableFilter<"ActivityLog"> | number | null
    completed?: BoolFilter<"ActivityLog"> | boolean
    completed_at?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
    skipped?: BoolFilter<"ActivityLog"> | boolean
    skip_reason?: StringNullableFilter<"ActivityLog"> | string | null
    notes?: StringNullableFilter<"ActivityLog"> | string | null
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
    updated_at?: DateTimeFilter<"ActivityLog"> | Date | string
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    schedule?: XOR<ActivityScheduleScalarRelationFilter, ActivityScheduleWhereInput>
    occurrence?: XOR<ActivityOccurrenceScalarRelationFilter, ActivityOccurrenceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "uuid" | "occurrence_uuid">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    occurrence_uuid?: SortOrder
    snapshot_target_type?: SortOrder
    snapshot_target_value?: SortOrderInput | SortOrder
    snapshot_target_unit?: SortOrderInput | SortOrder
    snapshot_target_unit_label?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    completed?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    skipped?: SortOrder
    skip_reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    uuid?: StringWithAggregatesFilter<"ActivityLog"> | string
    user_uuid?: StringWithAggregatesFilter<"ActivityLog"> | string
    activity_uuid?: StringWithAggregatesFilter<"ActivityLog"> | string
    schedule_uuid?: StringWithAggregatesFilter<"ActivityLog"> | string
    occurrence_uuid?: StringWithAggregatesFilter<"ActivityLog"> | string
    snapshot_target_type?: EnumActivityTargetTypeWithAggregatesFilter<"ActivityLog"> | $Enums.ActivityTargetType
    snapshot_target_value?: FloatNullableWithAggregatesFilter<"ActivityLog"> | number | null
    snapshot_target_unit?: EnumActivityTargetUnitNullableWithAggregatesFilter<"ActivityLog"> | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    value?: FloatNullableWithAggregatesFilter<"ActivityLog"> | number | null
    completed?: BoolWithAggregatesFilter<"ActivityLog"> | boolean
    completed_at?: DateTimeNullableWithAggregatesFilter<"ActivityLog"> | Date | string | null
    skipped?: BoolWithAggregatesFilter<"ActivityLog"> | boolean
    skip_reason?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type ExpenseAccountWhereInput = {
    AND?: ExpenseAccountWhereInput | ExpenseAccountWhereInput[]
    OR?: ExpenseAccountWhereInput[]
    NOT?: ExpenseAccountWhereInput | ExpenseAccountWhereInput[]
    id?: IntFilter<"ExpenseAccount"> | number
    uuid?: StringFilter<"ExpenseAccount"> | string
    user_uuid?: StringFilter<"ExpenseAccount"> | string
    name?: StringFilter<"ExpenseAccount"> | string
    icon?: StringNullableFilter<"ExpenseAccount"> | string | null
    color?: StringNullableFilter<"ExpenseAccount"> | string | null
    balance?: DecimalFilter<"ExpenseAccount"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseAccount"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    entries_from?: ExpenseEntryListRelationFilter
    entries_to?: ExpenseEntryListRelationFilter
  }

  export type ExpenseAccountOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    entries_from?: ExpenseEntryOrderByRelationAggregateInput
    entries_to?: ExpenseEntryOrderByRelationAggregateInput
  }

  export type ExpenseAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ExpenseAccountWhereInput | ExpenseAccountWhereInput[]
    OR?: ExpenseAccountWhereInput[]
    NOT?: ExpenseAccountWhereInput | ExpenseAccountWhereInput[]
    user_uuid?: StringFilter<"ExpenseAccount"> | string
    name?: StringFilter<"ExpenseAccount"> | string
    icon?: StringNullableFilter<"ExpenseAccount"> | string | null
    color?: StringNullableFilter<"ExpenseAccount"> | string | null
    balance?: DecimalFilter<"ExpenseAccount"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseAccount"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    entries_from?: ExpenseEntryListRelationFilter
    entries_to?: ExpenseEntryListRelationFilter
  }, "id" | "uuid">

  export type ExpenseAccountOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExpenseAccountCountOrderByAggregateInput
    _avg?: ExpenseAccountAvgOrderByAggregateInput
    _max?: ExpenseAccountMaxOrderByAggregateInput
    _min?: ExpenseAccountMinOrderByAggregateInput
    _sum?: ExpenseAccountSumOrderByAggregateInput
  }

  export type ExpenseAccountScalarWhereWithAggregatesInput = {
    AND?: ExpenseAccountScalarWhereWithAggregatesInput | ExpenseAccountScalarWhereWithAggregatesInput[]
    OR?: ExpenseAccountScalarWhereWithAggregatesInput[]
    NOT?: ExpenseAccountScalarWhereWithAggregatesInput | ExpenseAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseAccount"> | number
    uuid?: StringWithAggregatesFilter<"ExpenseAccount"> | string
    user_uuid?: StringWithAggregatesFilter<"ExpenseAccount"> | string
    name?: StringWithAggregatesFilter<"ExpenseAccount"> | string
    icon?: StringNullableWithAggregatesFilter<"ExpenseAccount"> | string | null
    color?: StringNullableWithAggregatesFilter<"ExpenseAccount"> | string | null
    balance?: DecimalWithAggregatesFilter<"ExpenseAccount"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"ExpenseAccount"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ExpenseAccount"> | Date | string
  }

  export type ExpenseCategoryWhereInput = {
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    id?: IntFilter<"ExpenseCategory"> | number
    uuid?: StringFilter<"ExpenseCategory"> | string
    user_uuid?: StringNullableFilter<"ExpenseCategory"> | string | null
    name?: StringFilter<"ExpenseCategory"> | string
    icon?: StringNullableFilter<"ExpenseCategory"> | string | null
    color?: StringNullableFilter<"ExpenseCategory"> | string | null
    created_at?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseCategory"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subcategories?: ExpenseSubcategoryListRelationFilter
    entries?: ExpenseEntryListRelationFilter
    products?: ExpenseProductListRelationFilter
  }

  export type ExpenseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    subcategories?: ExpenseSubcategoryOrderByRelationAggregateInput
    entries?: ExpenseEntryOrderByRelationAggregateInput
    products?: ExpenseProductOrderByRelationAggregateInput
  }

  export type ExpenseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    user_uuid?: StringNullableFilter<"ExpenseCategory"> | string | null
    name?: StringFilter<"ExpenseCategory"> | string
    icon?: StringNullableFilter<"ExpenseCategory"> | string | null
    color?: StringNullableFilter<"ExpenseCategory"> | string | null
    created_at?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseCategory"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subcategories?: ExpenseSubcategoryListRelationFilter
    entries?: ExpenseEntryListRelationFilter
    products?: ExpenseProductListRelationFilter
  }, "id" | "uuid">

  export type ExpenseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExpenseCategoryCountOrderByAggregateInput
    _avg?: ExpenseCategoryAvgOrderByAggregateInput
    _max?: ExpenseCategoryMaxOrderByAggregateInput
    _min?: ExpenseCategoryMinOrderByAggregateInput
    _sum?: ExpenseCategorySumOrderByAggregateInput
  }

  export type ExpenseCategoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseCategory"> | number
    uuid?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    user_uuid?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
    name?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    icon?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
  }

  export type ExpenseSubcategoryWhereInput = {
    AND?: ExpenseSubcategoryWhereInput | ExpenseSubcategoryWhereInput[]
    OR?: ExpenseSubcategoryWhereInput[]
    NOT?: ExpenseSubcategoryWhereInput | ExpenseSubcategoryWhereInput[]
    id?: IntFilter<"ExpenseSubcategory"> | number
    uuid?: StringFilter<"ExpenseSubcategory"> | string
    user_uuid?: StringNullableFilter<"ExpenseSubcategory"> | string | null
    category_uuid?: StringFilter<"ExpenseSubcategory"> | string
    name?: StringFilter<"ExpenseSubcategory"> | string
    created_at?: DateTimeFilter<"ExpenseSubcategory"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseSubcategory"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    category?: XOR<ExpenseCategoryScalarRelationFilter, ExpenseCategoryWhereInput>
    entries?: ExpenseEntryListRelationFilter
    products?: ExpenseProductListRelationFilter
  }

  export type ExpenseSubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    category_uuid?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    category?: ExpenseCategoryOrderByWithRelationInput
    entries?: ExpenseEntryOrderByRelationAggregateInput
    products?: ExpenseProductOrderByRelationAggregateInput
  }

  export type ExpenseSubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ExpenseSubcategoryWhereInput | ExpenseSubcategoryWhereInput[]
    OR?: ExpenseSubcategoryWhereInput[]
    NOT?: ExpenseSubcategoryWhereInput | ExpenseSubcategoryWhereInput[]
    user_uuid?: StringNullableFilter<"ExpenseSubcategory"> | string | null
    category_uuid?: StringFilter<"ExpenseSubcategory"> | string
    name?: StringFilter<"ExpenseSubcategory"> | string
    created_at?: DateTimeFilter<"ExpenseSubcategory"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseSubcategory"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    category?: XOR<ExpenseCategoryScalarRelationFilter, ExpenseCategoryWhereInput>
    entries?: ExpenseEntryListRelationFilter
    products?: ExpenseProductListRelationFilter
  }, "id" | "uuid">

  export type ExpenseSubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    category_uuid?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExpenseSubcategoryCountOrderByAggregateInput
    _avg?: ExpenseSubcategoryAvgOrderByAggregateInput
    _max?: ExpenseSubcategoryMaxOrderByAggregateInput
    _min?: ExpenseSubcategoryMinOrderByAggregateInput
    _sum?: ExpenseSubcategorySumOrderByAggregateInput
  }

  export type ExpenseSubcategoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseSubcategoryScalarWhereWithAggregatesInput | ExpenseSubcategoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseSubcategoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseSubcategoryScalarWhereWithAggregatesInput | ExpenseSubcategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseSubcategory"> | number
    uuid?: StringWithAggregatesFilter<"ExpenseSubcategory"> | string
    user_uuid?: StringNullableWithAggregatesFilter<"ExpenseSubcategory"> | string | null
    category_uuid?: StringWithAggregatesFilter<"ExpenseSubcategory"> | string
    name?: StringWithAggregatesFilter<"ExpenseSubcategory"> | string
    created_at?: DateTimeWithAggregatesFilter<"ExpenseSubcategory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ExpenseSubcategory"> | Date | string
  }

  export type ExpenseEntryWhereInput = {
    AND?: ExpenseEntryWhereInput | ExpenseEntryWhereInput[]
    OR?: ExpenseEntryWhereInput[]
    NOT?: ExpenseEntryWhereInput | ExpenseEntryWhereInput[]
    id?: IntFilter<"ExpenseEntry"> | number
    uuid?: StringFilter<"ExpenseEntry"> | string
    user_uuid?: StringFilter<"ExpenseEntry"> | string
    type?: EnumExpenseEntryTypeFilter<"ExpenseEntry"> | $Enums.ExpenseEntryType
    amount?: DecimalFilter<"ExpenseEntry"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"ExpenseEntry"> | string | null
    from_account_uuid?: StringFilter<"ExpenseEntry"> | string
    to_account_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    category_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    subcategory_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    entry_date?: DateTimeFilter<"ExpenseEntry"> | Date | string
    created_at?: DateTimeFilter<"ExpenseEntry"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    from_account?: XOR<ExpenseAccountScalarRelationFilter, ExpenseAccountWhereInput>
    to_account?: XOR<ExpenseAccountNullableScalarRelationFilter, ExpenseAccountWhereInput> | null
    category?: XOR<ExpenseCategoryNullableScalarRelationFilter, ExpenseCategoryWhereInput> | null
    subcategory?: XOR<ExpenseSubcategoryNullableScalarRelationFilter, ExpenseSubcategoryWhereInput> | null
    expense_receipt?: XOR<ExpenseReceiptNullableScalarRelationFilter, ExpenseReceiptWhereInput> | null
  }

  export type ExpenseEntryOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    from_account_uuid?: SortOrder
    to_account_uuid?: SortOrderInput | SortOrder
    category_uuid?: SortOrderInput | SortOrder
    subcategory_uuid?: SortOrderInput | SortOrder
    entry_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    from_account?: ExpenseAccountOrderByWithRelationInput
    to_account?: ExpenseAccountOrderByWithRelationInput
    category?: ExpenseCategoryOrderByWithRelationInput
    subcategory?: ExpenseSubcategoryOrderByWithRelationInput
    expense_receipt?: ExpenseReceiptOrderByWithRelationInput
  }

  export type ExpenseEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ExpenseEntryWhereInput | ExpenseEntryWhereInput[]
    OR?: ExpenseEntryWhereInput[]
    NOT?: ExpenseEntryWhereInput | ExpenseEntryWhereInput[]
    user_uuid?: StringFilter<"ExpenseEntry"> | string
    type?: EnumExpenseEntryTypeFilter<"ExpenseEntry"> | $Enums.ExpenseEntryType
    amount?: DecimalFilter<"ExpenseEntry"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"ExpenseEntry"> | string | null
    from_account_uuid?: StringFilter<"ExpenseEntry"> | string
    to_account_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    category_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    subcategory_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    entry_date?: DateTimeFilter<"ExpenseEntry"> | Date | string
    created_at?: DateTimeFilter<"ExpenseEntry"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    from_account?: XOR<ExpenseAccountScalarRelationFilter, ExpenseAccountWhereInput>
    to_account?: XOR<ExpenseAccountNullableScalarRelationFilter, ExpenseAccountWhereInput> | null
    category?: XOR<ExpenseCategoryNullableScalarRelationFilter, ExpenseCategoryWhereInput> | null
    subcategory?: XOR<ExpenseSubcategoryNullableScalarRelationFilter, ExpenseSubcategoryWhereInput> | null
    expense_receipt?: XOR<ExpenseReceiptNullableScalarRelationFilter, ExpenseReceiptWhereInput> | null
  }, "id" | "uuid">

  export type ExpenseEntryOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    from_account_uuid?: SortOrder
    to_account_uuid?: SortOrderInput | SortOrder
    category_uuid?: SortOrderInput | SortOrder
    subcategory_uuid?: SortOrderInput | SortOrder
    entry_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExpenseEntryCountOrderByAggregateInput
    _avg?: ExpenseEntryAvgOrderByAggregateInput
    _max?: ExpenseEntryMaxOrderByAggregateInput
    _min?: ExpenseEntryMinOrderByAggregateInput
    _sum?: ExpenseEntrySumOrderByAggregateInput
  }

  export type ExpenseEntryScalarWhereWithAggregatesInput = {
    AND?: ExpenseEntryScalarWhereWithAggregatesInput | ExpenseEntryScalarWhereWithAggregatesInput[]
    OR?: ExpenseEntryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseEntryScalarWhereWithAggregatesInput | ExpenseEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseEntry"> | number
    uuid?: StringWithAggregatesFilter<"ExpenseEntry"> | string
    user_uuid?: StringWithAggregatesFilter<"ExpenseEntry"> | string
    type?: EnumExpenseEntryTypeWithAggregatesFilter<"ExpenseEntry"> | $Enums.ExpenseEntryType
    amount?: DecimalWithAggregatesFilter<"ExpenseEntry"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"ExpenseEntry"> | string | null
    from_account_uuid?: StringWithAggregatesFilter<"ExpenseEntry"> | string
    to_account_uuid?: StringNullableWithAggregatesFilter<"ExpenseEntry"> | string | null
    category_uuid?: StringNullableWithAggregatesFilter<"ExpenseEntry"> | string | null
    subcategory_uuid?: StringNullableWithAggregatesFilter<"ExpenseEntry"> | string | null
    entry_date?: DateTimeWithAggregatesFilter<"ExpenseEntry"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"ExpenseEntry"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ExpenseEntry"> | Date | string
  }

  export type ExpenseStoreWhereInput = {
    AND?: ExpenseStoreWhereInput | ExpenseStoreWhereInput[]
    OR?: ExpenseStoreWhereInput[]
    NOT?: ExpenseStoreWhereInput | ExpenseStoreWhereInput[]
    id?: IntFilter<"ExpenseStore"> | number
    uuid?: StringFilter<"ExpenseStore"> | string
    user_uuid?: StringNullableFilter<"ExpenseStore"> | string | null
    name?: StringFilter<"ExpenseStore"> | string
    created_at?: DateTimeFilter<"ExpenseStore"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseStore"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    receipts?: ExpenseReceiptListRelationFilter
  }

  export type ExpenseStoreOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    receipts?: ExpenseReceiptOrderByRelationAggregateInput
  }

  export type ExpenseStoreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ExpenseStoreWhereInput | ExpenseStoreWhereInput[]
    OR?: ExpenseStoreWhereInput[]
    NOT?: ExpenseStoreWhereInput | ExpenseStoreWhereInput[]
    user_uuid?: StringNullableFilter<"ExpenseStore"> | string | null
    name?: StringFilter<"ExpenseStore"> | string
    created_at?: DateTimeFilter<"ExpenseStore"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseStore"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    receipts?: ExpenseReceiptListRelationFilter
  }, "id" | "uuid">

  export type ExpenseStoreOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExpenseStoreCountOrderByAggregateInput
    _avg?: ExpenseStoreAvgOrderByAggregateInput
    _max?: ExpenseStoreMaxOrderByAggregateInput
    _min?: ExpenseStoreMinOrderByAggregateInput
    _sum?: ExpenseStoreSumOrderByAggregateInput
  }

  export type ExpenseStoreScalarWhereWithAggregatesInput = {
    AND?: ExpenseStoreScalarWhereWithAggregatesInput | ExpenseStoreScalarWhereWithAggregatesInput[]
    OR?: ExpenseStoreScalarWhereWithAggregatesInput[]
    NOT?: ExpenseStoreScalarWhereWithAggregatesInput | ExpenseStoreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseStore"> | number
    uuid?: StringWithAggregatesFilter<"ExpenseStore"> | string
    user_uuid?: StringNullableWithAggregatesFilter<"ExpenseStore"> | string | null
    name?: StringWithAggregatesFilter<"ExpenseStore"> | string
    created_at?: DateTimeWithAggregatesFilter<"ExpenseStore"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ExpenseStore"> | Date | string
  }

  export type ExpenseReceiptWhereInput = {
    AND?: ExpenseReceiptWhereInput | ExpenseReceiptWhereInput[]
    OR?: ExpenseReceiptWhereInput[]
    NOT?: ExpenseReceiptWhereInput | ExpenseReceiptWhereInput[]
    id?: IntFilter<"ExpenseReceipt"> | number
    uuid?: StringFilter<"ExpenseReceipt"> | string
    user_uuid?: StringFilter<"ExpenseReceipt"> | string
    store_uuid?: StringNullableFilter<"ExpenseReceipt"> | string | null
    expense_entry_uuid?: StringFilter<"ExpenseReceipt"> | string
    receipt_date?: DateTimeFilter<"ExpenseReceipt"> | Date | string
    total_amount?: DecimalFilter<"ExpenseReceipt"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseReceipt"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseReceipt"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<ExpenseStoreNullableScalarRelationFilter, ExpenseStoreWhereInput> | null
    expense_entry?: XOR<ExpenseEntryScalarRelationFilter, ExpenseEntryWhereInput>
    items?: ExpenseReceiptItemListRelationFilter
  }

  export type ExpenseReceiptOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    store_uuid?: SortOrderInput | SortOrder
    expense_entry_uuid?: SortOrder
    receipt_date?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    store?: ExpenseStoreOrderByWithRelationInput
    expense_entry?: ExpenseEntryOrderByWithRelationInput
    items?: ExpenseReceiptItemOrderByRelationAggregateInput
  }

  export type ExpenseReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    expense_entry_uuid?: string
    AND?: ExpenseReceiptWhereInput | ExpenseReceiptWhereInput[]
    OR?: ExpenseReceiptWhereInput[]
    NOT?: ExpenseReceiptWhereInput | ExpenseReceiptWhereInput[]
    user_uuid?: StringFilter<"ExpenseReceipt"> | string
    store_uuid?: StringNullableFilter<"ExpenseReceipt"> | string | null
    receipt_date?: DateTimeFilter<"ExpenseReceipt"> | Date | string
    total_amount?: DecimalFilter<"ExpenseReceipt"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseReceipt"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseReceipt"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<ExpenseStoreNullableScalarRelationFilter, ExpenseStoreWhereInput> | null
    expense_entry?: XOR<ExpenseEntryScalarRelationFilter, ExpenseEntryWhereInput>
    items?: ExpenseReceiptItemListRelationFilter
  }, "id" | "uuid" | "expense_entry_uuid">

  export type ExpenseReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    store_uuid?: SortOrderInput | SortOrder
    expense_entry_uuid?: SortOrder
    receipt_date?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExpenseReceiptCountOrderByAggregateInput
    _avg?: ExpenseReceiptAvgOrderByAggregateInput
    _max?: ExpenseReceiptMaxOrderByAggregateInput
    _min?: ExpenseReceiptMinOrderByAggregateInput
    _sum?: ExpenseReceiptSumOrderByAggregateInput
  }

  export type ExpenseReceiptScalarWhereWithAggregatesInput = {
    AND?: ExpenseReceiptScalarWhereWithAggregatesInput | ExpenseReceiptScalarWhereWithAggregatesInput[]
    OR?: ExpenseReceiptScalarWhereWithAggregatesInput[]
    NOT?: ExpenseReceiptScalarWhereWithAggregatesInput | ExpenseReceiptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseReceipt"> | number
    uuid?: StringWithAggregatesFilter<"ExpenseReceipt"> | string
    user_uuid?: StringWithAggregatesFilter<"ExpenseReceipt"> | string
    store_uuid?: StringNullableWithAggregatesFilter<"ExpenseReceipt"> | string | null
    expense_entry_uuid?: StringWithAggregatesFilter<"ExpenseReceipt"> | string
    receipt_date?: DateTimeWithAggregatesFilter<"ExpenseReceipt"> | Date | string
    total_amount?: DecimalWithAggregatesFilter<"ExpenseReceipt"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"ExpenseReceipt"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ExpenseReceipt"> | Date | string
  }

  export type ExpenseProductWhereInput = {
    AND?: ExpenseProductWhereInput | ExpenseProductWhereInput[]
    OR?: ExpenseProductWhereInput[]
    NOT?: ExpenseProductWhereInput | ExpenseProductWhereInput[]
    id?: IntFilter<"ExpenseProduct"> | number
    uuid?: StringFilter<"ExpenseProduct"> | string
    user_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    name?: StringFilter<"ExpenseProduct"> | string
    brand?: StringNullableFilter<"ExpenseProduct"> | string | null
    unit?: StringNullableFilter<"ExpenseProduct"> | string | null
    size?: DecimalNullableFilter<"ExpenseProduct"> | Decimal | DecimalJsLike | number | string | null
    category_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    subcategory_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    created_at?: DateTimeFilter<"ExpenseProduct"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseProduct"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    category?: XOR<ExpenseCategoryNullableScalarRelationFilter, ExpenseCategoryWhereInput> | null
    subcategory?: XOR<ExpenseSubcategoryNullableScalarRelationFilter, ExpenseSubcategoryWhereInput> | null
    receipt_items?: ExpenseReceiptItemListRelationFilter
  }

  export type ExpenseProductOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    category_uuid?: SortOrderInput | SortOrder
    subcategory_uuid?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    category?: ExpenseCategoryOrderByWithRelationInput
    subcategory?: ExpenseSubcategoryOrderByWithRelationInput
    receipt_items?: ExpenseReceiptItemOrderByRelationAggregateInput
  }

  export type ExpenseProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ExpenseProductWhereInput | ExpenseProductWhereInput[]
    OR?: ExpenseProductWhereInput[]
    NOT?: ExpenseProductWhereInput | ExpenseProductWhereInput[]
    user_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    name?: StringFilter<"ExpenseProduct"> | string
    brand?: StringNullableFilter<"ExpenseProduct"> | string | null
    unit?: StringNullableFilter<"ExpenseProduct"> | string | null
    size?: DecimalNullableFilter<"ExpenseProduct"> | Decimal | DecimalJsLike | number | string | null
    category_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    subcategory_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    created_at?: DateTimeFilter<"ExpenseProduct"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseProduct"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    category?: XOR<ExpenseCategoryNullableScalarRelationFilter, ExpenseCategoryWhereInput> | null
    subcategory?: XOR<ExpenseSubcategoryNullableScalarRelationFilter, ExpenseSubcategoryWhereInput> | null
    receipt_items?: ExpenseReceiptItemListRelationFilter
  }, "id" | "uuid">

  export type ExpenseProductOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    category_uuid?: SortOrderInput | SortOrder
    subcategory_uuid?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExpenseProductCountOrderByAggregateInput
    _avg?: ExpenseProductAvgOrderByAggregateInput
    _max?: ExpenseProductMaxOrderByAggregateInput
    _min?: ExpenseProductMinOrderByAggregateInput
    _sum?: ExpenseProductSumOrderByAggregateInput
  }

  export type ExpenseProductScalarWhereWithAggregatesInput = {
    AND?: ExpenseProductScalarWhereWithAggregatesInput | ExpenseProductScalarWhereWithAggregatesInput[]
    OR?: ExpenseProductScalarWhereWithAggregatesInput[]
    NOT?: ExpenseProductScalarWhereWithAggregatesInput | ExpenseProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseProduct"> | number
    uuid?: StringWithAggregatesFilter<"ExpenseProduct"> | string
    user_uuid?: StringNullableWithAggregatesFilter<"ExpenseProduct"> | string | null
    name?: StringWithAggregatesFilter<"ExpenseProduct"> | string
    brand?: StringNullableWithAggregatesFilter<"ExpenseProduct"> | string | null
    unit?: StringNullableWithAggregatesFilter<"ExpenseProduct"> | string | null
    size?: DecimalNullableWithAggregatesFilter<"ExpenseProduct"> | Decimal | DecimalJsLike | number | string | null
    category_uuid?: StringNullableWithAggregatesFilter<"ExpenseProduct"> | string | null
    subcategory_uuid?: StringNullableWithAggregatesFilter<"ExpenseProduct"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ExpenseProduct"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ExpenseProduct"> | Date | string
  }

  export type ExpenseReceiptItemWhereInput = {
    AND?: ExpenseReceiptItemWhereInput | ExpenseReceiptItemWhereInput[]
    OR?: ExpenseReceiptItemWhereInput[]
    NOT?: ExpenseReceiptItemWhereInput | ExpenseReceiptItemWhereInput[]
    id?: IntFilter<"ExpenseReceiptItem"> | number
    uuid?: StringFilter<"ExpenseReceiptItem"> | string
    receipt_uuid?: StringFilter<"ExpenseReceiptItem"> | string
    product_uuid?: StringNullableFilter<"ExpenseReceiptItem"> | string | null
    quantity?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseReceiptItem"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseReceiptItem"> | Date | string
    receipt?: XOR<ExpenseReceiptScalarRelationFilter, ExpenseReceiptWhereInput>
    product?: XOR<ExpenseProductNullableScalarRelationFilter, ExpenseProductWhereInput> | null
  }

  export type ExpenseReceiptItemOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    receipt_uuid?: SortOrder
    product_uuid?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    receipt?: ExpenseReceiptOrderByWithRelationInput
    product?: ExpenseProductOrderByWithRelationInput
  }

  export type ExpenseReceiptItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ExpenseReceiptItemWhereInput | ExpenseReceiptItemWhereInput[]
    OR?: ExpenseReceiptItemWhereInput[]
    NOT?: ExpenseReceiptItemWhereInput | ExpenseReceiptItemWhereInput[]
    receipt_uuid?: StringFilter<"ExpenseReceiptItem"> | string
    product_uuid?: StringNullableFilter<"ExpenseReceiptItem"> | string | null
    quantity?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseReceiptItem"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseReceiptItem"> | Date | string
    receipt?: XOR<ExpenseReceiptScalarRelationFilter, ExpenseReceiptWhereInput>
    product?: XOR<ExpenseProductNullableScalarRelationFilter, ExpenseProductWhereInput> | null
  }, "id" | "uuid">

  export type ExpenseReceiptItemOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    receipt_uuid?: SortOrder
    product_uuid?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExpenseReceiptItemCountOrderByAggregateInput
    _avg?: ExpenseReceiptItemAvgOrderByAggregateInput
    _max?: ExpenseReceiptItemMaxOrderByAggregateInput
    _min?: ExpenseReceiptItemMinOrderByAggregateInput
    _sum?: ExpenseReceiptItemSumOrderByAggregateInput
  }

  export type ExpenseReceiptItemScalarWhereWithAggregatesInput = {
    AND?: ExpenseReceiptItemScalarWhereWithAggregatesInput | ExpenseReceiptItemScalarWhereWithAggregatesInput[]
    OR?: ExpenseReceiptItemScalarWhereWithAggregatesInput[]
    NOT?: ExpenseReceiptItemScalarWhereWithAggregatesInput | ExpenseReceiptItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseReceiptItem"> | number
    uuid?: StringWithAggregatesFilter<"ExpenseReceiptItem"> | string
    receipt_uuid?: StringWithAggregatesFilter<"ExpenseReceiptItem"> | string
    product_uuid?: StringNullableWithAggregatesFilter<"ExpenseReceiptItem"> | string | null
    quantity?: DecimalWithAggregatesFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalWithAggregatesFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalWithAggregatesFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"ExpenseReceiptItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ExpenseReceiptItem"> | Date | string
  }

  export type MuscleGroupWhereInput = {
    AND?: MuscleGroupWhereInput | MuscleGroupWhereInput[]
    OR?: MuscleGroupWhereInput[]
    NOT?: MuscleGroupWhereInput | MuscleGroupWhereInput[]
    id?: IntFilter<"MuscleGroup"> | number
    uuid?: StringFilter<"MuscleGroup"> | string
    user_uuid?: StringNullableFilter<"MuscleGroup"> | string | null
    name?: StringFilter<"MuscleGroup"> | string
    color?: StringNullableFilter<"MuscleGroup"> | string | null
    created_at?: DateTimeFilter<"MuscleGroup"> | Date | string
    updated_at?: DateTimeFilter<"MuscleGroup"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    exercises?: ExerciseListRelationFilter
  }

  export type MuscleGroupOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    exercises?: ExerciseOrderByRelationAggregateInput
  }

  export type MuscleGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: MuscleGroupWhereInput | MuscleGroupWhereInput[]
    OR?: MuscleGroupWhereInput[]
    NOT?: MuscleGroupWhereInput | MuscleGroupWhereInput[]
    user_uuid?: StringNullableFilter<"MuscleGroup"> | string | null
    name?: StringFilter<"MuscleGroup"> | string
    color?: StringNullableFilter<"MuscleGroup"> | string | null
    created_at?: DateTimeFilter<"MuscleGroup"> | Date | string
    updated_at?: DateTimeFilter<"MuscleGroup"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    exercises?: ExerciseListRelationFilter
  }, "id" | "uuid">

  export type MuscleGroupOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MuscleGroupCountOrderByAggregateInput
    _avg?: MuscleGroupAvgOrderByAggregateInput
    _max?: MuscleGroupMaxOrderByAggregateInput
    _min?: MuscleGroupMinOrderByAggregateInput
    _sum?: MuscleGroupSumOrderByAggregateInput
  }

  export type MuscleGroupScalarWhereWithAggregatesInput = {
    AND?: MuscleGroupScalarWhereWithAggregatesInput | MuscleGroupScalarWhereWithAggregatesInput[]
    OR?: MuscleGroupScalarWhereWithAggregatesInput[]
    NOT?: MuscleGroupScalarWhereWithAggregatesInput | MuscleGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MuscleGroup"> | number
    uuid?: StringWithAggregatesFilter<"MuscleGroup"> | string
    user_uuid?: StringNullableWithAggregatesFilter<"MuscleGroup"> | string | null
    name?: StringWithAggregatesFilter<"MuscleGroup"> | string
    color?: StringNullableWithAggregatesFilter<"MuscleGroup"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"MuscleGroup"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MuscleGroup"> | Date | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: IntFilter<"Exercise"> | number
    uuid?: StringFilter<"Exercise"> | string
    user_uuid?: StringNullableFilter<"Exercise"> | string | null
    muscle_group_uuid?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    type?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    created_at?: DateTimeFilter<"Exercise"> | Date | string
    updated_at?: DateTimeFilter<"Exercise"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    muscle_group?: XOR<MuscleGroupScalarRelationFilter, MuscleGroupWhereInput>
    entries?: WorkoutEntryListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    muscle_group_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    muscle_group?: MuscleGroupOrderByWithRelationInput
    entries?: WorkoutEntryOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    user_uuid?: StringNullableFilter<"Exercise"> | string | null
    muscle_group_uuid?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    type?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    created_at?: DateTimeFilter<"Exercise"> | Date | string
    updated_at?: DateTimeFilter<"Exercise"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    muscle_group?: XOR<MuscleGroupScalarRelationFilter, MuscleGroupWhereInput>
    entries?: WorkoutEntryListRelationFilter
  }, "id" | "uuid">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    muscle_group_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exercise"> | number
    uuid?: StringWithAggregatesFilter<"Exercise"> | string
    user_uuid?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    muscle_group_uuid?: StringWithAggregatesFilter<"Exercise"> | string
    name?: StringWithAggregatesFilter<"Exercise"> | string
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    type?: EnumExerciseTypeWithAggregatesFilter<"Exercise"> | $Enums.ExerciseType
    created_at?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
  }

  export type WorkoutWhereInput = {
    AND?: WorkoutWhereInput | WorkoutWhereInput[]
    OR?: WorkoutWhereInput[]
    NOT?: WorkoutWhereInput | WorkoutWhereInput[]
    id?: IntFilter<"Workout"> | number
    uuid?: StringFilter<"Workout"> | string
    user_uuid?: StringNullableFilter<"Workout"> | string | null
    name?: StringNullableFilter<"Workout"> | string | null
    notes?: StringNullableFilter<"Workout"> | string | null
    started_at?: DateTimeFilter<"Workout"> | Date | string
    finished_at?: DateTimeFilter<"Workout"> | Date | string
    created_at?: DateTimeFilter<"Workout"> | Date | string
    updated_at?: DateTimeFilter<"Workout"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    entries?: WorkoutEntryListRelationFilter
  }

  export type WorkoutOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    entries?: WorkoutEntryOrderByRelationAggregateInput
  }

  export type WorkoutWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: WorkoutWhereInput | WorkoutWhereInput[]
    OR?: WorkoutWhereInput[]
    NOT?: WorkoutWhereInput | WorkoutWhereInput[]
    user_uuid?: StringNullableFilter<"Workout"> | string | null
    name?: StringNullableFilter<"Workout"> | string | null
    notes?: StringNullableFilter<"Workout"> | string | null
    started_at?: DateTimeFilter<"Workout"> | Date | string
    finished_at?: DateTimeFilter<"Workout"> | Date | string
    created_at?: DateTimeFilter<"Workout"> | Date | string
    updated_at?: DateTimeFilter<"Workout"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    entries?: WorkoutEntryListRelationFilter
  }, "id" | "uuid">

  export type WorkoutOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WorkoutCountOrderByAggregateInput
    _avg?: WorkoutAvgOrderByAggregateInput
    _max?: WorkoutMaxOrderByAggregateInput
    _min?: WorkoutMinOrderByAggregateInput
    _sum?: WorkoutSumOrderByAggregateInput
  }

  export type WorkoutScalarWhereWithAggregatesInput = {
    AND?: WorkoutScalarWhereWithAggregatesInput | WorkoutScalarWhereWithAggregatesInput[]
    OR?: WorkoutScalarWhereWithAggregatesInput[]
    NOT?: WorkoutScalarWhereWithAggregatesInput | WorkoutScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Workout"> | number
    uuid?: StringWithAggregatesFilter<"Workout"> | string
    user_uuid?: StringNullableWithAggregatesFilter<"Workout"> | string | null
    name?: StringNullableWithAggregatesFilter<"Workout"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Workout"> | string | null
    started_at?: DateTimeWithAggregatesFilter<"Workout"> | Date | string
    finished_at?: DateTimeWithAggregatesFilter<"Workout"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"Workout"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Workout"> | Date | string
  }

  export type WorkoutEntryWhereInput = {
    AND?: WorkoutEntryWhereInput | WorkoutEntryWhereInput[]
    OR?: WorkoutEntryWhereInput[]
    NOT?: WorkoutEntryWhereInput | WorkoutEntryWhereInput[]
    id?: IntFilter<"WorkoutEntry"> | number
    uuid?: StringFilter<"WorkoutEntry"> | string
    workout_uuid?: StringFilter<"WorkoutEntry"> | string
    exercise_uuid?: StringFilter<"WorkoutEntry"> | string
    order?: IntFilter<"WorkoutEntry"> | number
    created_at?: DateTimeFilter<"WorkoutEntry"> | Date | string
    updated_at?: DateTimeFilter<"WorkoutEntry"> | Date | string
    workout?: XOR<WorkoutScalarRelationFilter, WorkoutWhereInput>
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
    sets?: WorkoutSetListRelationFilter
  }

  export type WorkoutEntryOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_uuid?: SortOrder
    exercise_uuid?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    workout?: WorkoutOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
    sets?: WorkoutSetOrderByRelationAggregateInput
  }

  export type WorkoutEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: WorkoutEntryWhereInput | WorkoutEntryWhereInput[]
    OR?: WorkoutEntryWhereInput[]
    NOT?: WorkoutEntryWhereInput | WorkoutEntryWhereInput[]
    workout_uuid?: StringFilter<"WorkoutEntry"> | string
    exercise_uuid?: StringFilter<"WorkoutEntry"> | string
    order?: IntFilter<"WorkoutEntry"> | number
    created_at?: DateTimeFilter<"WorkoutEntry"> | Date | string
    updated_at?: DateTimeFilter<"WorkoutEntry"> | Date | string
    workout?: XOR<WorkoutScalarRelationFilter, WorkoutWhereInput>
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
    sets?: WorkoutSetListRelationFilter
  }, "id" | "uuid">

  export type WorkoutEntryOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_uuid?: SortOrder
    exercise_uuid?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WorkoutEntryCountOrderByAggregateInput
    _avg?: WorkoutEntryAvgOrderByAggregateInput
    _max?: WorkoutEntryMaxOrderByAggregateInput
    _min?: WorkoutEntryMinOrderByAggregateInput
    _sum?: WorkoutEntrySumOrderByAggregateInput
  }

  export type WorkoutEntryScalarWhereWithAggregatesInput = {
    AND?: WorkoutEntryScalarWhereWithAggregatesInput | WorkoutEntryScalarWhereWithAggregatesInput[]
    OR?: WorkoutEntryScalarWhereWithAggregatesInput[]
    NOT?: WorkoutEntryScalarWhereWithAggregatesInput | WorkoutEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkoutEntry"> | number
    uuid?: StringWithAggregatesFilter<"WorkoutEntry"> | string
    workout_uuid?: StringWithAggregatesFilter<"WorkoutEntry"> | string
    exercise_uuid?: StringWithAggregatesFilter<"WorkoutEntry"> | string
    order?: IntWithAggregatesFilter<"WorkoutEntry"> | number
    created_at?: DateTimeWithAggregatesFilter<"WorkoutEntry"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"WorkoutEntry"> | Date | string
  }

  export type WorkoutSetWhereInput = {
    AND?: WorkoutSetWhereInput | WorkoutSetWhereInput[]
    OR?: WorkoutSetWhereInput[]
    NOT?: WorkoutSetWhereInput | WorkoutSetWhereInput[]
    id?: IntFilter<"WorkoutSet"> | number
    uuid?: StringFilter<"WorkoutSet"> | string
    workout_entry_uuid?: StringFilter<"WorkoutSet"> | string
    type?: EnumExerciseTypeFilter<"WorkoutSet"> | $Enums.ExerciseType
    reps?: IntNullableFilter<"WorkoutSet"> | number | null
    weight?: DecimalNullableFilter<"WorkoutSet"> | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: IntNullableFilter<"WorkoutSet"> | number | null
    distance_meters?: IntNullableFilter<"WorkoutSet"> | number | null
    rest_seconds?: IntNullableFilter<"WorkoutSet"> | number | null
    notes?: StringNullableFilter<"WorkoutSet"> | string | null
    is_dropset?: BoolFilter<"WorkoutSet"> | boolean
    is_amrap?: BoolFilter<"WorkoutSet"> | boolean
    is_rest?: BoolFilter<"WorkoutSet"> | boolean
    is_warmup?: BoolFilter<"WorkoutSet"> | boolean
    is_cooldown?: BoolFilter<"WorkoutSet"> | boolean
    is_super_set?: BoolFilter<"WorkoutSet"> | boolean
    order?: IntFilter<"WorkoutSet"> | number
    created_at?: DateTimeFilter<"WorkoutSet"> | Date | string
    updated_at?: DateTimeFilter<"WorkoutSet"> | Date | string
    workout_entry?: XOR<WorkoutEntryScalarRelationFilter, WorkoutEntryWhereInput>
  }

  export type WorkoutSetOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_entry_uuid?: SortOrder
    type?: SortOrder
    reps?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    duration_seconds?: SortOrderInput | SortOrder
    distance_meters?: SortOrderInput | SortOrder
    rest_seconds?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_dropset?: SortOrder
    is_amrap?: SortOrder
    is_rest?: SortOrder
    is_warmup?: SortOrder
    is_cooldown?: SortOrder
    is_super_set?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    workout_entry?: WorkoutEntryOrderByWithRelationInput
  }

  export type WorkoutSetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: WorkoutSetWhereInput | WorkoutSetWhereInput[]
    OR?: WorkoutSetWhereInput[]
    NOT?: WorkoutSetWhereInput | WorkoutSetWhereInput[]
    workout_entry_uuid?: StringFilter<"WorkoutSet"> | string
    type?: EnumExerciseTypeFilter<"WorkoutSet"> | $Enums.ExerciseType
    reps?: IntNullableFilter<"WorkoutSet"> | number | null
    weight?: DecimalNullableFilter<"WorkoutSet"> | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: IntNullableFilter<"WorkoutSet"> | number | null
    distance_meters?: IntNullableFilter<"WorkoutSet"> | number | null
    rest_seconds?: IntNullableFilter<"WorkoutSet"> | number | null
    notes?: StringNullableFilter<"WorkoutSet"> | string | null
    is_dropset?: BoolFilter<"WorkoutSet"> | boolean
    is_amrap?: BoolFilter<"WorkoutSet"> | boolean
    is_rest?: BoolFilter<"WorkoutSet"> | boolean
    is_warmup?: BoolFilter<"WorkoutSet"> | boolean
    is_cooldown?: BoolFilter<"WorkoutSet"> | boolean
    is_super_set?: BoolFilter<"WorkoutSet"> | boolean
    order?: IntFilter<"WorkoutSet"> | number
    created_at?: DateTimeFilter<"WorkoutSet"> | Date | string
    updated_at?: DateTimeFilter<"WorkoutSet"> | Date | string
    workout_entry?: XOR<WorkoutEntryScalarRelationFilter, WorkoutEntryWhereInput>
  }, "id" | "uuid">

  export type WorkoutSetOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_entry_uuid?: SortOrder
    type?: SortOrder
    reps?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    duration_seconds?: SortOrderInput | SortOrder
    distance_meters?: SortOrderInput | SortOrder
    rest_seconds?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_dropset?: SortOrder
    is_amrap?: SortOrder
    is_rest?: SortOrder
    is_warmup?: SortOrder
    is_cooldown?: SortOrder
    is_super_set?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WorkoutSetCountOrderByAggregateInput
    _avg?: WorkoutSetAvgOrderByAggregateInput
    _max?: WorkoutSetMaxOrderByAggregateInput
    _min?: WorkoutSetMinOrderByAggregateInput
    _sum?: WorkoutSetSumOrderByAggregateInput
  }

  export type WorkoutSetScalarWhereWithAggregatesInput = {
    AND?: WorkoutSetScalarWhereWithAggregatesInput | WorkoutSetScalarWhereWithAggregatesInput[]
    OR?: WorkoutSetScalarWhereWithAggregatesInput[]
    NOT?: WorkoutSetScalarWhereWithAggregatesInput | WorkoutSetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkoutSet"> | number
    uuid?: StringWithAggregatesFilter<"WorkoutSet"> | string
    workout_entry_uuid?: StringWithAggregatesFilter<"WorkoutSet"> | string
    type?: EnumExerciseTypeWithAggregatesFilter<"WorkoutSet"> | $Enums.ExerciseType
    reps?: IntNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    weight?: DecimalNullableWithAggregatesFilter<"WorkoutSet"> | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: IntNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    distance_meters?: IntNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    rest_seconds?: IntNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    notes?: StringNullableWithAggregatesFilter<"WorkoutSet"> | string | null
    is_dropset?: BoolWithAggregatesFilter<"WorkoutSet"> | boolean
    is_amrap?: BoolWithAggregatesFilter<"WorkoutSet"> | boolean
    is_rest?: BoolWithAggregatesFilter<"WorkoutSet"> | boolean
    is_warmup?: BoolWithAggregatesFilter<"WorkoutSet"> | boolean
    is_cooldown?: BoolWithAggregatesFilter<"WorkoutSet"> | boolean
    is_super_set?: BoolWithAggregatesFilter<"WorkoutSet"> | boolean
    order?: IntWithAggregatesFilter<"WorkoutSet"> | number
    created_at?: DateTimeWithAggregatesFilter<"WorkoutSet"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"WorkoutSet"> | Date | string
  }

  export type UserCreateInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    uuid?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutActivityInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutActivityInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutActivityNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutActivityNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleSlotCreateInput = {
    uuid?: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutSchedule_slotsInput
    activity: ActivityCreateNestedOneWithoutSchedule_slotsInput
  }

  export type ScheduleSlotUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleSlotUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchedule_slotsNestedInput
    activity?: ActivityUpdateOneRequiredWithoutSchedule_slotsNestedInput
  }

  export type ScheduleSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleSlotCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleSlotUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleCreateInput = {
    uuid?: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_schedulesInput
    user: UserCreateNestedOneWithoutActivity_schedulesInput
    weekdays?: ActivityScheduleWeekdayCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateUncheckedCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_schedulesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_schedulesNestedInput
    weekdays?: ActivityScheduleWeekdayUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUncheckedUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityScheduleUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleWeekdayCreateInput = {
    weekday: number
    schedule: ActivityScheduleCreateNestedOneWithoutWeekdaysInput
  }

  export type ActivityScheduleWeekdayUncheckedCreateInput = {
    id?: number
    schedule_uuid: string
    weekday: number
  }

  export type ActivityScheduleWeekdayUpdateInput = {
    weekday?: IntFieldUpdateOperationsInput | number
    schedule?: ActivityScheduleUpdateOneRequiredWithoutWeekdaysNestedInput
  }

  export type ActivityScheduleWeekdayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityScheduleWeekdayCreateManyInput = {
    id?: number
    schedule_uuid: string
    weekday: number
  }

  export type ActivityScheduleWeekdayUpdateManyMutationInput = {
    weekday?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityScheduleWeekdayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityScheduleDateCreateInput = {
    date: Date | string
    schedule: ActivityScheduleCreateNestedOneWithoutSpecific_datesInput
  }

  export type ActivityScheduleDateUncheckedCreateInput = {
    id?: number
    schedule_uuid: string
    date: Date | string
  }

  export type ActivityScheduleDateUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ActivityScheduleUpdateOneRequiredWithoutSpecific_datesNestedInput
  }

  export type ActivityScheduleDateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleDateCreateManyInput = {
    id?: number
    schedule_uuid: string
    date: Date | string
  }

  export type ActivityScheduleDateUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleDateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityOccurrenceCreateInput = {
    uuid?: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_occurrencesInput
    schedule: ActivityScheduleCreateNestedOneWithoutOccurrencesInput
    user: UserCreateNestedOneWithoutActivity_occurrencesInput
    log?: ActivityLogCreateNestedOneWithoutOccurrenceInput
  }

  export type ActivityOccurrenceUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    schedule_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    log?: ActivityLogUncheckedCreateNestedOneWithoutOccurrenceInput
  }

  export type ActivityOccurrenceUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_occurrencesNestedInput
    schedule?: ActivityScheduleUpdateOneRequiredWithoutOccurrencesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_occurrencesNestedInput
    log?: ActivityLogUpdateOneWithoutOccurrenceNestedInput
  }

  export type ActivityOccurrenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    log?: ActivityLogUncheckedUpdateOneWithoutOccurrenceNestedInput
  }

  export type ActivityOccurrenceCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    schedule_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityOccurrenceUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityOccurrenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    uuid?: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_logsInput
    schedule: ActivityScheduleCreateNestedOneWithoutLogsInput
    occurrence: ActivityOccurrenceCreateNestedOneWithoutLogInput
    user: UserCreateNestedOneWithoutActivity_logsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    schedule_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_logsNestedInput
    schedule?: ActivityScheduleUpdateOneRequiredWithoutLogsNestedInput
    occurrence?: ActivityOccurrenceUpdateOneRequiredWithoutLogNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_logsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    occurrence_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    schedule_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    occurrence_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseAccountCreateInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_accountsInput
    entries_from?: ExpenseEntryCreateNestedManyWithoutFrom_accountInput
    entries_to?: ExpenseEntryCreateNestedManyWithoutTo_accountInput
  }

  export type ExpenseAccountUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    entries_from?: ExpenseEntryUncheckedCreateNestedManyWithoutFrom_accountInput
    entries_to?: ExpenseEntryUncheckedCreateNestedManyWithoutTo_accountInput
  }

  export type ExpenseAccountUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_accountsNestedInput
    entries_from?: ExpenseEntryUpdateManyWithoutFrom_accountNestedInput
    entries_to?: ExpenseEntryUpdateManyWithoutTo_accountNestedInput
  }

  export type ExpenseAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries_from?: ExpenseEntryUncheckedUpdateManyWithoutFrom_accountNestedInput
    entries_to?: ExpenseEntryUncheckedUpdateManyWithoutTo_accountNestedInput
  }

  export type ExpenseAccountCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseAccountUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryCreateInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutCategoriesInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutCategoryInput
    entries?: ExpenseEntryCreateNestedManyWithoutCategoryInput
    products?: ExpenseProductCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    entries?: ExpenseEntryUncheckedCreateNestedManyWithoutCategoryInput
    products?: ExpenseProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCategoriesNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutCategoryNestedInput
    entries?: ExpenseEntryUpdateManyWithoutCategoryNestedInput
    products?: ExpenseProductUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    entries?: ExpenseEntryUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ExpenseProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseCategoryUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseSubcategoryCreateInput = {
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutSubcategoriesInput
    category: ExpenseCategoryCreateNestedOneWithoutSubcategoriesInput
    entries?: ExpenseEntryCreateNestedManyWithoutSubcategoryInput
    products?: ExpenseProductCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    category_uuid: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entries?: ExpenseEntryUncheckedCreateNestedManyWithoutSubcategoryInput
    products?: ExpenseProductUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSubcategoriesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    entries?: ExpenseEntryUpdateManyWithoutSubcategoryNestedInput
    products?: ExpenseProductUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseSubcategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ExpenseEntryUncheckedUpdateManyWithoutSubcategoryNestedInput
    products?: ExpenseProductUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseSubcategoryCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    category_uuid: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseSubcategoryUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseSubcategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseEntryCreateInput = {
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_entriesInput
    from_account: ExpenseAccountCreateNestedOneWithoutEntries_fromInput
    to_account?: ExpenseAccountCreateNestedOneWithoutEntries_toInput
    category?: ExpenseCategoryCreateNestedOneWithoutEntriesInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutEntriesInput
    expense_receipt?: ExpenseReceiptCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    expense_receipt?: ExpenseReceiptUncheckedCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_entriesNestedInput
    from_account?: ExpenseAccountUpdateOneRequiredWithoutEntries_fromNestedInput
    to_account?: ExpenseAccountUpdateOneWithoutEntries_toNestedInput
    category?: ExpenseCategoryUpdateOneWithoutEntriesNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutEntriesNestedInput
    expense_receipt?: ExpenseReceiptUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expense_receipt?: ExpenseReceiptUncheckedUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseEntryUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseStoreCreateInput = {
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExpense_storesInput
    receipts?: ExpenseReceiptCreateNestedManyWithoutStoreInput
  }

  export type ExpenseStoreUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutStoreInput
  }

  export type ExpenseStoreUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExpense_storesNestedInput
    receipts?: ExpenseReceiptUpdateManyWithoutStoreNestedInput
  }

  export type ExpenseStoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipts?: ExpenseReceiptUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ExpenseStoreCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseStoreUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseStoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptCreateInput = {
    uuid?: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_receiptsInput
    store?: ExpenseStoreCreateNestedOneWithoutReceiptsInput
    expense_entry: ExpenseEntryCreateNestedOneWithoutExpense_receiptInput
    items?: ExpenseReceiptItemCreateNestedManyWithoutReceiptInput
  }

  export type ExpenseReceiptUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid: string
    store_uuid?: string | null
    expense_entry_uuid: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    items?: ExpenseReceiptItemUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type ExpenseReceiptUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_receiptsNestedInput
    store?: ExpenseStoreUpdateOneWithoutReceiptsNestedInput
    expense_entry?: ExpenseEntryUpdateOneRequiredWithoutExpense_receiptNestedInput
    items?: ExpenseReceiptItemUpdateManyWithoutReceiptNestedInput
  }

  export type ExpenseReceiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    store_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    expense_entry_uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ExpenseReceiptItemUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ExpenseReceiptCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid: string
    store_uuid?: string | null
    expense_entry_uuid: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    store_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    expense_entry_uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseProductCreateInput = {
    uuid?: string
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExpense_productsInput
    category?: ExpenseCategoryCreateNestedOneWithoutProductsInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutProductsInput
    receipt_items?: ExpenseReceiptItemCreateNestedManyWithoutProductInput
  }

  export type ExpenseProductUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    receipt_items?: ExpenseReceiptItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ExpenseProductUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExpense_productsNestedInput
    category?: ExpenseCategoryUpdateOneWithoutProductsNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutProductsNestedInput
    receipt_items?: ExpenseReceiptItemUpdateManyWithoutProductNestedInput
  }

  export type ExpenseProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_items?: ExpenseReceiptItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ExpenseProductCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseProductUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptItemCreateInput = {
    uuid?: string
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    receipt: ExpenseReceiptCreateNestedOneWithoutItemsInput
    product?: ExpenseProductCreateNestedOneWithoutReceipt_itemsInput
  }

  export type ExpenseReceiptItemUncheckedCreateInput = {
    id?: number
    uuid?: string
    receipt_uuid: string
    product_uuid?: string | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptItemUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt?: ExpenseReceiptUpdateOneRequiredWithoutItemsNestedInput
    product?: ExpenseProductUpdateOneWithoutReceipt_itemsNestedInput
  }

  export type ExpenseReceiptItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_uuid?: StringFieldUpdateOperationsInput | string
    product_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptItemCreateManyInput = {
    id?: number
    uuid?: string
    receipt_uuid: string
    product_uuid?: string | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptItemUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_uuid?: StringFieldUpdateOperationsInput | string
    product_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuscleGroupCreateInput = {
    uuid?: string
    name: string
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutMuscle_groupsInput
    exercises?: ExerciseCreateNestedManyWithoutMuscle_groupInput
  }

  export type MuscleGroupUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutMuscle_groupInput
  }

  export type MuscleGroupUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMuscle_groupsNestedInput
    exercises?: ExerciseUpdateManyWithoutMuscle_groupNestedInput
  }

  export type MuscleGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUncheckedUpdateManyWithoutMuscle_groupNestedInput
  }

  export type MuscleGroupCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MuscleGroupUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuscleGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateInput = {
    uuid?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExercisesInput
    muscle_group: MuscleGroupCreateNestedOneWithoutExercisesInput
    entries?: WorkoutEntryCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    muscle_group_uuid: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
    entries?: WorkoutEntryUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExercisesNestedInput
    muscle_group?: MuscleGroupUpdateOneRequiredWithoutExercisesNestedInput
    entries?: WorkoutEntryUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    muscle_group_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: WorkoutEntryUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    muscle_group_uuid: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExerciseUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    muscle_group_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutCreateInput = {
    uuid?: string
    name?: string | null
    notes?: string | null
    started_at?: Date | string
    finished_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutWorkoutsInput
    entries?: WorkoutEntryCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name?: string | null
    notes?: string | null
    started_at?: Date | string
    finished_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    entries?: WorkoutEntryUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWorkoutsNestedInput
    entries?: WorkoutEntryUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: WorkoutEntryUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutCreateManyInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name?: string | null
    notes?: string | null
    started_at?: Date | string
    finished_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutEntryCreateInput = {
    uuid?: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
    workout: WorkoutCreateNestedOneWithoutEntriesInput
    exercise: ExerciseCreateNestedOneWithoutEntriesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkout_entryInput
  }

  export type WorkoutEntryUncheckedCreateInput = {
    id?: number
    uuid?: string
    workout_uuid: string
    exercise_uuid: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkout_entryInput
  }

  export type WorkoutEntryUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: WorkoutUpdateOneRequiredWithoutEntriesNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutEntriesNestedInput
    sets?: WorkoutSetUpdateManyWithoutWorkout_entryNestedInput
  }

  export type WorkoutEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    workout_uuid?: StringFieldUpdateOperationsInput | string
    exercise_uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkout_entryNestedInput
  }

  export type WorkoutEntryCreateManyInput = {
    id?: number
    uuid?: string
    workout_uuid: string
    exercise_uuid: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutEntryUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    workout_uuid?: StringFieldUpdateOperationsInput | string
    exercise_uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetCreateInput = {
    uuid?: string
    type: $Enums.ExerciseType
    reps?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    duration_seconds?: number | null
    distance_meters?: number | null
    rest_seconds?: number | null
    notes?: string | null
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
    workout_entry: WorkoutEntryCreateNestedOneWithoutSetsInput
  }

  export type WorkoutSetUncheckedCreateInput = {
    id?: number
    uuid?: string
    workout_entry_uuid: string
    type: $Enums.ExerciseType
    reps?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    duration_seconds?: number | null
    distance_meters?: number | null
    rest_seconds?: number | null
    notes?: string | null
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutSetUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    distance_meters?: NullableIntFieldUpdateOperationsInput | number | null
    rest_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_dropset?: BoolFieldUpdateOperationsInput | boolean
    is_amrap?: BoolFieldUpdateOperationsInput | boolean
    is_rest?: BoolFieldUpdateOperationsInput | boolean
    is_warmup?: BoolFieldUpdateOperationsInput | boolean
    is_cooldown?: BoolFieldUpdateOperationsInput | boolean
    is_super_set?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    workout_entry?: WorkoutEntryUpdateOneRequiredWithoutSetsNestedInput
  }

  export type WorkoutSetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    workout_entry_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    distance_meters?: NullableIntFieldUpdateOperationsInput | number | null
    rest_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_dropset?: BoolFieldUpdateOperationsInput | boolean
    is_amrap?: BoolFieldUpdateOperationsInput | boolean
    is_rest?: BoolFieldUpdateOperationsInput | boolean
    is_warmup?: BoolFieldUpdateOperationsInput | boolean
    is_cooldown?: BoolFieldUpdateOperationsInput | boolean
    is_super_set?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetCreateManyInput = {
    id?: number
    uuid?: string
    workout_entry_uuid: string
    type: $Enums.ExerciseType
    reps?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    duration_seconds?: number | null
    distance_meters?: number | null
    rest_seconds?: number | null
    notes?: string | null
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutSetUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    distance_meters?: NullableIntFieldUpdateOperationsInput | number | null
    rest_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_dropset?: BoolFieldUpdateOperationsInput | boolean
    is_amrap?: BoolFieldUpdateOperationsInput | boolean
    is_rest?: BoolFieldUpdateOperationsInput | boolean
    is_warmup?: BoolFieldUpdateOperationsInput | boolean
    is_cooldown?: BoolFieldUpdateOperationsInput | boolean
    is_super_set?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    workout_entry_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    distance_meters?: NullableIntFieldUpdateOperationsInput | number | null
    rest_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_dropset?: BoolFieldUpdateOperationsInput | boolean
    is_amrap?: BoolFieldUpdateOperationsInput | boolean
    is_rest?: BoolFieldUpdateOperationsInput | boolean
    is_warmup?: BoolFieldUpdateOperationsInput | boolean
    is_cooldown?: BoolFieldUpdateOperationsInput | boolean
    is_super_set?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAuthRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthRole | EnumAuthRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AuthRole[] | ListEnumAuthRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthRole[] | ListEnumAuthRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthRoleFilter<$PrismaModel> | $Enums.AuthRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ScheduleSlotListRelationFilter = {
    every?: ScheduleSlotWhereInput
    some?: ScheduleSlotWhereInput
    none?: ScheduleSlotWhereInput
  }

  export type ActivityScheduleListRelationFilter = {
    every?: ActivityScheduleWhereInput
    some?: ActivityScheduleWhereInput
    none?: ActivityScheduleWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type ActivityOccurrenceListRelationFilter = {
    every?: ActivityOccurrenceWhereInput
    some?: ActivityOccurrenceWhereInput
    none?: ActivityOccurrenceWhereInput
  }

  export type ExpenseAccountListRelationFilter = {
    every?: ExpenseAccountWhereInput
    some?: ExpenseAccountWhereInput
    none?: ExpenseAccountWhereInput
  }

  export type ExpenseEntryListRelationFilter = {
    every?: ExpenseEntryWhereInput
    some?: ExpenseEntryWhereInput
    none?: ExpenseEntryWhereInput
  }

  export type ExpenseCategoryListRelationFilter = {
    every?: ExpenseCategoryWhereInput
    some?: ExpenseCategoryWhereInput
    none?: ExpenseCategoryWhereInput
  }

  export type ExpenseSubcategoryListRelationFilter = {
    every?: ExpenseSubcategoryWhereInput
    some?: ExpenseSubcategoryWhereInput
    none?: ExpenseSubcategoryWhereInput
  }

  export type ExpenseReceiptListRelationFilter = {
    every?: ExpenseReceiptWhereInput
    some?: ExpenseReceiptWhereInput
    none?: ExpenseReceiptWhereInput
  }

  export type ExpenseStoreListRelationFilter = {
    every?: ExpenseStoreWhereInput
    some?: ExpenseStoreWhereInput
    none?: ExpenseStoreWhereInput
  }

  export type ExpenseProductListRelationFilter = {
    every?: ExpenseProductWhereInput
    some?: ExpenseProductWhereInput
    none?: ExpenseProductWhereInput
  }

  export type MuscleGroupListRelationFilter = {
    every?: MuscleGroupWhereInput
    some?: MuscleGroupWhereInput
    none?: MuscleGroupWhereInput
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type WorkoutListRelationFilter = {
    every?: WorkoutWhereInput
    some?: WorkoutWhereInput
    none?: WorkoutWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOccurrenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseSubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseStoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MuscleGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAuthRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthRole | EnumAuthRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AuthRole[] | ListEnumAuthRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthRole[] | ListEnumAuthRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthRoleWithAggregatesFilter<$PrismaModel> | $Enums.AuthRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthRoleFilter<$PrismaModel>
    _max?: NestedEnumAuthRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    visible?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    visible?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    visible?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumScheduleDayFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleDay | EnumScheduleDayFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleDay[] | ListEnumScheduleDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleDay[] | ListEnumScheduleDayFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleDayFilter<$PrismaModel> | $Enums.ScheduleDay
  }

  export type ActivityScalarRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type ScheduleSlotCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ScheduleSlotAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ScheduleSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ScheduleSlotMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ScheduleSlotSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumScheduleDayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleDay | EnumScheduleDayFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleDay[] | ListEnumScheduleDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleDay[] | ListEnumScheduleDayFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleDayWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleDay
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleDayFilter<$PrismaModel>
    _max?: NestedEnumScheduleDayFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumActivityRepeatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityRepeatType | EnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityRepeatType[] | ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityRepeatType[] | ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityRepeatTypeFilter<$PrismaModel> | $Enums.ActivityRepeatType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumFrequencyPeriodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FrequencyPeriod | EnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.FrequencyPeriod[] | ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FrequencyPeriod[] | ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFrequencyPeriodNullableFilter<$PrismaModel> | $Enums.FrequencyPeriod | null
  }

  export type EnumActivityTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetType | EnumActivityTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTargetTypeFilter<$PrismaModel> | $Enums.ActivityTargetType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumActivityTargetUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetUnit | EnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActivityTargetUnit[] | ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActivityTargetUnit[] | ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActivityTargetUnitNullableFilter<$PrismaModel> | $Enums.ActivityTargetUnit | null
  }

  export type ActivityScheduleWeekdayListRelationFilter = {
    every?: ActivityScheduleWeekdayWhereInput
    some?: ActivityScheduleWeekdayWhereInput
    none?: ActivityScheduleWeekdayWhereInput
  }

  export type ActivityScheduleDateListRelationFilter = {
    every?: ActivityScheduleDateWhereInput
    some?: ActivityScheduleDateWhereInput
    none?: ActivityScheduleDateWhereInput
  }

  export type ActivityScheduleWeekdayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityScheduleDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
    repeat_type?: SortOrder
    interval_days?: SortOrder
    time_of_day?: SortOrder
    frequency_value?: SortOrder
    frequency_period?: SortOrder
    target_type?: SortOrder
    target_value?: SortOrder
    target_unit?: SortOrder
    target_unit_label?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    interval_days?: SortOrder
    frequency_value?: SortOrder
    target_value?: SortOrder
  }

  export type ActivityScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
    repeat_type?: SortOrder
    interval_days?: SortOrder
    time_of_day?: SortOrder
    frequency_value?: SortOrder
    frequency_period?: SortOrder
    target_type?: SortOrder
    target_value?: SortOrder
    target_unit?: SortOrder
    target_unit_label?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
    repeat_type?: SortOrder
    interval_days?: SortOrder
    time_of_day?: SortOrder
    frequency_value?: SortOrder
    frequency_period?: SortOrder
    target_type?: SortOrder
    target_value?: SortOrder
    target_unit?: SortOrder
    target_unit_label?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    interval_days?: SortOrder
    frequency_value?: SortOrder
    target_value?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumActivityRepeatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityRepeatType | EnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityRepeatType[] | ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityRepeatType[] | ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityRepeatTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityRepeatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityRepeatTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityRepeatTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumFrequencyPeriodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FrequencyPeriod | EnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.FrequencyPeriod[] | ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FrequencyPeriod[] | ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFrequencyPeriodNullableWithAggregatesFilter<$PrismaModel> | $Enums.FrequencyPeriod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFrequencyPeriodNullableFilter<$PrismaModel>
    _max?: NestedEnumFrequencyPeriodNullableFilter<$PrismaModel>
  }

  export type EnumActivityTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetType | EnumActivityTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTargetTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumActivityTargetUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetUnit | EnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActivityTargetUnit[] | ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActivityTargetUnit[] | ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActivityTargetUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.ActivityTargetUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumActivityTargetUnitNullableFilter<$PrismaModel>
    _max?: NestedEnumActivityTargetUnitNullableFilter<$PrismaModel>
  }

  export type ActivityScheduleScalarRelationFilter = {
    is?: ActivityScheduleWhereInput
    isNot?: ActivityScheduleWhereInput
  }

  export type ActivityScheduleWeekdaySchedule_uuidWeekdayCompoundUniqueInput = {
    schedule_uuid: string
    weekday: number
  }

  export type ActivityScheduleWeekdayCountOrderByAggregateInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    weekday?: SortOrder
  }

  export type ActivityScheduleWeekdayAvgOrderByAggregateInput = {
    id?: SortOrder
    weekday?: SortOrder
  }

  export type ActivityScheduleWeekdayMaxOrderByAggregateInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    weekday?: SortOrder
  }

  export type ActivityScheduleWeekdayMinOrderByAggregateInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    weekday?: SortOrder
  }

  export type ActivityScheduleWeekdaySumOrderByAggregateInput = {
    id?: SortOrder
    weekday?: SortOrder
  }

  export type ActivityScheduleDateSchedule_uuidDateCompoundUniqueInput = {
    schedule_uuid: string
    date: Date | string
  }

  export type ActivityScheduleDateCountOrderByAggregateInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    date?: SortOrder
  }

  export type ActivityScheduleDateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActivityScheduleDateMaxOrderByAggregateInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    date?: SortOrder
  }

  export type ActivityScheduleDateMinOrderByAggregateInput = {
    id?: SortOrder
    schedule_uuid?: SortOrder
    date?: SortOrder
  }

  export type ActivityScheduleDateSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumOccurrenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceStatus | EnumOccurrenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceStatusFilter<$PrismaModel> | $Enums.OccurrenceStatus
  }

  export type ActivityLogNullableScalarRelationFilter = {
    is?: ActivityLogWhereInput | null
    isNot?: ActivityLogWhereInput | null
  }

  export type ActivityOccurrenceSchedule_uuidScheduled_forCompoundUniqueInput = {
    schedule_uuid: string
    scheduled_for: Date | string
  }

  export type ActivityOccurrenceCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    scheduled_for?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityOccurrenceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActivityOccurrenceMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    scheduled_for?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityOccurrenceMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    scheduled_for?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityOccurrenceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumOccurrenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceStatus | EnumOccurrenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.OccurrenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccurrenceStatusFilter<$PrismaModel>
    _max?: NestedEnumOccurrenceStatusFilter<$PrismaModel>
  }

  export type ActivityOccurrenceScalarRelationFilter = {
    is?: ActivityOccurrenceWhereInput
    isNot?: ActivityOccurrenceWhereInput
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    occurrence_uuid?: SortOrder
    snapshot_target_type?: SortOrder
    snapshot_target_value?: SortOrder
    snapshot_target_unit?: SortOrder
    snapshot_target_unit_label?: SortOrder
    value?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    skipped?: SortOrder
    skip_reason?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    snapshot_target_value?: SortOrder
    value?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    occurrence_uuid?: SortOrder
    snapshot_target_type?: SortOrder
    snapshot_target_value?: SortOrder
    snapshot_target_unit?: SortOrder
    snapshot_target_unit_label?: SortOrder
    value?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    skipped?: SortOrder
    skip_reason?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    activity_uuid?: SortOrder
    schedule_uuid?: SortOrder
    occurrence_uuid?: SortOrder
    snapshot_target_type?: SortOrder
    snapshot_target_value?: SortOrder
    snapshot_target_unit?: SortOrder
    snapshot_target_unit_label?: SortOrder
    value?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    skipped?: SortOrder
    skip_reason?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    snapshot_target_value?: SortOrder
    value?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ExpenseAccountCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
  }

  export type ExpenseAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseAccountMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseAccountSumOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ExpenseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExpenseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExpenseCategoryScalarRelationFilter = {
    is?: ExpenseCategoryWhereInput
    isNot?: ExpenseCategoryWhereInput
  }

  export type ExpenseSubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    category_uuid?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseSubcategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExpenseSubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    category_uuid?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseSubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    category_uuid?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseSubcategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumExpenseEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseEntryType | EnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseEntryType[] | ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseEntryType[] | ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseEntryTypeFilter<$PrismaModel> | $Enums.ExpenseEntryType
  }

  export type ExpenseAccountScalarRelationFilter = {
    is?: ExpenseAccountWhereInput
    isNot?: ExpenseAccountWhereInput
  }

  export type ExpenseAccountNullableScalarRelationFilter = {
    is?: ExpenseAccountWhereInput | null
    isNot?: ExpenseAccountWhereInput | null
  }

  export type ExpenseCategoryNullableScalarRelationFilter = {
    is?: ExpenseCategoryWhereInput | null
    isNot?: ExpenseCategoryWhereInput | null
  }

  export type ExpenseSubcategoryNullableScalarRelationFilter = {
    is?: ExpenseSubcategoryWhereInput | null
    isNot?: ExpenseSubcategoryWhereInput | null
  }

  export type ExpenseReceiptNullableScalarRelationFilter = {
    is?: ExpenseReceiptWhereInput | null
    isNot?: ExpenseReceiptWhereInput | null
  }

  export type ExpenseEntryCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    from_account_uuid?: SortOrder
    to_account_uuid?: SortOrder
    category_uuid?: SortOrder
    subcategory_uuid?: SortOrder
    entry_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type ExpenseEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    from_account_uuid?: SortOrder
    to_account_uuid?: SortOrder
    category_uuid?: SortOrder
    subcategory_uuid?: SortOrder
    entry_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseEntryMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    from_account_uuid?: SortOrder
    to_account_uuid?: SortOrder
    category_uuid?: SortOrder
    subcategory_uuid?: SortOrder
    entry_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseEntrySumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type EnumExpenseEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseEntryType | EnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseEntryType[] | ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseEntryType[] | ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseEntryTypeFilter<$PrismaModel>
  }

  export type ExpenseStoreCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseStoreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExpenseStoreMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseStoreMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseStoreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExpenseStoreNullableScalarRelationFilter = {
    is?: ExpenseStoreWhereInput | null
    isNot?: ExpenseStoreWhereInput | null
  }

  export type ExpenseEntryScalarRelationFilter = {
    is?: ExpenseEntryWhereInput
    isNot?: ExpenseEntryWhereInput
  }

  export type ExpenseReceiptItemListRelationFilter = {
    every?: ExpenseReceiptItemWhereInput
    some?: ExpenseReceiptItemWhereInput
    none?: ExpenseReceiptItemWhereInput
  }

  export type ExpenseReceiptItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    store_uuid?: SortOrder
    expense_entry_uuid?: SortOrder
    receipt_date?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseReceiptAvgOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
  }

  export type ExpenseReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    store_uuid?: SortOrder
    expense_entry_uuid?: SortOrder
    receipt_date?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    store_uuid?: SortOrder
    expense_entry_uuid?: SortOrder
    receipt_date?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseReceiptSumOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ExpenseProductCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
    size?: SortOrder
    category_uuid?: SortOrder
    subcategory_uuid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseProductAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
  }

  export type ExpenseProductMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
    size?: SortOrder
    category_uuid?: SortOrder
    subcategory_uuid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseProductMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
    size?: SortOrder
    category_uuid?: SortOrder
    subcategory_uuid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseProductSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ExpenseReceiptScalarRelationFilter = {
    is?: ExpenseReceiptWhereInput
    isNot?: ExpenseReceiptWhereInput
  }

  export type ExpenseProductNullableScalarRelationFilter = {
    is?: ExpenseProductWhereInput | null
    isNot?: ExpenseProductWhereInput | null
  }

  export type ExpenseReceiptItemCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    receipt_uuid?: SortOrder
    product_uuid?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseReceiptItemAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
  }

  export type ExpenseReceiptItemMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    receipt_uuid?: SortOrder
    product_uuid?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseReceiptItemMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    receipt_uuid?: SortOrder
    product_uuid?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExpenseReceiptItemSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
  }

  export type MuscleGroupCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MuscleGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MuscleGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MuscleGroupMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MuscleGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumExerciseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeFilter<$PrismaModel> | $Enums.ExerciseType
  }

  export type MuscleGroupScalarRelationFilter = {
    is?: MuscleGroupWhereInput
    isNot?: MuscleGroupWhereInput
  }

  export type WorkoutEntryListRelationFilter = {
    every?: WorkoutEntryWhereInput
    some?: WorkoutEntryWhereInput
    none?: WorkoutEntryWhereInput
  }

  export type WorkoutEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    muscle_group_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    muscle_group_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    muscle_group_uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumExerciseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseTypeFilter<$PrismaModel>
    _max?: NestedEnumExerciseTypeFilter<$PrismaModel>
  }

  export type WorkoutCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorkoutMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    user_uuid?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorkoutScalarRelationFilter = {
    is?: WorkoutWhereInput
    isNot?: WorkoutWhereInput
  }

  export type ExerciseScalarRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type WorkoutSetListRelationFilter = {
    every?: WorkoutSetWhereInput
    some?: WorkoutSetWhereInput
    none?: WorkoutSetWhereInput
  }

  export type WorkoutSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutEntryCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_uuid?: SortOrder
    exercise_uuid?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type WorkoutEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_uuid?: SortOrder
    exercise_uuid?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutEntryMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_uuid?: SortOrder
    exercise_uuid?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutEntrySumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type WorkoutEntryScalarRelationFilter = {
    is?: WorkoutEntryWhereInput
    isNot?: WorkoutEntryWhereInput
  }

  export type WorkoutSetCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_entry_uuid?: SortOrder
    type?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    duration_seconds?: SortOrder
    distance_meters?: SortOrder
    rest_seconds?: SortOrder
    notes?: SortOrder
    is_dropset?: SortOrder
    is_amrap?: SortOrder
    is_rest?: SortOrder
    is_warmup?: SortOrder
    is_cooldown?: SortOrder
    is_super_set?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutSetAvgOrderByAggregateInput = {
    id?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    duration_seconds?: SortOrder
    distance_meters?: SortOrder
    rest_seconds?: SortOrder
    order?: SortOrder
  }

  export type WorkoutSetMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_entry_uuid?: SortOrder
    type?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    duration_seconds?: SortOrder
    distance_meters?: SortOrder
    rest_seconds?: SortOrder
    notes?: SortOrder
    is_dropset?: SortOrder
    is_amrap?: SortOrder
    is_rest?: SortOrder
    is_warmup?: SortOrder
    is_cooldown?: SortOrder
    is_super_set?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutSetMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    workout_entry_uuid?: SortOrder
    type?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    duration_seconds?: SortOrder
    distance_meters?: SortOrder
    rest_seconds?: SortOrder
    notes?: SortOrder
    is_dropset?: SortOrder
    is_amrap?: SortOrder
    is_rest?: SortOrder
    is_warmup?: SortOrder
    is_cooldown?: SortOrder
    is_super_set?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkoutSetSumOrderByAggregateInput = {
    id?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    duration_seconds?: SortOrder
    distance_meters?: SortOrder
    rest_seconds?: SortOrder
    order?: SortOrder
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ScheduleSlotCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleSlotCreateWithoutUserInput, ScheduleSlotUncheckedCreateWithoutUserInput> | ScheduleSlotCreateWithoutUserInput[] | ScheduleSlotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleSlotCreateOrConnectWithoutUserInput | ScheduleSlotCreateOrConnectWithoutUserInput[]
    createMany?: ScheduleSlotCreateManyUserInputEnvelope
    connect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
  }

  export type ActivityScheduleCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityScheduleCreateWithoutUserInput, ActivityScheduleUncheckedCreateWithoutUserInput> | ActivityScheduleCreateWithoutUserInput[] | ActivityScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutUserInput | ActivityScheduleCreateOrConnectWithoutUserInput[]
    createMany?: ActivityScheduleCreateManyUserInputEnvelope
    connect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityOccurrenceCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutUserInput, ActivityOccurrenceUncheckedCreateWithoutUserInput> | ActivityOccurrenceCreateWithoutUserInput[] | ActivityOccurrenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutUserInput | ActivityOccurrenceCreateOrConnectWithoutUserInput[]
    createMany?: ActivityOccurrenceCreateManyUserInputEnvelope
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
  }

  export type ExpenseAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseAccountCreateWithoutUserInput, ExpenseAccountUncheckedCreateWithoutUserInput> | ExpenseAccountCreateWithoutUserInput[] | ExpenseAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseAccountCreateOrConnectWithoutUserInput | ExpenseAccountCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseAccountCreateManyUserInputEnvelope
    connect?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
  }

  export type ExpenseEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseEntryCreateWithoutUserInput, ExpenseEntryUncheckedCreateWithoutUserInput> | ExpenseEntryCreateWithoutUserInput[] | ExpenseEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutUserInput | ExpenseEntryCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseEntryCreateManyUserInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseCategoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseCategoryCreateWithoutUserInput, ExpenseCategoryUncheckedCreateWithoutUserInput> | ExpenseCategoryCreateWithoutUserInput[] | ExpenseCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutUserInput | ExpenseCategoryCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseCategoryCreateManyUserInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type ExpenseSubcategoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutUserInput, ExpenseSubcategoryUncheckedCreateWithoutUserInput> | ExpenseSubcategoryCreateWithoutUserInput[] | ExpenseSubcategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutUserInput | ExpenseSubcategoryCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseSubcategoryCreateManyUserInputEnvelope
    connect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
  }

  export type ExpenseReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseReceiptCreateWithoutUserInput, ExpenseReceiptUncheckedCreateWithoutUserInput> | ExpenseReceiptCreateWithoutUserInput[] | ExpenseReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutUserInput | ExpenseReceiptCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseReceiptCreateManyUserInputEnvelope
    connect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
  }

  export type ExpenseStoreCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseStoreCreateWithoutUserInput, ExpenseStoreUncheckedCreateWithoutUserInput> | ExpenseStoreCreateWithoutUserInput[] | ExpenseStoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseStoreCreateOrConnectWithoutUserInput | ExpenseStoreCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseStoreCreateManyUserInputEnvelope
    connect?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
  }

  export type ExpenseProductCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseProductCreateWithoutUserInput, ExpenseProductUncheckedCreateWithoutUserInput> | ExpenseProductCreateWithoutUserInput[] | ExpenseProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutUserInput | ExpenseProductCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseProductCreateManyUserInputEnvelope
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
  }

  export type MuscleGroupCreateNestedManyWithoutUserInput = {
    create?: XOR<MuscleGroupCreateWithoutUserInput, MuscleGroupUncheckedCreateWithoutUserInput> | MuscleGroupCreateWithoutUserInput[] | MuscleGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MuscleGroupCreateOrConnectWithoutUserInput | MuscleGroupCreateOrConnectWithoutUserInput[]
    createMany?: MuscleGroupCreateManyUserInputEnvelope
    connect?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutUserInput = {
    create?: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput> | ExerciseCreateWithoutUserInput[] | ExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutUserInput | ExerciseCreateOrConnectWithoutUserInput[]
    createMany?: ExerciseCreateManyUserInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type WorkoutCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkoutCreateWithoutUserInput, WorkoutUncheckedCreateWithoutUserInput> | WorkoutCreateWithoutUserInput[] | WorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutUserInput | WorkoutCreateOrConnectWithoutUserInput[]
    createMany?: WorkoutCreateManyUserInputEnvelope
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ScheduleSlotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleSlotCreateWithoutUserInput, ScheduleSlotUncheckedCreateWithoutUserInput> | ScheduleSlotCreateWithoutUserInput[] | ScheduleSlotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleSlotCreateOrConnectWithoutUserInput | ScheduleSlotCreateOrConnectWithoutUserInput[]
    createMany?: ScheduleSlotCreateManyUserInputEnvelope
    connect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
  }

  export type ActivityScheduleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityScheduleCreateWithoutUserInput, ActivityScheduleUncheckedCreateWithoutUserInput> | ActivityScheduleCreateWithoutUserInput[] | ActivityScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutUserInput | ActivityScheduleCreateOrConnectWithoutUserInput[]
    createMany?: ActivityScheduleCreateManyUserInputEnvelope
    connect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutUserInput, ActivityOccurrenceUncheckedCreateWithoutUserInput> | ActivityOccurrenceCreateWithoutUserInput[] | ActivityOccurrenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutUserInput | ActivityOccurrenceCreateOrConnectWithoutUserInput[]
    createMany?: ActivityOccurrenceCreateManyUserInputEnvelope
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
  }

  export type ExpenseAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseAccountCreateWithoutUserInput, ExpenseAccountUncheckedCreateWithoutUserInput> | ExpenseAccountCreateWithoutUserInput[] | ExpenseAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseAccountCreateOrConnectWithoutUserInput | ExpenseAccountCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseAccountCreateManyUserInputEnvelope
    connect?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
  }

  export type ExpenseEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseEntryCreateWithoutUserInput, ExpenseEntryUncheckedCreateWithoutUserInput> | ExpenseEntryCreateWithoutUserInput[] | ExpenseEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutUserInput | ExpenseEntryCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseEntryCreateManyUserInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseCategoryCreateWithoutUserInput, ExpenseCategoryUncheckedCreateWithoutUserInput> | ExpenseCategoryCreateWithoutUserInput[] | ExpenseCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutUserInput | ExpenseCategoryCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseCategoryCreateManyUserInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutUserInput, ExpenseSubcategoryUncheckedCreateWithoutUserInput> | ExpenseSubcategoryCreateWithoutUserInput[] | ExpenseSubcategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutUserInput | ExpenseSubcategoryCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseSubcategoryCreateManyUserInputEnvelope
    connect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
  }

  export type ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseReceiptCreateWithoutUserInput, ExpenseReceiptUncheckedCreateWithoutUserInput> | ExpenseReceiptCreateWithoutUserInput[] | ExpenseReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutUserInput | ExpenseReceiptCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseReceiptCreateManyUserInputEnvelope
    connect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
  }

  export type ExpenseStoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseStoreCreateWithoutUserInput, ExpenseStoreUncheckedCreateWithoutUserInput> | ExpenseStoreCreateWithoutUserInput[] | ExpenseStoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseStoreCreateOrConnectWithoutUserInput | ExpenseStoreCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseStoreCreateManyUserInputEnvelope
    connect?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
  }

  export type ExpenseProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseProductCreateWithoutUserInput, ExpenseProductUncheckedCreateWithoutUserInput> | ExpenseProductCreateWithoutUserInput[] | ExpenseProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutUserInput | ExpenseProductCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseProductCreateManyUserInputEnvelope
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
  }

  export type MuscleGroupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MuscleGroupCreateWithoutUserInput, MuscleGroupUncheckedCreateWithoutUserInput> | MuscleGroupCreateWithoutUserInput[] | MuscleGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MuscleGroupCreateOrConnectWithoutUserInput | MuscleGroupCreateOrConnectWithoutUserInput[]
    createMany?: MuscleGroupCreateManyUserInputEnvelope
    connect?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput> | ExerciseCreateWithoutUserInput[] | ExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutUserInput | ExerciseCreateOrConnectWithoutUserInput[]
    createMany?: ExerciseCreateManyUserInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type WorkoutUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkoutCreateWithoutUserInput, WorkoutUncheckedCreateWithoutUserInput> | WorkoutCreateWithoutUserInput[] | WorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutUserInput | WorkoutCreateOrConnectWithoutUserInput[]
    createMany?: WorkoutCreateManyUserInputEnvelope
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAuthRoleFieldUpdateOperationsInput = {
    set?: $Enums.AuthRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ScheduleSlotUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleSlotCreateWithoutUserInput, ScheduleSlotUncheckedCreateWithoutUserInput> | ScheduleSlotCreateWithoutUserInput[] | ScheduleSlotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleSlotCreateOrConnectWithoutUserInput | ScheduleSlotCreateOrConnectWithoutUserInput[]
    upsert?: ScheduleSlotUpsertWithWhereUniqueWithoutUserInput | ScheduleSlotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduleSlotCreateManyUserInputEnvelope
    set?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    disconnect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    delete?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    connect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    update?: ScheduleSlotUpdateWithWhereUniqueWithoutUserInput | ScheduleSlotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduleSlotUpdateManyWithWhereWithoutUserInput | ScheduleSlotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduleSlotScalarWhereInput | ScheduleSlotScalarWhereInput[]
  }

  export type ActivityScheduleUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityScheduleCreateWithoutUserInput, ActivityScheduleUncheckedCreateWithoutUserInput> | ActivityScheduleCreateWithoutUserInput[] | ActivityScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutUserInput | ActivityScheduleCreateOrConnectWithoutUserInput[]
    upsert?: ActivityScheduleUpsertWithWhereUniqueWithoutUserInput | ActivityScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityScheduleCreateManyUserInputEnvelope
    set?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    disconnect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    delete?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    connect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    update?: ActivityScheduleUpdateWithWhereUniqueWithoutUserInput | ActivityScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityScheduleUpdateManyWithWhereWithoutUserInput | ActivityScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScheduleScalarWhereInput | ActivityScheduleScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityOccurrenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutUserInput, ActivityOccurrenceUncheckedCreateWithoutUserInput> | ActivityOccurrenceCreateWithoutUserInput[] | ActivityOccurrenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutUserInput | ActivityOccurrenceCreateOrConnectWithoutUserInput[]
    upsert?: ActivityOccurrenceUpsertWithWhereUniqueWithoutUserInput | ActivityOccurrenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityOccurrenceCreateManyUserInputEnvelope
    set?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    disconnect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    delete?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    update?: ActivityOccurrenceUpdateWithWhereUniqueWithoutUserInput | ActivityOccurrenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityOccurrenceUpdateManyWithWhereWithoutUserInput | ActivityOccurrenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityOccurrenceScalarWhereInput | ActivityOccurrenceScalarWhereInput[]
  }

  export type ExpenseAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseAccountCreateWithoutUserInput, ExpenseAccountUncheckedCreateWithoutUserInput> | ExpenseAccountCreateWithoutUserInput[] | ExpenseAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseAccountCreateOrConnectWithoutUserInput | ExpenseAccountCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseAccountUpsertWithWhereUniqueWithoutUserInput | ExpenseAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseAccountCreateManyUserInputEnvelope
    set?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
    disconnect?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
    delete?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
    connect?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
    update?: ExpenseAccountUpdateWithWhereUniqueWithoutUserInput | ExpenseAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseAccountUpdateManyWithWhereWithoutUserInput | ExpenseAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseAccountScalarWhereInput | ExpenseAccountScalarWhereInput[]
  }

  export type ExpenseEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutUserInput, ExpenseEntryUncheckedCreateWithoutUserInput> | ExpenseEntryCreateWithoutUserInput[] | ExpenseEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutUserInput | ExpenseEntryCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutUserInput | ExpenseEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseEntryCreateManyUserInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutUserInput | ExpenseEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutUserInput | ExpenseEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseCategoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutUserInput, ExpenseCategoryUncheckedCreateWithoutUserInput> | ExpenseCategoryCreateWithoutUserInput[] | ExpenseCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutUserInput | ExpenseCategoryCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutUserInput | ExpenseCategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseCategoryCreateManyUserInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutUserInput | ExpenseCategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutUserInput | ExpenseCategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type ExpenseSubcategoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutUserInput, ExpenseSubcategoryUncheckedCreateWithoutUserInput> | ExpenseSubcategoryCreateWithoutUserInput[] | ExpenseSubcategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutUserInput | ExpenseSubcategoryCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseSubcategoryUpsertWithWhereUniqueWithoutUserInput | ExpenseSubcategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseSubcategoryCreateManyUserInputEnvelope
    set?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    disconnect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    delete?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    connect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    update?: ExpenseSubcategoryUpdateWithWhereUniqueWithoutUserInput | ExpenseSubcategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseSubcategoryUpdateManyWithWhereWithoutUserInput | ExpenseSubcategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseSubcategoryScalarWhereInput | ExpenseSubcategoryScalarWhereInput[]
  }

  export type ExpenseReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseReceiptCreateWithoutUserInput, ExpenseReceiptUncheckedCreateWithoutUserInput> | ExpenseReceiptCreateWithoutUserInput[] | ExpenseReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutUserInput | ExpenseReceiptCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseReceiptUpsertWithWhereUniqueWithoutUserInput | ExpenseReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseReceiptCreateManyUserInputEnvelope
    set?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    disconnect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    delete?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    connect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    update?: ExpenseReceiptUpdateWithWhereUniqueWithoutUserInput | ExpenseReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseReceiptUpdateManyWithWhereWithoutUserInput | ExpenseReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseReceiptScalarWhereInput | ExpenseReceiptScalarWhereInput[]
  }

  export type ExpenseStoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseStoreCreateWithoutUserInput, ExpenseStoreUncheckedCreateWithoutUserInput> | ExpenseStoreCreateWithoutUserInput[] | ExpenseStoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseStoreCreateOrConnectWithoutUserInput | ExpenseStoreCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseStoreUpsertWithWhereUniqueWithoutUserInput | ExpenseStoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseStoreCreateManyUserInputEnvelope
    set?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
    disconnect?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
    delete?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
    connect?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
    update?: ExpenseStoreUpdateWithWhereUniqueWithoutUserInput | ExpenseStoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseStoreUpdateManyWithWhereWithoutUserInput | ExpenseStoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseStoreScalarWhereInput | ExpenseStoreScalarWhereInput[]
  }

  export type ExpenseProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseProductCreateWithoutUserInput, ExpenseProductUncheckedCreateWithoutUserInput> | ExpenseProductCreateWithoutUserInput[] | ExpenseProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutUserInput | ExpenseProductCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseProductUpsertWithWhereUniqueWithoutUserInput | ExpenseProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseProductCreateManyUserInputEnvelope
    set?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    disconnect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    delete?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    update?: ExpenseProductUpdateWithWhereUniqueWithoutUserInput | ExpenseProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseProductUpdateManyWithWhereWithoutUserInput | ExpenseProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseProductScalarWhereInput | ExpenseProductScalarWhereInput[]
  }

  export type MuscleGroupUpdateManyWithoutUserNestedInput = {
    create?: XOR<MuscleGroupCreateWithoutUserInput, MuscleGroupUncheckedCreateWithoutUserInput> | MuscleGroupCreateWithoutUserInput[] | MuscleGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MuscleGroupCreateOrConnectWithoutUserInput | MuscleGroupCreateOrConnectWithoutUserInput[]
    upsert?: MuscleGroupUpsertWithWhereUniqueWithoutUserInput | MuscleGroupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MuscleGroupCreateManyUserInputEnvelope
    set?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
    disconnect?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
    delete?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
    connect?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
    update?: MuscleGroupUpdateWithWhereUniqueWithoutUserInput | MuscleGroupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MuscleGroupUpdateManyWithWhereWithoutUserInput | MuscleGroupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MuscleGroupScalarWhereInput | MuscleGroupScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput> | ExerciseCreateWithoutUserInput[] | ExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutUserInput | ExerciseCreateOrConnectWithoutUserInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutUserInput | ExerciseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExerciseCreateManyUserInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutUserInput | ExerciseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutUserInput | ExerciseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type WorkoutUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkoutCreateWithoutUserInput, WorkoutUncheckedCreateWithoutUserInput> | WorkoutCreateWithoutUserInput[] | WorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutUserInput | WorkoutCreateOrConnectWithoutUserInput[]
    upsert?: WorkoutUpsertWithWhereUniqueWithoutUserInput | WorkoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkoutCreateManyUserInputEnvelope
    set?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    disconnect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    delete?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    update?: WorkoutUpdateWithWhereUniqueWithoutUserInput | WorkoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkoutUpdateManyWithWhereWithoutUserInput | WorkoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleSlotCreateWithoutUserInput, ScheduleSlotUncheckedCreateWithoutUserInput> | ScheduleSlotCreateWithoutUserInput[] | ScheduleSlotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleSlotCreateOrConnectWithoutUserInput | ScheduleSlotCreateOrConnectWithoutUserInput[]
    upsert?: ScheduleSlotUpsertWithWhereUniqueWithoutUserInput | ScheduleSlotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduleSlotCreateManyUserInputEnvelope
    set?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    disconnect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    delete?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    connect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    update?: ScheduleSlotUpdateWithWhereUniqueWithoutUserInput | ScheduleSlotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduleSlotUpdateManyWithWhereWithoutUserInput | ScheduleSlotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduleSlotScalarWhereInput | ScheduleSlotScalarWhereInput[]
  }

  export type ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityScheduleCreateWithoutUserInput, ActivityScheduleUncheckedCreateWithoutUserInput> | ActivityScheduleCreateWithoutUserInput[] | ActivityScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutUserInput | ActivityScheduleCreateOrConnectWithoutUserInput[]
    upsert?: ActivityScheduleUpsertWithWhereUniqueWithoutUserInput | ActivityScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityScheduleCreateManyUserInputEnvelope
    set?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    disconnect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    delete?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    connect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    update?: ActivityScheduleUpdateWithWhereUniqueWithoutUserInput | ActivityScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityScheduleUpdateManyWithWhereWithoutUserInput | ActivityScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScheduleScalarWhereInput | ActivityScheduleScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutUserInput, ActivityOccurrenceUncheckedCreateWithoutUserInput> | ActivityOccurrenceCreateWithoutUserInput[] | ActivityOccurrenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutUserInput | ActivityOccurrenceCreateOrConnectWithoutUserInput[]
    upsert?: ActivityOccurrenceUpsertWithWhereUniqueWithoutUserInput | ActivityOccurrenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityOccurrenceCreateManyUserInputEnvelope
    set?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    disconnect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    delete?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    update?: ActivityOccurrenceUpdateWithWhereUniqueWithoutUserInput | ActivityOccurrenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityOccurrenceUpdateManyWithWhereWithoutUserInput | ActivityOccurrenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityOccurrenceScalarWhereInput | ActivityOccurrenceScalarWhereInput[]
  }

  export type ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseAccountCreateWithoutUserInput, ExpenseAccountUncheckedCreateWithoutUserInput> | ExpenseAccountCreateWithoutUserInput[] | ExpenseAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseAccountCreateOrConnectWithoutUserInput | ExpenseAccountCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseAccountUpsertWithWhereUniqueWithoutUserInput | ExpenseAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseAccountCreateManyUserInputEnvelope
    set?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
    disconnect?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
    delete?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
    connect?: ExpenseAccountWhereUniqueInput | ExpenseAccountWhereUniqueInput[]
    update?: ExpenseAccountUpdateWithWhereUniqueWithoutUserInput | ExpenseAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseAccountUpdateManyWithWhereWithoutUserInput | ExpenseAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseAccountScalarWhereInput | ExpenseAccountScalarWhereInput[]
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutUserInput, ExpenseEntryUncheckedCreateWithoutUserInput> | ExpenseEntryCreateWithoutUserInput[] | ExpenseEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutUserInput | ExpenseEntryCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutUserInput | ExpenseEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseEntryCreateManyUserInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutUserInput | ExpenseEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutUserInput | ExpenseEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutUserInput, ExpenseCategoryUncheckedCreateWithoutUserInput> | ExpenseCategoryCreateWithoutUserInput[] | ExpenseCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutUserInput | ExpenseCategoryCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutUserInput | ExpenseCategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseCategoryCreateManyUserInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutUserInput | ExpenseCategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutUserInput | ExpenseCategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutUserInput, ExpenseSubcategoryUncheckedCreateWithoutUserInput> | ExpenseSubcategoryCreateWithoutUserInput[] | ExpenseSubcategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutUserInput | ExpenseSubcategoryCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseSubcategoryUpsertWithWhereUniqueWithoutUserInput | ExpenseSubcategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseSubcategoryCreateManyUserInputEnvelope
    set?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    disconnect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    delete?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    connect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    update?: ExpenseSubcategoryUpdateWithWhereUniqueWithoutUserInput | ExpenseSubcategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseSubcategoryUpdateManyWithWhereWithoutUserInput | ExpenseSubcategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseSubcategoryScalarWhereInput | ExpenseSubcategoryScalarWhereInput[]
  }

  export type ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseReceiptCreateWithoutUserInput, ExpenseReceiptUncheckedCreateWithoutUserInput> | ExpenseReceiptCreateWithoutUserInput[] | ExpenseReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutUserInput | ExpenseReceiptCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseReceiptUpsertWithWhereUniqueWithoutUserInput | ExpenseReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseReceiptCreateManyUserInputEnvelope
    set?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    disconnect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    delete?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    connect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    update?: ExpenseReceiptUpdateWithWhereUniqueWithoutUserInput | ExpenseReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseReceiptUpdateManyWithWhereWithoutUserInput | ExpenseReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseReceiptScalarWhereInput | ExpenseReceiptScalarWhereInput[]
  }

  export type ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseStoreCreateWithoutUserInput, ExpenseStoreUncheckedCreateWithoutUserInput> | ExpenseStoreCreateWithoutUserInput[] | ExpenseStoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseStoreCreateOrConnectWithoutUserInput | ExpenseStoreCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseStoreUpsertWithWhereUniqueWithoutUserInput | ExpenseStoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseStoreCreateManyUserInputEnvelope
    set?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
    disconnect?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
    delete?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
    connect?: ExpenseStoreWhereUniqueInput | ExpenseStoreWhereUniqueInput[]
    update?: ExpenseStoreUpdateWithWhereUniqueWithoutUserInput | ExpenseStoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseStoreUpdateManyWithWhereWithoutUserInput | ExpenseStoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseStoreScalarWhereInput | ExpenseStoreScalarWhereInput[]
  }

  export type ExpenseProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseProductCreateWithoutUserInput, ExpenseProductUncheckedCreateWithoutUserInput> | ExpenseProductCreateWithoutUserInput[] | ExpenseProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutUserInput | ExpenseProductCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseProductUpsertWithWhereUniqueWithoutUserInput | ExpenseProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseProductCreateManyUserInputEnvelope
    set?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    disconnect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    delete?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    update?: ExpenseProductUpdateWithWhereUniqueWithoutUserInput | ExpenseProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseProductUpdateManyWithWhereWithoutUserInput | ExpenseProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseProductScalarWhereInput | ExpenseProductScalarWhereInput[]
  }

  export type MuscleGroupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MuscleGroupCreateWithoutUserInput, MuscleGroupUncheckedCreateWithoutUserInput> | MuscleGroupCreateWithoutUserInput[] | MuscleGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MuscleGroupCreateOrConnectWithoutUserInput | MuscleGroupCreateOrConnectWithoutUserInput[]
    upsert?: MuscleGroupUpsertWithWhereUniqueWithoutUserInput | MuscleGroupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MuscleGroupCreateManyUserInputEnvelope
    set?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
    disconnect?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
    delete?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
    connect?: MuscleGroupWhereUniqueInput | MuscleGroupWhereUniqueInput[]
    update?: MuscleGroupUpdateWithWhereUniqueWithoutUserInput | MuscleGroupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MuscleGroupUpdateManyWithWhereWithoutUserInput | MuscleGroupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MuscleGroupScalarWhereInput | MuscleGroupScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput> | ExerciseCreateWithoutUserInput[] | ExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutUserInput | ExerciseCreateOrConnectWithoutUserInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutUserInput | ExerciseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExerciseCreateManyUserInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutUserInput | ExerciseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutUserInput | ExerciseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type WorkoutUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkoutCreateWithoutUserInput, WorkoutUncheckedCreateWithoutUserInput> | WorkoutCreateWithoutUserInput[] | WorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutUserInput | WorkoutCreateOrConnectWithoutUserInput[]
    upsert?: WorkoutUpsertWithWhereUniqueWithoutUserInput | WorkoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkoutCreateManyUserInputEnvelope
    set?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    disconnect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    delete?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    update?: WorkoutUpdateWithWhereUniqueWithoutUserInput | WorkoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkoutUpdateManyWithWhereWithoutUserInput | WorkoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduleSlotCreateNestedManyWithoutActivityInput = {
    create?: XOR<ScheduleSlotCreateWithoutActivityInput, ScheduleSlotUncheckedCreateWithoutActivityInput> | ScheduleSlotCreateWithoutActivityInput[] | ScheduleSlotUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ScheduleSlotCreateOrConnectWithoutActivityInput | ScheduleSlotCreateOrConnectWithoutActivityInput[]
    createMany?: ScheduleSlotCreateManyActivityInputEnvelope
    connect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
  }

  export type ActivityScheduleCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityScheduleCreateWithoutActivityInput, ActivityScheduleUncheckedCreateWithoutActivityInput> | ActivityScheduleCreateWithoutActivityInput[] | ActivityScheduleUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutActivityInput | ActivityScheduleCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityScheduleCreateManyActivityInputEnvelope
    connect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityLogCreateWithoutActivityInput, ActivityLogUncheckedCreateWithoutActivityInput> | ActivityLogCreateWithoutActivityInput[] | ActivityLogUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutActivityInput | ActivityLogCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityLogCreateManyActivityInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityOccurrenceCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutActivityInput, ActivityOccurrenceUncheckedCreateWithoutActivityInput> | ActivityOccurrenceCreateWithoutActivityInput[] | ActivityOccurrenceUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutActivityInput | ActivityOccurrenceCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityOccurrenceCreateManyActivityInputEnvelope
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
  }

  export type ScheduleSlotUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ScheduleSlotCreateWithoutActivityInput, ScheduleSlotUncheckedCreateWithoutActivityInput> | ScheduleSlotCreateWithoutActivityInput[] | ScheduleSlotUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ScheduleSlotCreateOrConnectWithoutActivityInput | ScheduleSlotCreateOrConnectWithoutActivityInput[]
    createMany?: ScheduleSlotCreateManyActivityInputEnvelope
    connect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
  }

  export type ActivityScheduleUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityScheduleCreateWithoutActivityInput, ActivityScheduleUncheckedCreateWithoutActivityInput> | ActivityScheduleCreateWithoutActivityInput[] | ActivityScheduleUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutActivityInput | ActivityScheduleCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityScheduleCreateManyActivityInputEnvelope
    connect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityLogCreateWithoutActivityInput, ActivityLogUncheckedCreateWithoutActivityInput> | ActivityLogCreateWithoutActivityInput[] | ActivityLogUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutActivityInput | ActivityLogCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityLogCreateManyActivityInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityOccurrenceUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutActivityInput, ActivityOccurrenceUncheckedCreateWithoutActivityInput> | ActivityOccurrenceCreateWithoutActivityInput[] | ActivityOccurrenceUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutActivityInput | ActivityOccurrenceCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityOccurrenceCreateManyActivityInputEnvelope
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type ScheduleSlotUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ScheduleSlotCreateWithoutActivityInput, ScheduleSlotUncheckedCreateWithoutActivityInput> | ScheduleSlotCreateWithoutActivityInput[] | ScheduleSlotUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ScheduleSlotCreateOrConnectWithoutActivityInput | ScheduleSlotCreateOrConnectWithoutActivityInput[]
    upsert?: ScheduleSlotUpsertWithWhereUniqueWithoutActivityInput | ScheduleSlotUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ScheduleSlotCreateManyActivityInputEnvelope
    set?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    disconnect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    delete?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    connect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    update?: ScheduleSlotUpdateWithWhereUniqueWithoutActivityInput | ScheduleSlotUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ScheduleSlotUpdateManyWithWhereWithoutActivityInput | ScheduleSlotUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ScheduleSlotScalarWhereInput | ScheduleSlotScalarWhereInput[]
  }

  export type ActivityScheduleUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityScheduleCreateWithoutActivityInput, ActivityScheduleUncheckedCreateWithoutActivityInput> | ActivityScheduleCreateWithoutActivityInput[] | ActivityScheduleUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutActivityInput | ActivityScheduleCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput | ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityScheduleCreateManyActivityInputEnvelope
    set?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    disconnect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    delete?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    connect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    update?: ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput | ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityScheduleUpdateManyWithWhereWithoutActivityInput | ActivityScheduleUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityScheduleScalarWhereInput | ActivityScheduleScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityLogCreateWithoutActivityInput, ActivityLogUncheckedCreateWithoutActivityInput> | ActivityLogCreateWithoutActivityInput[] | ActivityLogUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutActivityInput | ActivityLogCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutActivityInput | ActivityLogUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityLogCreateManyActivityInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutActivityInput | ActivityLogUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutActivityInput | ActivityLogUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityOccurrenceUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutActivityInput, ActivityOccurrenceUncheckedCreateWithoutActivityInput> | ActivityOccurrenceCreateWithoutActivityInput[] | ActivityOccurrenceUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutActivityInput | ActivityOccurrenceCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityOccurrenceUpsertWithWhereUniqueWithoutActivityInput | ActivityOccurrenceUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityOccurrenceCreateManyActivityInputEnvelope
    set?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    disconnect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    delete?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    update?: ActivityOccurrenceUpdateWithWhereUniqueWithoutActivityInput | ActivityOccurrenceUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityOccurrenceUpdateManyWithWhereWithoutActivityInput | ActivityOccurrenceUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityOccurrenceScalarWhereInput | ActivityOccurrenceScalarWhereInput[]
  }

  export type ScheduleSlotUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ScheduleSlotCreateWithoutActivityInput, ScheduleSlotUncheckedCreateWithoutActivityInput> | ScheduleSlotCreateWithoutActivityInput[] | ScheduleSlotUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ScheduleSlotCreateOrConnectWithoutActivityInput | ScheduleSlotCreateOrConnectWithoutActivityInput[]
    upsert?: ScheduleSlotUpsertWithWhereUniqueWithoutActivityInput | ScheduleSlotUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ScheduleSlotCreateManyActivityInputEnvelope
    set?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    disconnect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    delete?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    connect?: ScheduleSlotWhereUniqueInput | ScheduleSlotWhereUniqueInput[]
    update?: ScheduleSlotUpdateWithWhereUniqueWithoutActivityInput | ScheduleSlotUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ScheduleSlotUpdateManyWithWhereWithoutActivityInput | ScheduleSlotUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ScheduleSlotScalarWhereInput | ScheduleSlotScalarWhereInput[]
  }

  export type ActivityScheduleUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityScheduleCreateWithoutActivityInput, ActivityScheduleUncheckedCreateWithoutActivityInput> | ActivityScheduleCreateWithoutActivityInput[] | ActivityScheduleUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutActivityInput | ActivityScheduleCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput | ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityScheduleCreateManyActivityInputEnvelope
    set?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    disconnect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    delete?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    connect?: ActivityScheduleWhereUniqueInput | ActivityScheduleWhereUniqueInput[]
    update?: ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput | ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityScheduleUpdateManyWithWhereWithoutActivityInput | ActivityScheduleUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityScheduleScalarWhereInput | ActivityScheduleScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityLogCreateWithoutActivityInput, ActivityLogUncheckedCreateWithoutActivityInput> | ActivityLogCreateWithoutActivityInput[] | ActivityLogUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutActivityInput | ActivityLogCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutActivityInput | ActivityLogUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityLogCreateManyActivityInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutActivityInput | ActivityLogUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutActivityInput | ActivityLogUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityOccurrenceUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutActivityInput, ActivityOccurrenceUncheckedCreateWithoutActivityInput> | ActivityOccurrenceCreateWithoutActivityInput[] | ActivityOccurrenceUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutActivityInput | ActivityOccurrenceCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityOccurrenceUpsertWithWhereUniqueWithoutActivityInput | ActivityOccurrenceUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityOccurrenceCreateManyActivityInputEnvelope
    set?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    disconnect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    delete?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    update?: ActivityOccurrenceUpdateWithWhereUniqueWithoutActivityInput | ActivityOccurrenceUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityOccurrenceUpdateManyWithWhereWithoutActivityInput | ActivityOccurrenceUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityOccurrenceScalarWhereInput | ActivityOccurrenceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSchedule_slotsInput = {
    create?: XOR<UserCreateWithoutSchedule_slotsInput, UserUncheckedCreateWithoutSchedule_slotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchedule_slotsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutSchedule_slotsInput = {
    create?: XOR<ActivityCreateWithoutSchedule_slotsInput, ActivityUncheckedCreateWithoutSchedule_slotsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutSchedule_slotsInput
    connect?: ActivityWhereUniqueInput
  }

  export type EnumScheduleDayFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleDay
  }

  export type UserUpdateOneRequiredWithoutSchedule_slotsNestedInput = {
    create?: XOR<UserCreateWithoutSchedule_slotsInput, UserUncheckedCreateWithoutSchedule_slotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchedule_slotsInput
    upsert?: UserUpsertWithoutSchedule_slotsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSchedule_slotsInput, UserUpdateWithoutSchedule_slotsInput>, UserUncheckedUpdateWithoutSchedule_slotsInput>
  }

  export type ActivityUpdateOneRequiredWithoutSchedule_slotsNestedInput = {
    create?: XOR<ActivityCreateWithoutSchedule_slotsInput, ActivityUncheckedCreateWithoutSchedule_slotsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutSchedule_slotsInput
    upsert?: ActivityUpsertWithoutSchedule_slotsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutSchedule_slotsInput, ActivityUpdateWithoutSchedule_slotsInput>, ActivityUncheckedUpdateWithoutSchedule_slotsInput>
  }

  export type ActivityCreateNestedOneWithoutActivity_schedulesInput = {
    create?: XOR<ActivityCreateWithoutActivity_schedulesInput, ActivityUncheckedCreateWithoutActivity_schedulesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutActivity_schedulesInput
    connect?: ActivityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivity_schedulesInput = {
    create?: XOR<UserCreateWithoutActivity_schedulesInput, UserUncheckedCreateWithoutActivity_schedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivity_schedulesInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityScheduleWeekdayCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ActivityScheduleWeekdayCreateWithoutScheduleInput, ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput> | ActivityScheduleWeekdayCreateWithoutScheduleInput[] | ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput | ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput[]
    createMany?: ActivityScheduleWeekdayCreateManyScheduleInputEnvelope
    connect?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
  }

  export type ActivityScheduleDateCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ActivityScheduleDateCreateWithoutScheduleInput, ActivityScheduleDateUncheckedCreateWithoutScheduleInput> | ActivityScheduleDateCreateWithoutScheduleInput[] | ActivityScheduleDateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityScheduleDateCreateOrConnectWithoutScheduleInput | ActivityScheduleDateCreateOrConnectWithoutScheduleInput[]
    createMany?: ActivityScheduleDateCreateManyScheduleInputEnvelope
    connect?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
  }

  export type ActivityOccurrenceCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutScheduleInput, ActivityOccurrenceUncheckedCreateWithoutScheduleInput> | ActivityOccurrenceCreateWithoutScheduleInput[] | ActivityOccurrenceUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutScheduleInput | ActivityOccurrenceCreateOrConnectWithoutScheduleInput[]
    createMany?: ActivityOccurrenceCreateManyScheduleInputEnvelope
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ActivityLogCreateWithoutScheduleInput, ActivityLogUncheckedCreateWithoutScheduleInput> | ActivityLogCreateWithoutScheduleInput[] | ActivityLogUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutScheduleInput | ActivityLogCreateOrConnectWithoutScheduleInput[]
    createMany?: ActivityLogCreateManyScheduleInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityScheduleWeekdayUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ActivityScheduleWeekdayCreateWithoutScheduleInput, ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput> | ActivityScheduleWeekdayCreateWithoutScheduleInput[] | ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput | ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput[]
    createMany?: ActivityScheduleWeekdayCreateManyScheduleInputEnvelope
    connect?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
  }

  export type ActivityScheduleDateUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ActivityScheduleDateCreateWithoutScheduleInput, ActivityScheduleDateUncheckedCreateWithoutScheduleInput> | ActivityScheduleDateCreateWithoutScheduleInput[] | ActivityScheduleDateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityScheduleDateCreateOrConnectWithoutScheduleInput | ActivityScheduleDateCreateOrConnectWithoutScheduleInput[]
    createMany?: ActivityScheduleDateCreateManyScheduleInputEnvelope
    connect?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
  }

  export type ActivityOccurrenceUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutScheduleInput, ActivityOccurrenceUncheckedCreateWithoutScheduleInput> | ActivityOccurrenceCreateWithoutScheduleInput[] | ActivityOccurrenceUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutScheduleInput | ActivityOccurrenceCreateOrConnectWithoutScheduleInput[]
    createMany?: ActivityOccurrenceCreateManyScheduleInputEnvelope
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ActivityLogCreateWithoutScheduleInput, ActivityLogUncheckedCreateWithoutScheduleInput> | ActivityLogCreateWithoutScheduleInput[] | ActivityLogUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutScheduleInput | ActivityLogCreateOrConnectWithoutScheduleInput[]
    createMany?: ActivityLogCreateManyScheduleInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumActivityRepeatTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityRepeatType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumFrequencyPeriodFieldUpdateOperationsInput = {
    set?: $Enums.FrequencyPeriod | null
  }

  export type EnumActivityTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityTargetType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumActivityTargetUnitFieldUpdateOperationsInput = {
    set?: $Enums.ActivityTargetUnit | null
  }

  export type ActivityUpdateOneRequiredWithoutActivity_schedulesNestedInput = {
    create?: XOR<ActivityCreateWithoutActivity_schedulesInput, ActivityUncheckedCreateWithoutActivity_schedulesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutActivity_schedulesInput
    upsert?: ActivityUpsertWithoutActivity_schedulesInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutActivity_schedulesInput, ActivityUpdateWithoutActivity_schedulesInput>, ActivityUncheckedUpdateWithoutActivity_schedulesInput>
  }

  export type UserUpdateOneRequiredWithoutActivity_schedulesNestedInput = {
    create?: XOR<UserCreateWithoutActivity_schedulesInput, UserUncheckedCreateWithoutActivity_schedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivity_schedulesInput
    upsert?: UserUpsertWithoutActivity_schedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivity_schedulesInput, UserUpdateWithoutActivity_schedulesInput>, UserUncheckedUpdateWithoutActivity_schedulesInput>
  }

  export type ActivityScheduleWeekdayUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ActivityScheduleWeekdayCreateWithoutScheduleInput, ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput> | ActivityScheduleWeekdayCreateWithoutScheduleInput[] | ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput | ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput[]
    upsert?: ActivityScheduleWeekdayUpsertWithWhereUniqueWithoutScheduleInput | ActivityScheduleWeekdayUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ActivityScheduleWeekdayCreateManyScheduleInputEnvelope
    set?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
    disconnect?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
    delete?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
    connect?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
    update?: ActivityScheduleWeekdayUpdateWithWhereUniqueWithoutScheduleInput | ActivityScheduleWeekdayUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ActivityScheduleWeekdayUpdateManyWithWhereWithoutScheduleInput | ActivityScheduleWeekdayUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ActivityScheduleWeekdayScalarWhereInput | ActivityScheduleWeekdayScalarWhereInput[]
  }

  export type ActivityScheduleDateUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ActivityScheduleDateCreateWithoutScheduleInput, ActivityScheduleDateUncheckedCreateWithoutScheduleInput> | ActivityScheduleDateCreateWithoutScheduleInput[] | ActivityScheduleDateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityScheduleDateCreateOrConnectWithoutScheduleInput | ActivityScheduleDateCreateOrConnectWithoutScheduleInput[]
    upsert?: ActivityScheduleDateUpsertWithWhereUniqueWithoutScheduleInput | ActivityScheduleDateUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ActivityScheduleDateCreateManyScheduleInputEnvelope
    set?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
    disconnect?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
    delete?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
    connect?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
    update?: ActivityScheduleDateUpdateWithWhereUniqueWithoutScheduleInput | ActivityScheduleDateUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ActivityScheduleDateUpdateManyWithWhereWithoutScheduleInput | ActivityScheduleDateUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ActivityScheduleDateScalarWhereInput | ActivityScheduleDateScalarWhereInput[]
  }

  export type ActivityOccurrenceUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutScheduleInput, ActivityOccurrenceUncheckedCreateWithoutScheduleInput> | ActivityOccurrenceCreateWithoutScheduleInput[] | ActivityOccurrenceUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutScheduleInput | ActivityOccurrenceCreateOrConnectWithoutScheduleInput[]
    upsert?: ActivityOccurrenceUpsertWithWhereUniqueWithoutScheduleInput | ActivityOccurrenceUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ActivityOccurrenceCreateManyScheduleInputEnvelope
    set?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    disconnect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    delete?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    update?: ActivityOccurrenceUpdateWithWhereUniqueWithoutScheduleInput | ActivityOccurrenceUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ActivityOccurrenceUpdateManyWithWhereWithoutScheduleInput | ActivityOccurrenceUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ActivityOccurrenceScalarWhereInput | ActivityOccurrenceScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ActivityLogCreateWithoutScheduleInput, ActivityLogUncheckedCreateWithoutScheduleInput> | ActivityLogCreateWithoutScheduleInput[] | ActivityLogUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutScheduleInput | ActivityLogCreateOrConnectWithoutScheduleInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutScheduleInput | ActivityLogUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ActivityLogCreateManyScheduleInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutScheduleInput | ActivityLogUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutScheduleInput | ActivityLogUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ActivityScheduleWeekdayCreateWithoutScheduleInput, ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput> | ActivityScheduleWeekdayCreateWithoutScheduleInput[] | ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput | ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput[]
    upsert?: ActivityScheduleWeekdayUpsertWithWhereUniqueWithoutScheduleInput | ActivityScheduleWeekdayUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ActivityScheduleWeekdayCreateManyScheduleInputEnvelope
    set?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
    disconnect?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
    delete?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
    connect?: ActivityScheduleWeekdayWhereUniqueInput | ActivityScheduleWeekdayWhereUniqueInput[]
    update?: ActivityScheduleWeekdayUpdateWithWhereUniqueWithoutScheduleInput | ActivityScheduleWeekdayUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ActivityScheduleWeekdayUpdateManyWithWhereWithoutScheduleInput | ActivityScheduleWeekdayUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ActivityScheduleWeekdayScalarWhereInput | ActivityScheduleWeekdayScalarWhereInput[]
  }

  export type ActivityScheduleDateUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ActivityScheduleDateCreateWithoutScheduleInput, ActivityScheduleDateUncheckedCreateWithoutScheduleInput> | ActivityScheduleDateCreateWithoutScheduleInput[] | ActivityScheduleDateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityScheduleDateCreateOrConnectWithoutScheduleInput | ActivityScheduleDateCreateOrConnectWithoutScheduleInput[]
    upsert?: ActivityScheduleDateUpsertWithWhereUniqueWithoutScheduleInput | ActivityScheduleDateUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ActivityScheduleDateCreateManyScheduleInputEnvelope
    set?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
    disconnect?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
    delete?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
    connect?: ActivityScheduleDateWhereUniqueInput | ActivityScheduleDateWhereUniqueInput[]
    update?: ActivityScheduleDateUpdateWithWhereUniqueWithoutScheduleInput | ActivityScheduleDateUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ActivityScheduleDateUpdateManyWithWhereWithoutScheduleInput | ActivityScheduleDateUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ActivityScheduleDateScalarWhereInput | ActivityScheduleDateScalarWhereInput[]
  }

  export type ActivityOccurrenceUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutScheduleInput, ActivityOccurrenceUncheckedCreateWithoutScheduleInput> | ActivityOccurrenceCreateWithoutScheduleInput[] | ActivityOccurrenceUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutScheduleInput | ActivityOccurrenceCreateOrConnectWithoutScheduleInput[]
    upsert?: ActivityOccurrenceUpsertWithWhereUniqueWithoutScheduleInput | ActivityOccurrenceUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ActivityOccurrenceCreateManyScheduleInputEnvelope
    set?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    disconnect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    delete?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    connect?: ActivityOccurrenceWhereUniqueInput | ActivityOccurrenceWhereUniqueInput[]
    update?: ActivityOccurrenceUpdateWithWhereUniqueWithoutScheduleInput | ActivityOccurrenceUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ActivityOccurrenceUpdateManyWithWhereWithoutScheduleInput | ActivityOccurrenceUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ActivityOccurrenceScalarWhereInput | ActivityOccurrenceScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ActivityLogCreateWithoutScheduleInput, ActivityLogUncheckedCreateWithoutScheduleInput> | ActivityLogCreateWithoutScheduleInput[] | ActivityLogUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutScheduleInput | ActivityLogCreateOrConnectWithoutScheduleInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutScheduleInput | ActivityLogUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ActivityLogCreateManyScheduleInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutScheduleInput | ActivityLogUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutScheduleInput | ActivityLogUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityScheduleCreateNestedOneWithoutWeekdaysInput = {
    create?: XOR<ActivityScheduleCreateWithoutWeekdaysInput, ActivityScheduleUncheckedCreateWithoutWeekdaysInput>
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutWeekdaysInput
    connect?: ActivityScheduleWhereUniqueInput
  }

  export type ActivityScheduleUpdateOneRequiredWithoutWeekdaysNestedInput = {
    create?: XOR<ActivityScheduleCreateWithoutWeekdaysInput, ActivityScheduleUncheckedCreateWithoutWeekdaysInput>
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutWeekdaysInput
    upsert?: ActivityScheduleUpsertWithoutWeekdaysInput
    connect?: ActivityScheduleWhereUniqueInput
    update?: XOR<XOR<ActivityScheduleUpdateToOneWithWhereWithoutWeekdaysInput, ActivityScheduleUpdateWithoutWeekdaysInput>, ActivityScheduleUncheckedUpdateWithoutWeekdaysInput>
  }

  export type ActivityScheduleCreateNestedOneWithoutSpecific_datesInput = {
    create?: XOR<ActivityScheduleCreateWithoutSpecific_datesInput, ActivityScheduleUncheckedCreateWithoutSpecific_datesInput>
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutSpecific_datesInput
    connect?: ActivityScheduleWhereUniqueInput
  }

  export type ActivityScheduleUpdateOneRequiredWithoutSpecific_datesNestedInput = {
    create?: XOR<ActivityScheduleCreateWithoutSpecific_datesInput, ActivityScheduleUncheckedCreateWithoutSpecific_datesInput>
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutSpecific_datesInput
    upsert?: ActivityScheduleUpsertWithoutSpecific_datesInput
    connect?: ActivityScheduleWhereUniqueInput
    update?: XOR<XOR<ActivityScheduleUpdateToOneWithWhereWithoutSpecific_datesInput, ActivityScheduleUpdateWithoutSpecific_datesInput>, ActivityScheduleUncheckedUpdateWithoutSpecific_datesInput>
  }

  export type ActivityCreateNestedOneWithoutActivity_occurrencesInput = {
    create?: XOR<ActivityCreateWithoutActivity_occurrencesInput, ActivityUncheckedCreateWithoutActivity_occurrencesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutActivity_occurrencesInput
    connect?: ActivityWhereUniqueInput
  }

  export type ActivityScheduleCreateNestedOneWithoutOccurrencesInput = {
    create?: XOR<ActivityScheduleCreateWithoutOccurrencesInput, ActivityScheduleUncheckedCreateWithoutOccurrencesInput>
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutOccurrencesInput
    connect?: ActivityScheduleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivity_occurrencesInput = {
    create?: XOR<UserCreateWithoutActivity_occurrencesInput, UserUncheckedCreateWithoutActivity_occurrencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivity_occurrencesInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityLogCreateNestedOneWithoutOccurrenceInput = {
    create?: XOR<ActivityLogCreateWithoutOccurrenceInput, ActivityLogUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOccurrenceInput
    connect?: ActivityLogWhereUniqueInput
  }

  export type ActivityLogUncheckedCreateNestedOneWithoutOccurrenceInput = {
    create?: XOR<ActivityLogCreateWithoutOccurrenceInput, ActivityLogUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOccurrenceInput
    connect?: ActivityLogWhereUniqueInput
  }

  export type EnumOccurrenceStatusFieldUpdateOperationsInput = {
    set?: $Enums.OccurrenceStatus
  }

  export type ActivityUpdateOneRequiredWithoutActivity_occurrencesNestedInput = {
    create?: XOR<ActivityCreateWithoutActivity_occurrencesInput, ActivityUncheckedCreateWithoutActivity_occurrencesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutActivity_occurrencesInput
    upsert?: ActivityUpsertWithoutActivity_occurrencesInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutActivity_occurrencesInput, ActivityUpdateWithoutActivity_occurrencesInput>, ActivityUncheckedUpdateWithoutActivity_occurrencesInput>
  }

  export type ActivityScheduleUpdateOneRequiredWithoutOccurrencesNestedInput = {
    create?: XOR<ActivityScheduleCreateWithoutOccurrencesInput, ActivityScheduleUncheckedCreateWithoutOccurrencesInput>
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutOccurrencesInput
    upsert?: ActivityScheduleUpsertWithoutOccurrencesInput
    connect?: ActivityScheduleWhereUniqueInput
    update?: XOR<XOR<ActivityScheduleUpdateToOneWithWhereWithoutOccurrencesInput, ActivityScheduleUpdateWithoutOccurrencesInput>, ActivityScheduleUncheckedUpdateWithoutOccurrencesInput>
  }

  export type UserUpdateOneRequiredWithoutActivity_occurrencesNestedInput = {
    create?: XOR<UserCreateWithoutActivity_occurrencesInput, UserUncheckedCreateWithoutActivity_occurrencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivity_occurrencesInput
    upsert?: UserUpsertWithoutActivity_occurrencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivity_occurrencesInput, UserUpdateWithoutActivity_occurrencesInput>, UserUncheckedUpdateWithoutActivity_occurrencesInput>
  }

  export type ActivityLogUpdateOneWithoutOccurrenceNestedInput = {
    create?: XOR<ActivityLogCreateWithoutOccurrenceInput, ActivityLogUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOccurrenceInput
    upsert?: ActivityLogUpsertWithoutOccurrenceInput
    disconnect?: ActivityLogWhereInput | boolean
    delete?: ActivityLogWhereInput | boolean
    connect?: ActivityLogWhereUniqueInput
    update?: XOR<XOR<ActivityLogUpdateToOneWithWhereWithoutOccurrenceInput, ActivityLogUpdateWithoutOccurrenceInput>, ActivityLogUncheckedUpdateWithoutOccurrenceInput>
  }

  export type ActivityLogUncheckedUpdateOneWithoutOccurrenceNestedInput = {
    create?: XOR<ActivityLogCreateWithoutOccurrenceInput, ActivityLogUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOccurrenceInput
    upsert?: ActivityLogUpsertWithoutOccurrenceInput
    disconnect?: ActivityLogWhereInput | boolean
    delete?: ActivityLogWhereInput | boolean
    connect?: ActivityLogWhereUniqueInput
    update?: XOR<XOR<ActivityLogUpdateToOneWithWhereWithoutOccurrenceInput, ActivityLogUpdateWithoutOccurrenceInput>, ActivityLogUncheckedUpdateWithoutOccurrenceInput>
  }

  export type ActivityCreateNestedOneWithoutActivity_logsInput = {
    create?: XOR<ActivityCreateWithoutActivity_logsInput, ActivityUncheckedCreateWithoutActivity_logsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutActivity_logsInput
    connect?: ActivityWhereUniqueInput
  }

  export type ActivityScheduleCreateNestedOneWithoutLogsInput = {
    create?: XOR<ActivityScheduleCreateWithoutLogsInput, ActivityScheduleUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutLogsInput
    connect?: ActivityScheduleWhereUniqueInput
  }

  export type ActivityOccurrenceCreateNestedOneWithoutLogInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutLogInput, ActivityOccurrenceUncheckedCreateWithoutLogInput>
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutLogInput
    connect?: ActivityOccurrenceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivity_logsInput = {
    create?: XOR<UserCreateWithoutActivity_logsInput, UserUncheckedCreateWithoutActivity_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivity_logsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityUpdateOneRequiredWithoutActivity_logsNestedInput = {
    create?: XOR<ActivityCreateWithoutActivity_logsInput, ActivityUncheckedCreateWithoutActivity_logsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutActivity_logsInput
    upsert?: ActivityUpsertWithoutActivity_logsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutActivity_logsInput, ActivityUpdateWithoutActivity_logsInput>, ActivityUncheckedUpdateWithoutActivity_logsInput>
  }

  export type ActivityScheduleUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ActivityScheduleCreateWithoutLogsInput, ActivityScheduleUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ActivityScheduleCreateOrConnectWithoutLogsInput
    upsert?: ActivityScheduleUpsertWithoutLogsInput
    connect?: ActivityScheduleWhereUniqueInput
    update?: XOR<XOR<ActivityScheduleUpdateToOneWithWhereWithoutLogsInput, ActivityScheduleUpdateWithoutLogsInput>, ActivityScheduleUncheckedUpdateWithoutLogsInput>
  }

  export type ActivityOccurrenceUpdateOneRequiredWithoutLogNestedInput = {
    create?: XOR<ActivityOccurrenceCreateWithoutLogInput, ActivityOccurrenceUncheckedCreateWithoutLogInput>
    connectOrCreate?: ActivityOccurrenceCreateOrConnectWithoutLogInput
    upsert?: ActivityOccurrenceUpsertWithoutLogInput
    connect?: ActivityOccurrenceWhereUniqueInput
    update?: XOR<XOR<ActivityOccurrenceUpdateToOneWithWhereWithoutLogInput, ActivityOccurrenceUpdateWithoutLogInput>, ActivityOccurrenceUncheckedUpdateWithoutLogInput>
  }

  export type UserUpdateOneRequiredWithoutActivity_logsNestedInput = {
    create?: XOR<UserCreateWithoutActivity_logsInput, UserUncheckedCreateWithoutActivity_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivity_logsInput
    upsert?: UserUpsertWithoutActivity_logsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivity_logsInput, UserUpdateWithoutActivity_logsInput>, UserUncheckedUpdateWithoutActivity_logsInput>
  }

  export type UserCreateNestedOneWithoutExpense_accountsInput = {
    create?: XOR<UserCreateWithoutExpense_accountsInput, UserUncheckedCreateWithoutExpense_accountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_accountsInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseEntryCreateNestedManyWithoutFrom_accountInput = {
    create?: XOR<ExpenseEntryCreateWithoutFrom_accountInput, ExpenseEntryUncheckedCreateWithoutFrom_accountInput> | ExpenseEntryCreateWithoutFrom_accountInput[] | ExpenseEntryUncheckedCreateWithoutFrom_accountInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutFrom_accountInput | ExpenseEntryCreateOrConnectWithoutFrom_accountInput[]
    createMany?: ExpenseEntryCreateManyFrom_accountInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseEntryCreateNestedManyWithoutTo_accountInput = {
    create?: XOR<ExpenseEntryCreateWithoutTo_accountInput, ExpenseEntryUncheckedCreateWithoutTo_accountInput> | ExpenseEntryCreateWithoutTo_accountInput[] | ExpenseEntryUncheckedCreateWithoutTo_accountInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutTo_accountInput | ExpenseEntryCreateOrConnectWithoutTo_accountInput[]
    createMany?: ExpenseEntryCreateManyTo_accountInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseEntryUncheckedCreateNestedManyWithoutFrom_accountInput = {
    create?: XOR<ExpenseEntryCreateWithoutFrom_accountInput, ExpenseEntryUncheckedCreateWithoutFrom_accountInput> | ExpenseEntryCreateWithoutFrom_accountInput[] | ExpenseEntryUncheckedCreateWithoutFrom_accountInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutFrom_accountInput | ExpenseEntryCreateOrConnectWithoutFrom_accountInput[]
    createMany?: ExpenseEntryCreateManyFrom_accountInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseEntryUncheckedCreateNestedManyWithoutTo_accountInput = {
    create?: XOR<ExpenseEntryCreateWithoutTo_accountInput, ExpenseEntryUncheckedCreateWithoutTo_accountInput> | ExpenseEntryCreateWithoutTo_accountInput[] | ExpenseEntryUncheckedCreateWithoutTo_accountInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutTo_accountInput | ExpenseEntryCreateOrConnectWithoutTo_accountInput[]
    createMany?: ExpenseEntryCreateManyTo_accountInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutExpense_accountsNestedInput = {
    create?: XOR<UserCreateWithoutExpense_accountsInput, UserUncheckedCreateWithoutExpense_accountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_accountsInput
    upsert?: UserUpsertWithoutExpense_accountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpense_accountsInput, UserUpdateWithoutExpense_accountsInput>, UserUncheckedUpdateWithoutExpense_accountsInput>
  }

  export type ExpenseEntryUpdateManyWithoutFrom_accountNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutFrom_accountInput, ExpenseEntryUncheckedCreateWithoutFrom_accountInput> | ExpenseEntryCreateWithoutFrom_accountInput[] | ExpenseEntryUncheckedCreateWithoutFrom_accountInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutFrom_accountInput | ExpenseEntryCreateOrConnectWithoutFrom_accountInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutFrom_accountInput | ExpenseEntryUpsertWithWhereUniqueWithoutFrom_accountInput[]
    createMany?: ExpenseEntryCreateManyFrom_accountInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutFrom_accountInput | ExpenseEntryUpdateWithWhereUniqueWithoutFrom_accountInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutFrom_accountInput | ExpenseEntryUpdateManyWithWhereWithoutFrom_accountInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseEntryUpdateManyWithoutTo_accountNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutTo_accountInput, ExpenseEntryUncheckedCreateWithoutTo_accountInput> | ExpenseEntryCreateWithoutTo_accountInput[] | ExpenseEntryUncheckedCreateWithoutTo_accountInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutTo_accountInput | ExpenseEntryCreateOrConnectWithoutTo_accountInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutTo_accountInput | ExpenseEntryUpsertWithWhereUniqueWithoutTo_accountInput[]
    createMany?: ExpenseEntryCreateManyTo_accountInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutTo_accountInput | ExpenseEntryUpdateWithWhereUniqueWithoutTo_accountInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutTo_accountInput | ExpenseEntryUpdateManyWithWhereWithoutTo_accountInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutFrom_accountNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutFrom_accountInput, ExpenseEntryUncheckedCreateWithoutFrom_accountInput> | ExpenseEntryCreateWithoutFrom_accountInput[] | ExpenseEntryUncheckedCreateWithoutFrom_accountInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutFrom_accountInput | ExpenseEntryCreateOrConnectWithoutFrom_accountInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutFrom_accountInput | ExpenseEntryUpsertWithWhereUniqueWithoutFrom_accountInput[]
    createMany?: ExpenseEntryCreateManyFrom_accountInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutFrom_accountInput | ExpenseEntryUpdateWithWhereUniqueWithoutFrom_accountInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutFrom_accountInput | ExpenseEntryUpdateManyWithWhereWithoutFrom_accountInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutTo_accountNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutTo_accountInput, ExpenseEntryUncheckedCreateWithoutTo_accountInput> | ExpenseEntryCreateWithoutTo_accountInput[] | ExpenseEntryUncheckedCreateWithoutTo_accountInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutTo_accountInput | ExpenseEntryCreateOrConnectWithoutTo_accountInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutTo_accountInput | ExpenseEntryUpsertWithWhereUniqueWithoutTo_accountInput[]
    createMany?: ExpenseEntryCreateManyTo_accountInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutTo_accountInput | ExpenseEntryUpdateWithWhereUniqueWithoutTo_accountInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutTo_accountInput | ExpenseEntryUpdateManyWithWhereWithoutTo_accountInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseSubcategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutCategoryInput, ExpenseSubcategoryUncheckedCreateWithoutCategoryInput> | ExpenseSubcategoryCreateWithoutCategoryInput[] | ExpenseSubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutCategoryInput | ExpenseSubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseSubcategoryCreateManyCategoryInputEnvelope
    connect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
  }

  export type ExpenseEntryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseEntryCreateWithoutCategoryInput, ExpenseEntryUncheckedCreateWithoutCategoryInput> | ExpenseEntryCreateWithoutCategoryInput[] | ExpenseEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutCategoryInput | ExpenseEntryCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseEntryCreateManyCategoryInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseProductCreateWithoutCategoryInput, ExpenseProductUncheckedCreateWithoutCategoryInput> | ExpenseProductCreateWithoutCategoryInput[] | ExpenseProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutCategoryInput | ExpenseProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseProductCreateManyCategoryInputEnvelope
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
  }

  export type ExpenseSubcategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutCategoryInput, ExpenseSubcategoryUncheckedCreateWithoutCategoryInput> | ExpenseSubcategoryCreateWithoutCategoryInput[] | ExpenseSubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutCategoryInput | ExpenseSubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseSubcategoryCreateManyCategoryInputEnvelope
    connect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
  }

  export type ExpenseEntryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseEntryCreateWithoutCategoryInput, ExpenseEntryUncheckedCreateWithoutCategoryInput> | ExpenseEntryCreateWithoutCategoryInput[] | ExpenseEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutCategoryInput | ExpenseEntryCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseEntryCreateManyCategoryInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseProductCreateWithoutCategoryInput, ExpenseProductUncheckedCreateWithoutCategoryInput> | ExpenseProductCreateWithoutCategoryInput[] | ExpenseProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutCategoryInput | ExpenseProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseProductCreateManyCategoryInputEnvelope
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    upsert?: UserUpsertWithoutCategoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCategoriesInput, UserUpdateWithoutCategoriesInput>, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type ExpenseSubcategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutCategoryInput, ExpenseSubcategoryUncheckedCreateWithoutCategoryInput> | ExpenseSubcategoryCreateWithoutCategoryInput[] | ExpenseSubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutCategoryInput | ExpenseSubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseSubcategoryUpsertWithWhereUniqueWithoutCategoryInput | ExpenseSubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseSubcategoryCreateManyCategoryInputEnvelope
    set?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    disconnect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    delete?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    connect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    update?: ExpenseSubcategoryUpdateWithWhereUniqueWithoutCategoryInput | ExpenseSubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseSubcategoryUpdateManyWithWhereWithoutCategoryInput | ExpenseSubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseSubcategoryScalarWhereInput | ExpenseSubcategoryScalarWhereInput[]
  }

  export type ExpenseEntryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutCategoryInput, ExpenseEntryUncheckedCreateWithoutCategoryInput> | ExpenseEntryCreateWithoutCategoryInput[] | ExpenseEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutCategoryInput | ExpenseEntryCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutCategoryInput | ExpenseEntryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseEntryCreateManyCategoryInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutCategoryInput | ExpenseEntryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutCategoryInput | ExpenseEntryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseProductCreateWithoutCategoryInput, ExpenseProductUncheckedCreateWithoutCategoryInput> | ExpenseProductCreateWithoutCategoryInput[] | ExpenseProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutCategoryInput | ExpenseProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseProductUpsertWithWhereUniqueWithoutCategoryInput | ExpenseProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseProductCreateManyCategoryInputEnvelope
    set?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    disconnect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    delete?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    update?: ExpenseProductUpdateWithWhereUniqueWithoutCategoryInput | ExpenseProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseProductUpdateManyWithWhereWithoutCategoryInput | ExpenseProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseProductScalarWhereInput | ExpenseProductScalarWhereInput[]
  }

  export type ExpenseSubcategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutCategoryInput, ExpenseSubcategoryUncheckedCreateWithoutCategoryInput> | ExpenseSubcategoryCreateWithoutCategoryInput[] | ExpenseSubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutCategoryInput | ExpenseSubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseSubcategoryUpsertWithWhereUniqueWithoutCategoryInput | ExpenseSubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseSubcategoryCreateManyCategoryInputEnvelope
    set?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    disconnect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    delete?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    connect?: ExpenseSubcategoryWhereUniqueInput | ExpenseSubcategoryWhereUniqueInput[]
    update?: ExpenseSubcategoryUpdateWithWhereUniqueWithoutCategoryInput | ExpenseSubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseSubcategoryUpdateManyWithWhereWithoutCategoryInput | ExpenseSubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseSubcategoryScalarWhereInput | ExpenseSubcategoryScalarWhereInput[]
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutCategoryInput, ExpenseEntryUncheckedCreateWithoutCategoryInput> | ExpenseEntryCreateWithoutCategoryInput[] | ExpenseEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutCategoryInput | ExpenseEntryCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutCategoryInput | ExpenseEntryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseEntryCreateManyCategoryInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutCategoryInput | ExpenseEntryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutCategoryInput | ExpenseEntryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseProductCreateWithoutCategoryInput, ExpenseProductUncheckedCreateWithoutCategoryInput> | ExpenseProductCreateWithoutCategoryInput[] | ExpenseProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutCategoryInput | ExpenseProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseProductUpsertWithWhereUniqueWithoutCategoryInput | ExpenseProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseProductCreateManyCategoryInputEnvelope
    set?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    disconnect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    delete?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    update?: ExpenseProductUpdateWithWhereUniqueWithoutCategoryInput | ExpenseProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseProductUpdateManyWithWhereWithoutCategoryInput | ExpenseProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseProductScalarWhereInput | ExpenseProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<UserCreateWithoutSubcategoriesInput, UserUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubcategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseCategoryCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<ExpenseCategoryCreateWithoutSubcategoriesInput, ExpenseCategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutSubcategoriesInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type ExpenseEntryCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ExpenseEntryCreateWithoutSubcategoryInput, ExpenseEntryUncheckedCreateWithoutSubcategoryInput> | ExpenseEntryCreateWithoutSubcategoryInput[] | ExpenseEntryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutSubcategoryInput | ExpenseEntryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ExpenseEntryCreateManySubcategoryInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseProductCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ExpenseProductCreateWithoutSubcategoryInput, ExpenseProductUncheckedCreateWithoutSubcategoryInput> | ExpenseProductCreateWithoutSubcategoryInput[] | ExpenseProductUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutSubcategoryInput | ExpenseProductCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ExpenseProductCreateManySubcategoryInputEnvelope
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
  }

  export type ExpenseEntryUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ExpenseEntryCreateWithoutSubcategoryInput, ExpenseEntryUncheckedCreateWithoutSubcategoryInput> | ExpenseEntryCreateWithoutSubcategoryInput[] | ExpenseEntryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutSubcategoryInput | ExpenseEntryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ExpenseEntryCreateManySubcategoryInputEnvelope
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
  }

  export type ExpenseProductUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<ExpenseProductCreateWithoutSubcategoryInput, ExpenseProductUncheckedCreateWithoutSubcategoryInput> | ExpenseProductCreateWithoutSubcategoryInput[] | ExpenseProductUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutSubcategoryInput | ExpenseProductCreateOrConnectWithoutSubcategoryInput[]
    createMany?: ExpenseProductCreateManySubcategoryInputEnvelope
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutSubcategoriesNestedInput = {
    create?: XOR<UserCreateWithoutSubcategoriesInput, UserUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubcategoriesInput
    upsert?: UserUpsertWithoutSubcategoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubcategoriesInput, UserUpdateWithoutSubcategoriesInput>, UserUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ExpenseCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutSubcategoriesInput, ExpenseCategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutSubcategoriesInput
    upsert?: ExpenseCategoryUpsertWithoutSubcategoriesInput
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutSubcategoriesInput, ExpenseCategoryUpdateWithoutSubcategoriesInput>, ExpenseCategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ExpenseEntryUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutSubcategoryInput, ExpenseEntryUncheckedCreateWithoutSubcategoryInput> | ExpenseEntryCreateWithoutSubcategoryInput[] | ExpenseEntryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutSubcategoryInput | ExpenseEntryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutSubcategoryInput | ExpenseEntryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ExpenseEntryCreateManySubcategoryInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutSubcategoryInput | ExpenseEntryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutSubcategoryInput | ExpenseEntryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseProductUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ExpenseProductCreateWithoutSubcategoryInput, ExpenseProductUncheckedCreateWithoutSubcategoryInput> | ExpenseProductCreateWithoutSubcategoryInput[] | ExpenseProductUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutSubcategoryInput | ExpenseProductCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ExpenseProductUpsertWithWhereUniqueWithoutSubcategoryInput | ExpenseProductUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ExpenseProductCreateManySubcategoryInputEnvelope
    set?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    disconnect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    delete?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    update?: ExpenseProductUpdateWithWhereUniqueWithoutSubcategoryInput | ExpenseProductUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ExpenseProductUpdateManyWithWhereWithoutSubcategoryInput | ExpenseProductUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ExpenseProductScalarWhereInput | ExpenseProductScalarWhereInput[]
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutSubcategoryInput, ExpenseEntryUncheckedCreateWithoutSubcategoryInput> | ExpenseEntryCreateWithoutSubcategoryInput[] | ExpenseEntryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutSubcategoryInput | ExpenseEntryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ExpenseEntryUpsertWithWhereUniqueWithoutSubcategoryInput | ExpenseEntryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ExpenseEntryCreateManySubcategoryInputEnvelope
    set?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    disconnect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    delete?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    connect?: ExpenseEntryWhereUniqueInput | ExpenseEntryWhereUniqueInput[]
    update?: ExpenseEntryUpdateWithWhereUniqueWithoutSubcategoryInput | ExpenseEntryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ExpenseEntryUpdateManyWithWhereWithoutSubcategoryInput | ExpenseEntryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
  }

  export type ExpenseProductUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<ExpenseProductCreateWithoutSubcategoryInput, ExpenseProductUncheckedCreateWithoutSubcategoryInput> | ExpenseProductCreateWithoutSubcategoryInput[] | ExpenseProductUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutSubcategoryInput | ExpenseProductCreateOrConnectWithoutSubcategoryInput[]
    upsert?: ExpenseProductUpsertWithWhereUniqueWithoutSubcategoryInput | ExpenseProductUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: ExpenseProductCreateManySubcategoryInputEnvelope
    set?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    disconnect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    delete?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    connect?: ExpenseProductWhereUniqueInput | ExpenseProductWhereUniqueInput[]
    update?: ExpenseProductUpdateWithWhereUniqueWithoutSubcategoryInput | ExpenseProductUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: ExpenseProductUpdateManyWithWhereWithoutSubcategoryInput | ExpenseProductUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: ExpenseProductScalarWhereInput | ExpenseProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExpense_entriesInput = {
    create?: XOR<UserCreateWithoutExpense_entriesInput, UserUncheckedCreateWithoutExpense_entriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_entriesInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseAccountCreateNestedOneWithoutEntries_fromInput = {
    create?: XOR<ExpenseAccountCreateWithoutEntries_fromInput, ExpenseAccountUncheckedCreateWithoutEntries_fromInput>
    connectOrCreate?: ExpenseAccountCreateOrConnectWithoutEntries_fromInput
    connect?: ExpenseAccountWhereUniqueInput
  }

  export type ExpenseAccountCreateNestedOneWithoutEntries_toInput = {
    create?: XOR<ExpenseAccountCreateWithoutEntries_toInput, ExpenseAccountUncheckedCreateWithoutEntries_toInput>
    connectOrCreate?: ExpenseAccountCreateOrConnectWithoutEntries_toInput
    connect?: ExpenseAccountWhereUniqueInput
  }

  export type ExpenseCategoryCreateNestedOneWithoutEntriesInput = {
    create?: XOR<ExpenseCategoryCreateWithoutEntriesInput, ExpenseCategoryUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutEntriesInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type ExpenseSubcategoryCreateNestedOneWithoutEntriesInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutEntriesInput, ExpenseSubcategoryUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutEntriesInput
    connect?: ExpenseSubcategoryWhereUniqueInput
  }

  export type ExpenseReceiptCreateNestedOneWithoutExpense_entryInput = {
    create?: XOR<ExpenseReceiptCreateWithoutExpense_entryInput, ExpenseReceiptUncheckedCreateWithoutExpense_entryInput>
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutExpense_entryInput
    connect?: ExpenseReceiptWhereUniqueInput
  }

  export type ExpenseReceiptUncheckedCreateNestedOneWithoutExpense_entryInput = {
    create?: XOR<ExpenseReceiptCreateWithoutExpense_entryInput, ExpenseReceiptUncheckedCreateWithoutExpense_entryInput>
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutExpense_entryInput
    connect?: ExpenseReceiptWhereUniqueInput
  }

  export type EnumExpenseEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseEntryType
  }

  export type UserUpdateOneRequiredWithoutExpense_entriesNestedInput = {
    create?: XOR<UserCreateWithoutExpense_entriesInput, UserUncheckedCreateWithoutExpense_entriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_entriesInput
    upsert?: UserUpsertWithoutExpense_entriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpense_entriesInput, UserUpdateWithoutExpense_entriesInput>, UserUncheckedUpdateWithoutExpense_entriesInput>
  }

  export type ExpenseAccountUpdateOneRequiredWithoutEntries_fromNestedInput = {
    create?: XOR<ExpenseAccountCreateWithoutEntries_fromInput, ExpenseAccountUncheckedCreateWithoutEntries_fromInput>
    connectOrCreate?: ExpenseAccountCreateOrConnectWithoutEntries_fromInput
    upsert?: ExpenseAccountUpsertWithoutEntries_fromInput
    connect?: ExpenseAccountWhereUniqueInput
    update?: XOR<XOR<ExpenseAccountUpdateToOneWithWhereWithoutEntries_fromInput, ExpenseAccountUpdateWithoutEntries_fromInput>, ExpenseAccountUncheckedUpdateWithoutEntries_fromInput>
  }

  export type ExpenseAccountUpdateOneWithoutEntries_toNestedInput = {
    create?: XOR<ExpenseAccountCreateWithoutEntries_toInput, ExpenseAccountUncheckedCreateWithoutEntries_toInput>
    connectOrCreate?: ExpenseAccountCreateOrConnectWithoutEntries_toInput
    upsert?: ExpenseAccountUpsertWithoutEntries_toInput
    disconnect?: ExpenseAccountWhereInput | boolean
    delete?: ExpenseAccountWhereInput | boolean
    connect?: ExpenseAccountWhereUniqueInput
    update?: XOR<XOR<ExpenseAccountUpdateToOneWithWhereWithoutEntries_toInput, ExpenseAccountUpdateWithoutEntries_toInput>, ExpenseAccountUncheckedUpdateWithoutEntries_toInput>
  }

  export type ExpenseCategoryUpdateOneWithoutEntriesNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutEntriesInput, ExpenseCategoryUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutEntriesInput
    upsert?: ExpenseCategoryUpsertWithoutEntriesInput
    disconnect?: ExpenseCategoryWhereInput | boolean
    delete?: ExpenseCategoryWhereInput | boolean
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutEntriesInput, ExpenseCategoryUpdateWithoutEntriesInput>, ExpenseCategoryUncheckedUpdateWithoutEntriesInput>
  }

  export type ExpenseSubcategoryUpdateOneWithoutEntriesNestedInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutEntriesInput, ExpenseSubcategoryUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutEntriesInput
    upsert?: ExpenseSubcategoryUpsertWithoutEntriesInput
    disconnect?: ExpenseSubcategoryWhereInput | boolean
    delete?: ExpenseSubcategoryWhereInput | boolean
    connect?: ExpenseSubcategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseSubcategoryUpdateToOneWithWhereWithoutEntriesInput, ExpenseSubcategoryUpdateWithoutEntriesInput>, ExpenseSubcategoryUncheckedUpdateWithoutEntriesInput>
  }

  export type ExpenseReceiptUpdateOneWithoutExpense_entryNestedInput = {
    create?: XOR<ExpenseReceiptCreateWithoutExpense_entryInput, ExpenseReceiptUncheckedCreateWithoutExpense_entryInput>
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutExpense_entryInput
    upsert?: ExpenseReceiptUpsertWithoutExpense_entryInput
    disconnect?: ExpenseReceiptWhereInput | boolean
    delete?: ExpenseReceiptWhereInput | boolean
    connect?: ExpenseReceiptWhereUniqueInput
    update?: XOR<XOR<ExpenseReceiptUpdateToOneWithWhereWithoutExpense_entryInput, ExpenseReceiptUpdateWithoutExpense_entryInput>, ExpenseReceiptUncheckedUpdateWithoutExpense_entryInput>
  }

  export type ExpenseReceiptUncheckedUpdateOneWithoutExpense_entryNestedInput = {
    create?: XOR<ExpenseReceiptCreateWithoutExpense_entryInput, ExpenseReceiptUncheckedCreateWithoutExpense_entryInput>
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutExpense_entryInput
    upsert?: ExpenseReceiptUpsertWithoutExpense_entryInput
    disconnect?: ExpenseReceiptWhereInput | boolean
    delete?: ExpenseReceiptWhereInput | boolean
    connect?: ExpenseReceiptWhereUniqueInput
    update?: XOR<XOR<ExpenseReceiptUpdateToOneWithWhereWithoutExpense_entryInput, ExpenseReceiptUpdateWithoutExpense_entryInput>, ExpenseReceiptUncheckedUpdateWithoutExpense_entryInput>
  }

  export type UserCreateNestedOneWithoutExpense_storesInput = {
    create?: XOR<UserCreateWithoutExpense_storesInput, UserUncheckedCreateWithoutExpense_storesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_storesInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseReceiptCreateNestedManyWithoutStoreInput = {
    create?: XOR<ExpenseReceiptCreateWithoutStoreInput, ExpenseReceiptUncheckedCreateWithoutStoreInput> | ExpenseReceiptCreateWithoutStoreInput[] | ExpenseReceiptUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutStoreInput | ExpenseReceiptCreateOrConnectWithoutStoreInput[]
    createMany?: ExpenseReceiptCreateManyStoreInputEnvelope
    connect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
  }

  export type ExpenseReceiptUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ExpenseReceiptCreateWithoutStoreInput, ExpenseReceiptUncheckedCreateWithoutStoreInput> | ExpenseReceiptCreateWithoutStoreInput[] | ExpenseReceiptUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutStoreInput | ExpenseReceiptCreateOrConnectWithoutStoreInput[]
    createMany?: ExpenseReceiptCreateManyStoreInputEnvelope
    connect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutExpense_storesNestedInput = {
    create?: XOR<UserCreateWithoutExpense_storesInput, UserUncheckedCreateWithoutExpense_storesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_storesInput
    upsert?: UserUpsertWithoutExpense_storesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpense_storesInput, UserUpdateWithoutExpense_storesInput>, UserUncheckedUpdateWithoutExpense_storesInput>
  }

  export type ExpenseReceiptUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ExpenseReceiptCreateWithoutStoreInput, ExpenseReceiptUncheckedCreateWithoutStoreInput> | ExpenseReceiptCreateWithoutStoreInput[] | ExpenseReceiptUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutStoreInput | ExpenseReceiptCreateOrConnectWithoutStoreInput[]
    upsert?: ExpenseReceiptUpsertWithWhereUniqueWithoutStoreInput | ExpenseReceiptUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ExpenseReceiptCreateManyStoreInputEnvelope
    set?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    disconnect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    delete?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    connect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    update?: ExpenseReceiptUpdateWithWhereUniqueWithoutStoreInput | ExpenseReceiptUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ExpenseReceiptUpdateManyWithWhereWithoutStoreInput | ExpenseReceiptUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ExpenseReceiptScalarWhereInput | ExpenseReceiptScalarWhereInput[]
  }

  export type ExpenseReceiptUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ExpenseReceiptCreateWithoutStoreInput, ExpenseReceiptUncheckedCreateWithoutStoreInput> | ExpenseReceiptCreateWithoutStoreInput[] | ExpenseReceiptUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutStoreInput | ExpenseReceiptCreateOrConnectWithoutStoreInput[]
    upsert?: ExpenseReceiptUpsertWithWhereUniqueWithoutStoreInput | ExpenseReceiptUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ExpenseReceiptCreateManyStoreInputEnvelope
    set?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    disconnect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    delete?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    connect?: ExpenseReceiptWhereUniqueInput | ExpenseReceiptWhereUniqueInput[]
    update?: ExpenseReceiptUpdateWithWhereUniqueWithoutStoreInput | ExpenseReceiptUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ExpenseReceiptUpdateManyWithWhereWithoutStoreInput | ExpenseReceiptUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ExpenseReceiptScalarWhereInput | ExpenseReceiptScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExpense_receiptsInput = {
    create?: XOR<UserCreateWithoutExpense_receiptsInput, UserUncheckedCreateWithoutExpense_receiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_receiptsInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseStoreCreateNestedOneWithoutReceiptsInput = {
    create?: XOR<ExpenseStoreCreateWithoutReceiptsInput, ExpenseStoreUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: ExpenseStoreCreateOrConnectWithoutReceiptsInput
    connect?: ExpenseStoreWhereUniqueInput
  }

  export type ExpenseEntryCreateNestedOneWithoutExpense_receiptInput = {
    create?: XOR<ExpenseEntryCreateWithoutExpense_receiptInput, ExpenseEntryUncheckedCreateWithoutExpense_receiptInput>
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutExpense_receiptInput
    connect?: ExpenseEntryWhereUniqueInput
  }

  export type ExpenseReceiptItemCreateNestedManyWithoutReceiptInput = {
    create?: XOR<ExpenseReceiptItemCreateWithoutReceiptInput, ExpenseReceiptItemUncheckedCreateWithoutReceiptInput> | ExpenseReceiptItemCreateWithoutReceiptInput[] | ExpenseReceiptItemUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: ExpenseReceiptItemCreateOrConnectWithoutReceiptInput | ExpenseReceiptItemCreateOrConnectWithoutReceiptInput[]
    createMany?: ExpenseReceiptItemCreateManyReceiptInputEnvelope
    connect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
  }

  export type ExpenseReceiptItemUncheckedCreateNestedManyWithoutReceiptInput = {
    create?: XOR<ExpenseReceiptItemCreateWithoutReceiptInput, ExpenseReceiptItemUncheckedCreateWithoutReceiptInput> | ExpenseReceiptItemCreateWithoutReceiptInput[] | ExpenseReceiptItemUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: ExpenseReceiptItemCreateOrConnectWithoutReceiptInput | ExpenseReceiptItemCreateOrConnectWithoutReceiptInput[]
    createMany?: ExpenseReceiptItemCreateManyReceiptInputEnvelope
    connect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutExpense_receiptsNestedInput = {
    create?: XOR<UserCreateWithoutExpense_receiptsInput, UserUncheckedCreateWithoutExpense_receiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_receiptsInput
    upsert?: UserUpsertWithoutExpense_receiptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpense_receiptsInput, UserUpdateWithoutExpense_receiptsInput>, UserUncheckedUpdateWithoutExpense_receiptsInput>
  }

  export type ExpenseStoreUpdateOneWithoutReceiptsNestedInput = {
    create?: XOR<ExpenseStoreCreateWithoutReceiptsInput, ExpenseStoreUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: ExpenseStoreCreateOrConnectWithoutReceiptsInput
    upsert?: ExpenseStoreUpsertWithoutReceiptsInput
    disconnect?: ExpenseStoreWhereInput | boolean
    delete?: ExpenseStoreWhereInput | boolean
    connect?: ExpenseStoreWhereUniqueInput
    update?: XOR<XOR<ExpenseStoreUpdateToOneWithWhereWithoutReceiptsInput, ExpenseStoreUpdateWithoutReceiptsInput>, ExpenseStoreUncheckedUpdateWithoutReceiptsInput>
  }

  export type ExpenseEntryUpdateOneRequiredWithoutExpense_receiptNestedInput = {
    create?: XOR<ExpenseEntryCreateWithoutExpense_receiptInput, ExpenseEntryUncheckedCreateWithoutExpense_receiptInput>
    connectOrCreate?: ExpenseEntryCreateOrConnectWithoutExpense_receiptInput
    upsert?: ExpenseEntryUpsertWithoutExpense_receiptInput
    connect?: ExpenseEntryWhereUniqueInput
    update?: XOR<XOR<ExpenseEntryUpdateToOneWithWhereWithoutExpense_receiptInput, ExpenseEntryUpdateWithoutExpense_receiptInput>, ExpenseEntryUncheckedUpdateWithoutExpense_receiptInput>
  }

  export type ExpenseReceiptItemUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<ExpenseReceiptItemCreateWithoutReceiptInput, ExpenseReceiptItemUncheckedCreateWithoutReceiptInput> | ExpenseReceiptItemCreateWithoutReceiptInput[] | ExpenseReceiptItemUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: ExpenseReceiptItemCreateOrConnectWithoutReceiptInput | ExpenseReceiptItemCreateOrConnectWithoutReceiptInput[]
    upsert?: ExpenseReceiptItemUpsertWithWhereUniqueWithoutReceiptInput | ExpenseReceiptItemUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: ExpenseReceiptItemCreateManyReceiptInputEnvelope
    set?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    disconnect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    delete?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    connect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    update?: ExpenseReceiptItemUpdateWithWhereUniqueWithoutReceiptInput | ExpenseReceiptItemUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: ExpenseReceiptItemUpdateManyWithWhereWithoutReceiptInput | ExpenseReceiptItemUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: ExpenseReceiptItemScalarWhereInput | ExpenseReceiptItemScalarWhereInput[]
  }

  export type ExpenseReceiptItemUncheckedUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<ExpenseReceiptItemCreateWithoutReceiptInput, ExpenseReceiptItemUncheckedCreateWithoutReceiptInput> | ExpenseReceiptItemCreateWithoutReceiptInput[] | ExpenseReceiptItemUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: ExpenseReceiptItemCreateOrConnectWithoutReceiptInput | ExpenseReceiptItemCreateOrConnectWithoutReceiptInput[]
    upsert?: ExpenseReceiptItemUpsertWithWhereUniqueWithoutReceiptInput | ExpenseReceiptItemUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: ExpenseReceiptItemCreateManyReceiptInputEnvelope
    set?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    disconnect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    delete?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    connect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    update?: ExpenseReceiptItemUpdateWithWhereUniqueWithoutReceiptInput | ExpenseReceiptItemUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: ExpenseReceiptItemUpdateManyWithWhereWithoutReceiptInput | ExpenseReceiptItemUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: ExpenseReceiptItemScalarWhereInput | ExpenseReceiptItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExpense_productsInput = {
    create?: XOR<UserCreateWithoutExpense_productsInput, UserUncheckedCreateWithoutExpense_productsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_productsInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ExpenseCategoryCreateWithoutProductsInput, ExpenseCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutProductsInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type ExpenseSubcategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutProductsInput, ExpenseSubcategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutProductsInput
    connect?: ExpenseSubcategoryWhereUniqueInput
  }

  export type ExpenseReceiptItemCreateNestedManyWithoutProductInput = {
    create?: XOR<ExpenseReceiptItemCreateWithoutProductInput, ExpenseReceiptItemUncheckedCreateWithoutProductInput> | ExpenseReceiptItemCreateWithoutProductInput[] | ExpenseReceiptItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ExpenseReceiptItemCreateOrConnectWithoutProductInput | ExpenseReceiptItemCreateOrConnectWithoutProductInput[]
    createMany?: ExpenseReceiptItemCreateManyProductInputEnvelope
    connect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
  }

  export type ExpenseReceiptItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ExpenseReceiptItemCreateWithoutProductInput, ExpenseReceiptItemUncheckedCreateWithoutProductInput> | ExpenseReceiptItemCreateWithoutProductInput[] | ExpenseReceiptItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ExpenseReceiptItemCreateOrConnectWithoutProductInput | ExpenseReceiptItemCreateOrConnectWithoutProductInput[]
    createMany?: ExpenseReceiptItemCreateManyProductInputEnvelope
    connect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneWithoutExpense_productsNestedInput = {
    create?: XOR<UserCreateWithoutExpense_productsInput, UserUncheckedCreateWithoutExpense_productsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpense_productsInput
    upsert?: UserUpsertWithoutExpense_productsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpense_productsInput, UserUpdateWithoutExpense_productsInput>, UserUncheckedUpdateWithoutExpense_productsInput>
  }

  export type ExpenseCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutProductsInput, ExpenseCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutProductsInput
    upsert?: ExpenseCategoryUpsertWithoutProductsInput
    disconnect?: ExpenseCategoryWhereInput | boolean
    delete?: ExpenseCategoryWhereInput | boolean
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutProductsInput, ExpenseCategoryUpdateWithoutProductsInput>, ExpenseCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ExpenseSubcategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ExpenseSubcategoryCreateWithoutProductsInput, ExpenseSubcategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ExpenseSubcategoryCreateOrConnectWithoutProductsInput
    upsert?: ExpenseSubcategoryUpsertWithoutProductsInput
    disconnect?: ExpenseSubcategoryWhereInput | boolean
    delete?: ExpenseSubcategoryWhereInput | boolean
    connect?: ExpenseSubcategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseSubcategoryUpdateToOneWithWhereWithoutProductsInput, ExpenseSubcategoryUpdateWithoutProductsInput>, ExpenseSubcategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ExpenseReceiptItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<ExpenseReceiptItemCreateWithoutProductInput, ExpenseReceiptItemUncheckedCreateWithoutProductInput> | ExpenseReceiptItemCreateWithoutProductInput[] | ExpenseReceiptItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ExpenseReceiptItemCreateOrConnectWithoutProductInput | ExpenseReceiptItemCreateOrConnectWithoutProductInput[]
    upsert?: ExpenseReceiptItemUpsertWithWhereUniqueWithoutProductInput | ExpenseReceiptItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ExpenseReceiptItemCreateManyProductInputEnvelope
    set?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    disconnect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    delete?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    connect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    update?: ExpenseReceiptItemUpdateWithWhereUniqueWithoutProductInput | ExpenseReceiptItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ExpenseReceiptItemUpdateManyWithWhereWithoutProductInput | ExpenseReceiptItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ExpenseReceiptItemScalarWhereInput | ExpenseReceiptItemScalarWhereInput[]
  }

  export type ExpenseReceiptItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ExpenseReceiptItemCreateWithoutProductInput, ExpenseReceiptItemUncheckedCreateWithoutProductInput> | ExpenseReceiptItemCreateWithoutProductInput[] | ExpenseReceiptItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ExpenseReceiptItemCreateOrConnectWithoutProductInput | ExpenseReceiptItemCreateOrConnectWithoutProductInput[]
    upsert?: ExpenseReceiptItemUpsertWithWhereUniqueWithoutProductInput | ExpenseReceiptItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ExpenseReceiptItemCreateManyProductInputEnvelope
    set?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    disconnect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    delete?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    connect?: ExpenseReceiptItemWhereUniqueInput | ExpenseReceiptItemWhereUniqueInput[]
    update?: ExpenseReceiptItemUpdateWithWhereUniqueWithoutProductInput | ExpenseReceiptItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ExpenseReceiptItemUpdateManyWithWhereWithoutProductInput | ExpenseReceiptItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ExpenseReceiptItemScalarWhereInput | ExpenseReceiptItemScalarWhereInput[]
  }

  export type ExpenseReceiptCreateNestedOneWithoutItemsInput = {
    create?: XOR<ExpenseReceiptCreateWithoutItemsInput, ExpenseReceiptUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutItemsInput
    connect?: ExpenseReceiptWhereUniqueInput
  }

  export type ExpenseProductCreateNestedOneWithoutReceipt_itemsInput = {
    create?: XOR<ExpenseProductCreateWithoutReceipt_itemsInput, ExpenseProductUncheckedCreateWithoutReceipt_itemsInput>
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutReceipt_itemsInput
    connect?: ExpenseProductWhereUniqueInput
  }

  export type ExpenseReceiptUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ExpenseReceiptCreateWithoutItemsInput, ExpenseReceiptUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ExpenseReceiptCreateOrConnectWithoutItemsInput
    upsert?: ExpenseReceiptUpsertWithoutItemsInput
    connect?: ExpenseReceiptWhereUniqueInput
    update?: XOR<XOR<ExpenseReceiptUpdateToOneWithWhereWithoutItemsInput, ExpenseReceiptUpdateWithoutItemsInput>, ExpenseReceiptUncheckedUpdateWithoutItemsInput>
  }

  export type ExpenseProductUpdateOneWithoutReceipt_itemsNestedInput = {
    create?: XOR<ExpenseProductCreateWithoutReceipt_itemsInput, ExpenseProductUncheckedCreateWithoutReceipt_itemsInput>
    connectOrCreate?: ExpenseProductCreateOrConnectWithoutReceipt_itemsInput
    upsert?: ExpenseProductUpsertWithoutReceipt_itemsInput
    disconnect?: ExpenseProductWhereInput | boolean
    delete?: ExpenseProductWhereInput | boolean
    connect?: ExpenseProductWhereUniqueInput
    update?: XOR<XOR<ExpenseProductUpdateToOneWithWhereWithoutReceipt_itemsInput, ExpenseProductUpdateWithoutReceipt_itemsInput>, ExpenseProductUncheckedUpdateWithoutReceipt_itemsInput>
  }

  export type UserCreateNestedOneWithoutMuscle_groupsInput = {
    create?: XOR<UserCreateWithoutMuscle_groupsInput, UserUncheckedCreateWithoutMuscle_groupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMuscle_groupsInput
    connect?: UserWhereUniqueInput
  }

  export type ExerciseCreateNestedManyWithoutMuscle_groupInput = {
    create?: XOR<ExerciseCreateWithoutMuscle_groupInput, ExerciseUncheckedCreateWithoutMuscle_groupInput> | ExerciseCreateWithoutMuscle_groupInput[] | ExerciseUncheckedCreateWithoutMuscle_groupInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutMuscle_groupInput | ExerciseCreateOrConnectWithoutMuscle_groupInput[]
    createMany?: ExerciseCreateManyMuscle_groupInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutMuscle_groupInput = {
    create?: XOR<ExerciseCreateWithoutMuscle_groupInput, ExerciseUncheckedCreateWithoutMuscle_groupInput> | ExerciseCreateWithoutMuscle_groupInput[] | ExerciseUncheckedCreateWithoutMuscle_groupInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutMuscle_groupInput | ExerciseCreateOrConnectWithoutMuscle_groupInput[]
    createMany?: ExerciseCreateManyMuscle_groupInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutMuscle_groupsNestedInput = {
    create?: XOR<UserCreateWithoutMuscle_groupsInput, UserUncheckedCreateWithoutMuscle_groupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMuscle_groupsInput
    upsert?: UserUpsertWithoutMuscle_groupsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMuscle_groupsInput, UserUpdateWithoutMuscle_groupsInput>, UserUncheckedUpdateWithoutMuscle_groupsInput>
  }

  export type ExerciseUpdateManyWithoutMuscle_groupNestedInput = {
    create?: XOR<ExerciseCreateWithoutMuscle_groupInput, ExerciseUncheckedCreateWithoutMuscle_groupInput> | ExerciseCreateWithoutMuscle_groupInput[] | ExerciseUncheckedCreateWithoutMuscle_groupInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutMuscle_groupInput | ExerciseCreateOrConnectWithoutMuscle_groupInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutMuscle_groupInput | ExerciseUpsertWithWhereUniqueWithoutMuscle_groupInput[]
    createMany?: ExerciseCreateManyMuscle_groupInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutMuscle_groupInput | ExerciseUpdateWithWhereUniqueWithoutMuscle_groupInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutMuscle_groupInput | ExerciseUpdateManyWithWhereWithoutMuscle_groupInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutMuscle_groupNestedInput = {
    create?: XOR<ExerciseCreateWithoutMuscle_groupInput, ExerciseUncheckedCreateWithoutMuscle_groupInput> | ExerciseCreateWithoutMuscle_groupInput[] | ExerciseUncheckedCreateWithoutMuscle_groupInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutMuscle_groupInput | ExerciseCreateOrConnectWithoutMuscle_groupInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutMuscle_groupInput | ExerciseUpsertWithWhereUniqueWithoutMuscle_groupInput[]
    createMany?: ExerciseCreateManyMuscle_groupInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutMuscle_groupInput | ExerciseUpdateWithWhereUniqueWithoutMuscle_groupInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutMuscle_groupInput | ExerciseUpdateManyWithWhereWithoutMuscle_groupInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExercisesInput = {
    create?: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExercisesInput
    connect?: UserWhereUniqueInput
  }

  export type MuscleGroupCreateNestedOneWithoutExercisesInput = {
    create?: XOR<MuscleGroupCreateWithoutExercisesInput, MuscleGroupUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: MuscleGroupCreateOrConnectWithoutExercisesInput
    connect?: MuscleGroupWhereUniqueInput
  }

  export type WorkoutEntryCreateNestedManyWithoutExerciseInput = {
    create?: XOR<WorkoutEntryCreateWithoutExerciseInput, WorkoutEntryUncheckedCreateWithoutExerciseInput> | WorkoutEntryCreateWithoutExerciseInput[] | WorkoutEntryUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutExerciseInput | WorkoutEntryCreateOrConnectWithoutExerciseInput[]
    createMany?: WorkoutEntryCreateManyExerciseInputEnvelope
    connect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
  }

  export type WorkoutEntryUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<WorkoutEntryCreateWithoutExerciseInput, WorkoutEntryUncheckedCreateWithoutExerciseInput> | WorkoutEntryCreateWithoutExerciseInput[] | WorkoutEntryUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutExerciseInput | WorkoutEntryCreateOrConnectWithoutExerciseInput[]
    createMany?: WorkoutEntryCreateManyExerciseInputEnvelope
    connect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
  }

  export type EnumExerciseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExerciseType
  }

  export type UserUpdateOneWithoutExercisesNestedInput = {
    create?: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExercisesInput
    upsert?: UserUpsertWithoutExercisesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExercisesInput, UserUpdateWithoutExercisesInput>, UserUncheckedUpdateWithoutExercisesInput>
  }

  export type MuscleGroupUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<MuscleGroupCreateWithoutExercisesInput, MuscleGroupUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: MuscleGroupCreateOrConnectWithoutExercisesInput
    upsert?: MuscleGroupUpsertWithoutExercisesInput
    connect?: MuscleGroupWhereUniqueInput
    update?: XOR<XOR<MuscleGroupUpdateToOneWithWhereWithoutExercisesInput, MuscleGroupUpdateWithoutExercisesInput>, MuscleGroupUncheckedUpdateWithoutExercisesInput>
  }

  export type WorkoutEntryUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<WorkoutEntryCreateWithoutExerciseInput, WorkoutEntryUncheckedCreateWithoutExerciseInput> | WorkoutEntryCreateWithoutExerciseInput[] | WorkoutEntryUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutExerciseInput | WorkoutEntryCreateOrConnectWithoutExerciseInput[]
    upsert?: WorkoutEntryUpsertWithWhereUniqueWithoutExerciseInput | WorkoutEntryUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: WorkoutEntryCreateManyExerciseInputEnvelope
    set?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    disconnect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    delete?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    connect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    update?: WorkoutEntryUpdateWithWhereUniqueWithoutExerciseInput | WorkoutEntryUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: WorkoutEntryUpdateManyWithWhereWithoutExerciseInput | WorkoutEntryUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: WorkoutEntryScalarWhereInput | WorkoutEntryScalarWhereInput[]
  }

  export type WorkoutEntryUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<WorkoutEntryCreateWithoutExerciseInput, WorkoutEntryUncheckedCreateWithoutExerciseInput> | WorkoutEntryCreateWithoutExerciseInput[] | WorkoutEntryUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutExerciseInput | WorkoutEntryCreateOrConnectWithoutExerciseInput[]
    upsert?: WorkoutEntryUpsertWithWhereUniqueWithoutExerciseInput | WorkoutEntryUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: WorkoutEntryCreateManyExerciseInputEnvelope
    set?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    disconnect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    delete?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    connect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    update?: WorkoutEntryUpdateWithWhereUniqueWithoutExerciseInput | WorkoutEntryUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: WorkoutEntryUpdateManyWithWhereWithoutExerciseInput | WorkoutEntryUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: WorkoutEntryScalarWhereInput | WorkoutEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWorkoutsInput = {
    create?: XOR<UserCreateWithoutWorkoutsInput, UserUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkoutEntryCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutEntryCreateWithoutWorkoutInput, WorkoutEntryUncheckedCreateWithoutWorkoutInput> | WorkoutEntryCreateWithoutWorkoutInput[] | WorkoutEntryUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutWorkoutInput | WorkoutEntryCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutEntryCreateManyWorkoutInputEnvelope
    connect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
  }

  export type WorkoutEntryUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutEntryCreateWithoutWorkoutInput, WorkoutEntryUncheckedCreateWithoutWorkoutInput> | WorkoutEntryCreateWithoutWorkoutInput[] | WorkoutEntryUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutWorkoutInput | WorkoutEntryCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutEntryCreateManyWorkoutInputEnvelope
    connect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutWorkoutsNestedInput = {
    create?: XOR<UserCreateWithoutWorkoutsInput, UserUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutsInput
    upsert?: UserUpsertWithoutWorkoutsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkoutsInput, UserUpdateWithoutWorkoutsInput>, UserUncheckedUpdateWithoutWorkoutsInput>
  }

  export type WorkoutEntryUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutEntryCreateWithoutWorkoutInput, WorkoutEntryUncheckedCreateWithoutWorkoutInput> | WorkoutEntryCreateWithoutWorkoutInput[] | WorkoutEntryUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutWorkoutInput | WorkoutEntryCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutEntryUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutEntryUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutEntryCreateManyWorkoutInputEnvelope
    set?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    disconnect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    delete?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    connect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    update?: WorkoutEntryUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutEntryUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutEntryUpdateManyWithWhereWithoutWorkoutInput | WorkoutEntryUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutEntryScalarWhereInput | WorkoutEntryScalarWhereInput[]
  }

  export type WorkoutEntryUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutEntryCreateWithoutWorkoutInput, WorkoutEntryUncheckedCreateWithoutWorkoutInput> | WorkoutEntryCreateWithoutWorkoutInput[] | WorkoutEntryUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutWorkoutInput | WorkoutEntryCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutEntryUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutEntryUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutEntryCreateManyWorkoutInputEnvelope
    set?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    disconnect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    delete?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    connect?: WorkoutEntryWhereUniqueInput | WorkoutEntryWhereUniqueInput[]
    update?: WorkoutEntryUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutEntryUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutEntryUpdateManyWithWhereWithoutWorkoutInput | WorkoutEntryUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutEntryScalarWhereInput | WorkoutEntryScalarWhereInput[]
  }

  export type WorkoutCreateNestedOneWithoutEntriesInput = {
    create?: XOR<WorkoutCreateWithoutEntriesInput, WorkoutUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutEntriesInput
    connect?: WorkoutWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutEntriesInput = {
    create?: XOR<ExerciseCreateWithoutEntriesInput, ExerciseUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutEntriesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type WorkoutSetCreateNestedManyWithoutWorkout_entryInput = {
    create?: XOR<WorkoutSetCreateWithoutWorkout_entryInput, WorkoutSetUncheckedCreateWithoutWorkout_entryInput> | WorkoutSetCreateWithoutWorkout_entryInput[] | WorkoutSetUncheckedCreateWithoutWorkout_entryInput[]
    connectOrCreate?: WorkoutSetCreateOrConnectWithoutWorkout_entryInput | WorkoutSetCreateOrConnectWithoutWorkout_entryInput[]
    createMany?: WorkoutSetCreateManyWorkout_entryInputEnvelope
    connect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
  }

  export type WorkoutSetUncheckedCreateNestedManyWithoutWorkout_entryInput = {
    create?: XOR<WorkoutSetCreateWithoutWorkout_entryInput, WorkoutSetUncheckedCreateWithoutWorkout_entryInput> | WorkoutSetCreateWithoutWorkout_entryInput[] | WorkoutSetUncheckedCreateWithoutWorkout_entryInput[]
    connectOrCreate?: WorkoutSetCreateOrConnectWithoutWorkout_entryInput | WorkoutSetCreateOrConnectWithoutWorkout_entryInput[]
    createMany?: WorkoutSetCreateManyWorkout_entryInputEnvelope
    connect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
  }

  export type WorkoutUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<WorkoutCreateWithoutEntriesInput, WorkoutUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutEntriesInput
    upsert?: WorkoutUpsertWithoutEntriesInput
    connect?: WorkoutWhereUniqueInput
    update?: XOR<XOR<WorkoutUpdateToOneWithWhereWithoutEntriesInput, WorkoutUpdateWithoutEntriesInput>, WorkoutUncheckedUpdateWithoutEntriesInput>
  }

  export type ExerciseUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<ExerciseCreateWithoutEntriesInput, ExerciseUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutEntriesInput
    upsert?: ExerciseUpsertWithoutEntriesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutEntriesInput, ExerciseUpdateWithoutEntriesInput>, ExerciseUncheckedUpdateWithoutEntriesInput>
  }

  export type WorkoutSetUpdateManyWithoutWorkout_entryNestedInput = {
    create?: XOR<WorkoutSetCreateWithoutWorkout_entryInput, WorkoutSetUncheckedCreateWithoutWorkout_entryInput> | WorkoutSetCreateWithoutWorkout_entryInput[] | WorkoutSetUncheckedCreateWithoutWorkout_entryInput[]
    connectOrCreate?: WorkoutSetCreateOrConnectWithoutWorkout_entryInput | WorkoutSetCreateOrConnectWithoutWorkout_entryInput[]
    upsert?: WorkoutSetUpsertWithWhereUniqueWithoutWorkout_entryInput | WorkoutSetUpsertWithWhereUniqueWithoutWorkout_entryInput[]
    createMany?: WorkoutSetCreateManyWorkout_entryInputEnvelope
    set?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    disconnect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    delete?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    connect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    update?: WorkoutSetUpdateWithWhereUniqueWithoutWorkout_entryInput | WorkoutSetUpdateWithWhereUniqueWithoutWorkout_entryInput[]
    updateMany?: WorkoutSetUpdateManyWithWhereWithoutWorkout_entryInput | WorkoutSetUpdateManyWithWhereWithoutWorkout_entryInput[]
    deleteMany?: WorkoutSetScalarWhereInput | WorkoutSetScalarWhereInput[]
  }

  export type WorkoutSetUncheckedUpdateManyWithoutWorkout_entryNestedInput = {
    create?: XOR<WorkoutSetCreateWithoutWorkout_entryInput, WorkoutSetUncheckedCreateWithoutWorkout_entryInput> | WorkoutSetCreateWithoutWorkout_entryInput[] | WorkoutSetUncheckedCreateWithoutWorkout_entryInput[]
    connectOrCreate?: WorkoutSetCreateOrConnectWithoutWorkout_entryInput | WorkoutSetCreateOrConnectWithoutWorkout_entryInput[]
    upsert?: WorkoutSetUpsertWithWhereUniqueWithoutWorkout_entryInput | WorkoutSetUpsertWithWhereUniqueWithoutWorkout_entryInput[]
    createMany?: WorkoutSetCreateManyWorkout_entryInputEnvelope
    set?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    disconnect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    delete?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    connect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    update?: WorkoutSetUpdateWithWhereUniqueWithoutWorkout_entryInput | WorkoutSetUpdateWithWhereUniqueWithoutWorkout_entryInput[]
    updateMany?: WorkoutSetUpdateManyWithWhereWithoutWorkout_entryInput | WorkoutSetUpdateManyWithWhereWithoutWorkout_entryInput[]
    deleteMany?: WorkoutSetScalarWhereInput | WorkoutSetScalarWhereInput[]
  }

  export type WorkoutEntryCreateNestedOneWithoutSetsInput = {
    create?: XOR<WorkoutEntryCreateWithoutSetsInput, WorkoutEntryUncheckedCreateWithoutSetsInput>
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutSetsInput
    connect?: WorkoutEntryWhereUniqueInput
  }

  export type WorkoutEntryUpdateOneRequiredWithoutSetsNestedInput = {
    create?: XOR<WorkoutEntryCreateWithoutSetsInput, WorkoutEntryUncheckedCreateWithoutSetsInput>
    connectOrCreate?: WorkoutEntryCreateOrConnectWithoutSetsInput
    upsert?: WorkoutEntryUpsertWithoutSetsInput
    connect?: WorkoutEntryWhereUniqueInput
    update?: XOR<XOR<WorkoutEntryUpdateToOneWithWhereWithoutSetsInput, WorkoutEntryUpdateWithoutSetsInput>, WorkoutEntryUncheckedUpdateWithoutSetsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAuthRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthRole | EnumAuthRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AuthRole[] | ListEnumAuthRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthRole[] | ListEnumAuthRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthRoleFilter<$PrismaModel> | $Enums.AuthRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAuthRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthRole | EnumAuthRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AuthRole[] | ListEnumAuthRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthRole[] | ListEnumAuthRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthRoleWithAggregatesFilter<$PrismaModel> | $Enums.AuthRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthRoleFilter<$PrismaModel>
    _max?: NestedEnumAuthRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumScheduleDayFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleDay | EnumScheduleDayFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleDay[] | ListEnumScheduleDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleDay[] | ListEnumScheduleDayFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleDayFilter<$PrismaModel> | $Enums.ScheduleDay
  }

  export type NestedEnumScheduleDayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleDay | EnumScheduleDayFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleDay[] | ListEnumScheduleDayFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleDay[] | ListEnumScheduleDayFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleDayWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleDay
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleDayFilter<$PrismaModel>
    _max?: NestedEnumScheduleDayFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumActivityRepeatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityRepeatType | EnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityRepeatType[] | ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityRepeatType[] | ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityRepeatTypeFilter<$PrismaModel> | $Enums.ActivityRepeatType
  }

  export type NestedEnumFrequencyPeriodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FrequencyPeriod | EnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.FrequencyPeriod[] | ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FrequencyPeriod[] | ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFrequencyPeriodNullableFilter<$PrismaModel> | $Enums.FrequencyPeriod | null
  }

  export type NestedEnumActivityTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetType | EnumActivityTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTargetTypeFilter<$PrismaModel> | $Enums.ActivityTargetType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumActivityTargetUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetUnit | EnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActivityTargetUnit[] | ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActivityTargetUnit[] | ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActivityTargetUnitNullableFilter<$PrismaModel> | $Enums.ActivityTargetUnit | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumActivityRepeatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityRepeatType | EnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityRepeatType[] | ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityRepeatType[] | ListEnumActivityRepeatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityRepeatTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityRepeatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityRepeatTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityRepeatTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumFrequencyPeriodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FrequencyPeriod | EnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    in?: $Enums.FrequencyPeriod[] | ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FrequencyPeriod[] | ListEnumFrequencyPeriodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFrequencyPeriodNullableWithAggregatesFilter<$PrismaModel> | $Enums.FrequencyPeriod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFrequencyPeriodNullableFilter<$PrismaModel>
    _max?: NestedEnumFrequencyPeriodNullableFilter<$PrismaModel>
  }

  export type NestedEnumActivityTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetType | EnumActivityTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTargetTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumActivityTargetUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetUnit | EnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.ActivityTargetUnit[] | ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ActivityTargetUnit[] | ListEnumActivityTargetUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumActivityTargetUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.ActivityTargetUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumActivityTargetUnitNullableFilter<$PrismaModel>
    _max?: NestedEnumActivityTargetUnitNullableFilter<$PrismaModel>
  }

  export type NestedEnumOccurrenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceStatus | EnumOccurrenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceStatusFilter<$PrismaModel> | $Enums.OccurrenceStatus
  }

  export type NestedEnumOccurrenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceStatus | EnumOccurrenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.OccurrenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccurrenceStatusFilter<$PrismaModel>
    _max?: NestedEnumOccurrenceStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumExpenseEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseEntryType | EnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseEntryType[] | ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseEntryType[] | ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseEntryTypeFilter<$PrismaModel> | $Enums.ExpenseEntryType
  }

  export type NestedEnumExpenseEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseEntryType | EnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseEntryType[] | ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseEntryType[] | ListEnumExpenseEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseEntryTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumExerciseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeFilter<$PrismaModel> | $Enums.ExerciseType
  }

  export type NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseType | EnumExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseType[] | ListEnumExerciseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseTypeFilter<$PrismaModel>
    _max?: NestedEnumExerciseTypeFilter<$PrismaModel>
  }

  export type ActivityCreateWithoutUserInput = {
    uuid?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutActivityInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutActivityInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleSlotCreateWithoutUserInput = {
    uuid?: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutSchedule_slotsInput
  }

  export type ScheduleSlotUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    activity_uuid: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleSlotCreateOrConnectWithoutUserInput = {
    where: ScheduleSlotWhereUniqueInput
    create: XOR<ScheduleSlotCreateWithoutUserInput, ScheduleSlotUncheckedCreateWithoutUserInput>
  }

  export type ScheduleSlotCreateManyUserInputEnvelope = {
    data: ScheduleSlotCreateManyUserInput | ScheduleSlotCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityScheduleCreateWithoutUserInput = {
    uuid?: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_schedulesInput
    weekdays?: ActivityScheduleWeekdayCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    activity_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateUncheckedCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleCreateOrConnectWithoutUserInput = {
    where: ActivityScheduleWhereUniqueInput
    create: XOR<ActivityScheduleCreateWithoutUserInput, ActivityScheduleUncheckedCreateWithoutUserInput>
  }

  export type ActivityScheduleCreateManyUserInputEnvelope = {
    data: ActivityScheduleCreateManyUserInput | ActivityScheduleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutUserInput = {
    uuid?: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_logsInput
    schedule: ActivityScheduleCreateNestedOneWithoutLogsInput
    occurrence: ActivityOccurrenceCreateNestedOneWithoutLogInput
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    activity_uuid: string
    schedule_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityOccurrenceCreateWithoutUserInput = {
    uuid?: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_occurrencesInput
    schedule: ActivityScheduleCreateNestedOneWithoutOccurrencesInput
    log?: ActivityLogCreateNestedOneWithoutOccurrenceInput
  }

  export type ActivityOccurrenceUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    activity_uuid: string
    schedule_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    log?: ActivityLogUncheckedCreateNestedOneWithoutOccurrenceInput
  }

  export type ActivityOccurrenceCreateOrConnectWithoutUserInput = {
    where: ActivityOccurrenceWhereUniqueInput
    create: XOR<ActivityOccurrenceCreateWithoutUserInput, ActivityOccurrenceUncheckedCreateWithoutUserInput>
  }

  export type ActivityOccurrenceCreateManyUserInputEnvelope = {
    data: ActivityOccurrenceCreateManyUserInput | ActivityOccurrenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseAccountCreateWithoutUserInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    entries_from?: ExpenseEntryCreateNestedManyWithoutFrom_accountInput
    entries_to?: ExpenseEntryCreateNestedManyWithoutTo_accountInput
  }

  export type ExpenseAccountUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    entries_from?: ExpenseEntryUncheckedCreateNestedManyWithoutFrom_accountInput
    entries_to?: ExpenseEntryUncheckedCreateNestedManyWithoutTo_accountInput
  }

  export type ExpenseAccountCreateOrConnectWithoutUserInput = {
    where: ExpenseAccountWhereUniqueInput
    create: XOR<ExpenseAccountCreateWithoutUserInput, ExpenseAccountUncheckedCreateWithoutUserInput>
  }

  export type ExpenseAccountCreateManyUserInputEnvelope = {
    data: ExpenseAccountCreateManyUserInput | ExpenseAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseEntryCreateWithoutUserInput = {
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    from_account: ExpenseAccountCreateNestedOneWithoutEntries_fromInput
    to_account?: ExpenseAccountCreateNestedOneWithoutEntries_toInput
    category?: ExpenseCategoryCreateNestedOneWithoutEntriesInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutEntriesInput
    expense_receipt?: ExpenseReceiptCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    expense_receipt?: ExpenseReceiptUncheckedCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryCreateOrConnectWithoutUserInput = {
    where: ExpenseEntryWhereUniqueInput
    create: XOR<ExpenseEntryCreateWithoutUserInput, ExpenseEntryUncheckedCreateWithoutUserInput>
  }

  export type ExpenseEntryCreateManyUserInputEnvelope = {
    data: ExpenseEntryCreateManyUserInput | ExpenseEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCategoryCreateWithoutUserInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutCategoryInput
    entries?: ExpenseEntryCreateNestedManyWithoutCategoryInput
    products?: ExpenseProductCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    entries?: ExpenseEntryUncheckedCreateNestedManyWithoutCategoryInput
    products?: ExpenseProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutUserInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutUserInput, ExpenseCategoryUncheckedCreateWithoutUserInput>
  }

  export type ExpenseCategoryCreateManyUserInputEnvelope = {
    data: ExpenseCategoryCreateManyUserInput | ExpenseCategoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseSubcategoryCreateWithoutUserInput = {
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    category: ExpenseCategoryCreateNestedOneWithoutSubcategoriesInput
    entries?: ExpenseEntryCreateNestedManyWithoutSubcategoryInput
    products?: ExpenseProductCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    category_uuid: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entries?: ExpenseEntryUncheckedCreateNestedManyWithoutSubcategoryInput
    products?: ExpenseProductUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryCreateOrConnectWithoutUserInput = {
    where: ExpenseSubcategoryWhereUniqueInput
    create: XOR<ExpenseSubcategoryCreateWithoutUserInput, ExpenseSubcategoryUncheckedCreateWithoutUserInput>
  }

  export type ExpenseSubcategoryCreateManyUserInputEnvelope = {
    data: ExpenseSubcategoryCreateManyUserInput | ExpenseSubcategoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseReceiptCreateWithoutUserInput = {
    uuid?: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    store?: ExpenseStoreCreateNestedOneWithoutReceiptsInput
    expense_entry: ExpenseEntryCreateNestedOneWithoutExpense_receiptInput
    items?: ExpenseReceiptItemCreateNestedManyWithoutReceiptInput
  }

  export type ExpenseReceiptUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    store_uuid?: string | null
    expense_entry_uuid: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    items?: ExpenseReceiptItemUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type ExpenseReceiptCreateOrConnectWithoutUserInput = {
    where: ExpenseReceiptWhereUniqueInput
    create: XOR<ExpenseReceiptCreateWithoutUserInput, ExpenseReceiptUncheckedCreateWithoutUserInput>
  }

  export type ExpenseReceiptCreateManyUserInputEnvelope = {
    data: ExpenseReceiptCreateManyUserInput | ExpenseReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseStoreCreateWithoutUserInput = {
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    receipts?: ExpenseReceiptCreateNestedManyWithoutStoreInput
  }

  export type ExpenseStoreUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutStoreInput
  }

  export type ExpenseStoreCreateOrConnectWithoutUserInput = {
    where: ExpenseStoreWhereUniqueInput
    create: XOR<ExpenseStoreCreateWithoutUserInput, ExpenseStoreUncheckedCreateWithoutUserInput>
  }

  export type ExpenseStoreCreateManyUserInputEnvelope = {
    data: ExpenseStoreCreateManyUserInput | ExpenseStoreCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseProductCreateWithoutUserInput = {
    uuid?: string
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    category?: ExpenseCategoryCreateNestedOneWithoutProductsInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutProductsInput
    receipt_items?: ExpenseReceiptItemCreateNestedManyWithoutProductInput
  }

  export type ExpenseProductUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    receipt_items?: ExpenseReceiptItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ExpenseProductCreateOrConnectWithoutUserInput = {
    where: ExpenseProductWhereUniqueInput
    create: XOR<ExpenseProductCreateWithoutUserInput, ExpenseProductUncheckedCreateWithoutUserInput>
  }

  export type ExpenseProductCreateManyUserInputEnvelope = {
    data: ExpenseProductCreateManyUserInput | ExpenseProductCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MuscleGroupCreateWithoutUserInput = {
    uuid?: string
    name: string
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    exercises?: ExerciseCreateNestedManyWithoutMuscle_groupInput
  }

  export type MuscleGroupUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    name: string
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutMuscle_groupInput
  }

  export type MuscleGroupCreateOrConnectWithoutUserInput = {
    where: MuscleGroupWhereUniqueInput
    create: XOR<MuscleGroupCreateWithoutUserInput, MuscleGroupUncheckedCreateWithoutUserInput>
  }

  export type MuscleGroupCreateManyUserInputEnvelope = {
    data: MuscleGroupCreateManyUserInput | MuscleGroupCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutUserInput = {
    uuid?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
    muscle_group: MuscleGroupCreateNestedOneWithoutExercisesInput
    entries?: WorkoutEntryCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    muscle_group_uuid: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
    entries?: WorkoutEntryUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutUserInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput>
  }

  export type ExerciseCreateManyUserInputEnvelope = {
    data: ExerciseCreateManyUserInput | ExerciseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutCreateWithoutUserInput = {
    uuid?: string
    name?: string | null
    notes?: string | null
    started_at?: Date | string
    finished_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    entries?: WorkoutEntryCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    name?: string | null
    notes?: string | null
    started_at?: Date | string
    finished_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    entries?: WorkoutEntryUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutUserInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutUserInput, WorkoutUncheckedCreateWithoutUserInput>
  }

  export type WorkoutCreateManyUserInputEnvelope = {
    data: WorkoutCreateManyUserInput | WorkoutCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: IntFilter<"Activity"> | number
    uuid?: StringFilter<"Activity"> | string
    user_uuid?: StringFilter<"Activity"> | string
    name?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    icon?: StringNullableFilter<"Activity"> | string | null
    color?: StringNullableFilter<"Activity"> | string | null
    visible?: BoolFilter<"Activity"> | boolean
    created_at?: DateTimeFilter<"Activity"> | Date | string
    updated_at?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ScheduleSlotUpsertWithWhereUniqueWithoutUserInput = {
    where: ScheduleSlotWhereUniqueInput
    update: XOR<ScheduleSlotUpdateWithoutUserInput, ScheduleSlotUncheckedUpdateWithoutUserInput>
    create: XOR<ScheduleSlotCreateWithoutUserInput, ScheduleSlotUncheckedCreateWithoutUserInput>
  }

  export type ScheduleSlotUpdateWithWhereUniqueWithoutUserInput = {
    where: ScheduleSlotWhereUniqueInput
    data: XOR<ScheduleSlotUpdateWithoutUserInput, ScheduleSlotUncheckedUpdateWithoutUserInput>
  }

  export type ScheduleSlotUpdateManyWithWhereWithoutUserInput = {
    where: ScheduleSlotScalarWhereInput
    data: XOR<ScheduleSlotUpdateManyMutationInput, ScheduleSlotUncheckedUpdateManyWithoutUserInput>
  }

  export type ScheduleSlotScalarWhereInput = {
    AND?: ScheduleSlotScalarWhereInput | ScheduleSlotScalarWhereInput[]
    OR?: ScheduleSlotScalarWhereInput[]
    NOT?: ScheduleSlotScalarWhereInput | ScheduleSlotScalarWhereInput[]
    id?: IntFilter<"ScheduleSlot"> | number
    uuid?: StringFilter<"ScheduleSlot"> | string
    user_uuid?: StringFilter<"ScheduleSlot"> | string
    activity_uuid?: StringFilter<"ScheduleSlot"> | string
    day?: EnumScheduleDayFilter<"ScheduleSlot"> | $Enums.ScheduleDay
    start_time?: StringFilter<"ScheduleSlot"> | string
    end_time?: StringFilter<"ScheduleSlot"> | string
    created_at?: DateTimeFilter<"ScheduleSlot"> | Date | string
    updated_at?: DateTimeFilter<"ScheduleSlot"> | Date | string
  }

  export type ActivityScheduleUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityScheduleWhereUniqueInput
    update: XOR<ActivityScheduleUpdateWithoutUserInput, ActivityScheduleUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityScheduleCreateWithoutUserInput, ActivityScheduleUncheckedCreateWithoutUserInput>
  }

  export type ActivityScheduleUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityScheduleWhereUniqueInput
    data: XOR<ActivityScheduleUpdateWithoutUserInput, ActivityScheduleUncheckedUpdateWithoutUserInput>
  }

  export type ActivityScheduleUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScheduleScalarWhereInput
    data: XOR<ActivityScheduleUpdateManyMutationInput, ActivityScheduleUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScheduleScalarWhereInput = {
    AND?: ActivityScheduleScalarWhereInput | ActivityScheduleScalarWhereInput[]
    OR?: ActivityScheduleScalarWhereInput[]
    NOT?: ActivityScheduleScalarWhereInput | ActivityScheduleScalarWhereInput[]
    id?: IntFilter<"ActivitySchedule"> | number
    uuid?: StringFilter<"ActivitySchedule"> | string
    user_uuid?: StringFilter<"ActivitySchedule"> | string
    activity_uuid?: StringFilter<"ActivitySchedule"> | string
    valid_from?: DateTimeFilter<"ActivitySchedule"> | Date | string
    valid_until?: DateTimeNullableFilter<"ActivitySchedule"> | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFilter<"ActivitySchedule"> | $Enums.ActivityRepeatType
    interval_days?: IntNullableFilter<"ActivitySchedule"> | number | null
    time_of_day?: StringNullableFilter<"ActivitySchedule"> | string | null
    frequency_value?: IntNullableFilter<"ActivitySchedule"> | number | null
    frequency_period?: EnumFrequencyPeriodNullableFilter<"ActivitySchedule"> | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFilter<"ActivitySchedule"> | $Enums.ActivityTargetType
    target_value?: FloatNullableFilter<"ActivitySchedule"> | number | null
    target_unit?: EnumActivityTargetUnitNullableFilter<"ActivitySchedule"> | $Enums.ActivityTargetUnit | null
    target_unit_label?: StringNullableFilter<"ActivitySchedule"> | string | null
    is_active?: BoolFilter<"ActivitySchedule"> | boolean
    created_at?: DateTimeFilter<"ActivitySchedule"> | Date | string
    updated_at?: DateTimeFilter<"ActivitySchedule"> | Date | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    uuid?: StringFilter<"ActivityLog"> | string
    user_uuid?: StringFilter<"ActivityLog"> | string
    activity_uuid?: StringFilter<"ActivityLog"> | string
    schedule_uuid?: StringFilter<"ActivityLog"> | string
    occurrence_uuid?: StringFilter<"ActivityLog"> | string
    snapshot_target_type?: EnumActivityTargetTypeFilter<"ActivityLog"> | $Enums.ActivityTargetType
    snapshot_target_value?: FloatNullableFilter<"ActivityLog"> | number | null
    snapshot_target_unit?: EnumActivityTargetUnitNullableFilter<"ActivityLog"> | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: StringNullableFilter<"ActivityLog"> | string | null
    value?: FloatNullableFilter<"ActivityLog"> | number | null
    completed?: BoolFilter<"ActivityLog"> | boolean
    completed_at?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
    skipped?: BoolFilter<"ActivityLog"> | boolean
    skip_reason?: StringNullableFilter<"ActivityLog"> | string | null
    notes?: StringNullableFilter<"ActivityLog"> | string | null
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
    updated_at?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type ActivityOccurrenceUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityOccurrenceWhereUniqueInput
    update: XOR<ActivityOccurrenceUpdateWithoutUserInput, ActivityOccurrenceUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityOccurrenceCreateWithoutUserInput, ActivityOccurrenceUncheckedCreateWithoutUserInput>
  }

  export type ActivityOccurrenceUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityOccurrenceWhereUniqueInput
    data: XOR<ActivityOccurrenceUpdateWithoutUserInput, ActivityOccurrenceUncheckedUpdateWithoutUserInput>
  }

  export type ActivityOccurrenceUpdateManyWithWhereWithoutUserInput = {
    where: ActivityOccurrenceScalarWhereInput
    data: XOR<ActivityOccurrenceUpdateManyMutationInput, ActivityOccurrenceUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityOccurrenceScalarWhereInput = {
    AND?: ActivityOccurrenceScalarWhereInput | ActivityOccurrenceScalarWhereInput[]
    OR?: ActivityOccurrenceScalarWhereInput[]
    NOT?: ActivityOccurrenceScalarWhereInput | ActivityOccurrenceScalarWhereInput[]
    id?: IntFilter<"ActivityOccurrence"> | number
    uuid?: StringFilter<"ActivityOccurrence"> | string
    user_uuid?: StringFilter<"ActivityOccurrence"> | string
    activity_uuid?: StringFilter<"ActivityOccurrence"> | string
    schedule_uuid?: StringFilter<"ActivityOccurrence"> | string
    scheduled_for?: DateTimeFilter<"ActivityOccurrence"> | Date | string
    status?: EnumOccurrenceStatusFilter<"ActivityOccurrence"> | $Enums.OccurrenceStatus
    created_at?: DateTimeFilter<"ActivityOccurrence"> | Date | string
    updated_at?: DateTimeFilter<"ActivityOccurrence"> | Date | string
  }

  export type ExpenseAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseAccountWhereUniqueInput
    update: XOR<ExpenseAccountUpdateWithoutUserInput, ExpenseAccountUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseAccountCreateWithoutUserInput, ExpenseAccountUncheckedCreateWithoutUserInput>
  }

  export type ExpenseAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseAccountWhereUniqueInput
    data: XOR<ExpenseAccountUpdateWithoutUserInput, ExpenseAccountUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseAccountUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseAccountScalarWhereInput
    data: XOR<ExpenseAccountUpdateManyMutationInput, ExpenseAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseAccountScalarWhereInput = {
    AND?: ExpenseAccountScalarWhereInput | ExpenseAccountScalarWhereInput[]
    OR?: ExpenseAccountScalarWhereInput[]
    NOT?: ExpenseAccountScalarWhereInput | ExpenseAccountScalarWhereInput[]
    id?: IntFilter<"ExpenseAccount"> | number
    uuid?: StringFilter<"ExpenseAccount"> | string
    user_uuid?: StringFilter<"ExpenseAccount"> | string
    name?: StringFilter<"ExpenseAccount"> | string
    icon?: StringNullableFilter<"ExpenseAccount"> | string | null
    color?: StringNullableFilter<"ExpenseAccount"> | string | null
    balance?: DecimalFilter<"ExpenseAccount"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseAccount"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseAccount"> | Date | string
  }

  export type ExpenseEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseEntryWhereUniqueInput
    update: XOR<ExpenseEntryUpdateWithoutUserInput, ExpenseEntryUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseEntryCreateWithoutUserInput, ExpenseEntryUncheckedCreateWithoutUserInput>
  }

  export type ExpenseEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseEntryWhereUniqueInput
    data: XOR<ExpenseEntryUpdateWithoutUserInput, ExpenseEntryUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseEntryUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseEntryScalarWhereInput
    data: XOR<ExpenseEntryUpdateManyMutationInput, ExpenseEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseEntryScalarWhereInput = {
    AND?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
    OR?: ExpenseEntryScalarWhereInput[]
    NOT?: ExpenseEntryScalarWhereInput | ExpenseEntryScalarWhereInput[]
    id?: IntFilter<"ExpenseEntry"> | number
    uuid?: StringFilter<"ExpenseEntry"> | string
    user_uuid?: StringFilter<"ExpenseEntry"> | string
    type?: EnumExpenseEntryTypeFilter<"ExpenseEntry"> | $Enums.ExpenseEntryType
    amount?: DecimalFilter<"ExpenseEntry"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"ExpenseEntry"> | string | null
    from_account_uuid?: StringFilter<"ExpenseEntry"> | string
    to_account_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    category_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    subcategory_uuid?: StringNullableFilter<"ExpenseEntry"> | string | null
    entry_date?: DateTimeFilter<"ExpenseEntry"> | Date | string
    created_at?: DateTimeFilter<"ExpenseEntry"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseEntry"> | Date | string
  }

  export type ExpenseCategoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseCategoryWhereUniqueInput
    update: XOR<ExpenseCategoryUpdateWithoutUserInput, ExpenseCategoryUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseCategoryCreateWithoutUserInput, ExpenseCategoryUncheckedCreateWithoutUserInput>
  }

  export type ExpenseCategoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseCategoryWhereUniqueInput
    data: XOR<ExpenseCategoryUpdateWithoutUserInput, ExpenseCategoryUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseCategoryUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseCategoryScalarWhereInput
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseCategoryScalarWhereInput = {
    AND?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    OR?: ExpenseCategoryScalarWhereInput[]
    NOT?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    id?: IntFilter<"ExpenseCategory"> | number
    uuid?: StringFilter<"ExpenseCategory"> | string
    user_uuid?: StringNullableFilter<"ExpenseCategory"> | string | null
    name?: StringFilter<"ExpenseCategory"> | string
    icon?: StringNullableFilter<"ExpenseCategory"> | string | null
    color?: StringNullableFilter<"ExpenseCategory"> | string | null
    created_at?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseCategory"> | Date | string
  }

  export type ExpenseSubcategoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseSubcategoryWhereUniqueInput
    update: XOR<ExpenseSubcategoryUpdateWithoutUserInput, ExpenseSubcategoryUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseSubcategoryCreateWithoutUserInput, ExpenseSubcategoryUncheckedCreateWithoutUserInput>
  }

  export type ExpenseSubcategoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseSubcategoryWhereUniqueInput
    data: XOR<ExpenseSubcategoryUpdateWithoutUserInput, ExpenseSubcategoryUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseSubcategoryUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseSubcategoryScalarWhereInput
    data: XOR<ExpenseSubcategoryUpdateManyMutationInput, ExpenseSubcategoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseSubcategoryScalarWhereInput = {
    AND?: ExpenseSubcategoryScalarWhereInput | ExpenseSubcategoryScalarWhereInput[]
    OR?: ExpenseSubcategoryScalarWhereInput[]
    NOT?: ExpenseSubcategoryScalarWhereInput | ExpenseSubcategoryScalarWhereInput[]
    id?: IntFilter<"ExpenseSubcategory"> | number
    uuid?: StringFilter<"ExpenseSubcategory"> | string
    user_uuid?: StringNullableFilter<"ExpenseSubcategory"> | string | null
    category_uuid?: StringFilter<"ExpenseSubcategory"> | string
    name?: StringFilter<"ExpenseSubcategory"> | string
    created_at?: DateTimeFilter<"ExpenseSubcategory"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseSubcategory"> | Date | string
  }

  export type ExpenseReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseReceiptWhereUniqueInput
    update: XOR<ExpenseReceiptUpdateWithoutUserInput, ExpenseReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseReceiptCreateWithoutUserInput, ExpenseReceiptUncheckedCreateWithoutUserInput>
  }

  export type ExpenseReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseReceiptWhereUniqueInput
    data: XOR<ExpenseReceiptUpdateWithoutUserInput, ExpenseReceiptUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseReceiptUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseReceiptScalarWhereInput
    data: XOR<ExpenseReceiptUpdateManyMutationInput, ExpenseReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseReceiptScalarWhereInput = {
    AND?: ExpenseReceiptScalarWhereInput | ExpenseReceiptScalarWhereInput[]
    OR?: ExpenseReceiptScalarWhereInput[]
    NOT?: ExpenseReceiptScalarWhereInput | ExpenseReceiptScalarWhereInput[]
    id?: IntFilter<"ExpenseReceipt"> | number
    uuid?: StringFilter<"ExpenseReceipt"> | string
    user_uuid?: StringFilter<"ExpenseReceipt"> | string
    store_uuid?: StringNullableFilter<"ExpenseReceipt"> | string | null
    expense_entry_uuid?: StringFilter<"ExpenseReceipt"> | string
    receipt_date?: DateTimeFilter<"ExpenseReceipt"> | Date | string
    total_amount?: DecimalFilter<"ExpenseReceipt"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseReceipt"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseReceipt"> | Date | string
  }

  export type ExpenseStoreUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseStoreWhereUniqueInput
    update: XOR<ExpenseStoreUpdateWithoutUserInput, ExpenseStoreUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseStoreCreateWithoutUserInput, ExpenseStoreUncheckedCreateWithoutUserInput>
  }

  export type ExpenseStoreUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseStoreWhereUniqueInput
    data: XOR<ExpenseStoreUpdateWithoutUserInput, ExpenseStoreUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseStoreUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseStoreScalarWhereInput
    data: XOR<ExpenseStoreUpdateManyMutationInput, ExpenseStoreUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseStoreScalarWhereInput = {
    AND?: ExpenseStoreScalarWhereInput | ExpenseStoreScalarWhereInput[]
    OR?: ExpenseStoreScalarWhereInput[]
    NOT?: ExpenseStoreScalarWhereInput | ExpenseStoreScalarWhereInput[]
    id?: IntFilter<"ExpenseStore"> | number
    uuid?: StringFilter<"ExpenseStore"> | string
    user_uuid?: StringNullableFilter<"ExpenseStore"> | string | null
    name?: StringFilter<"ExpenseStore"> | string
    created_at?: DateTimeFilter<"ExpenseStore"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseStore"> | Date | string
  }

  export type ExpenseProductUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseProductWhereUniqueInput
    update: XOR<ExpenseProductUpdateWithoutUserInput, ExpenseProductUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseProductCreateWithoutUserInput, ExpenseProductUncheckedCreateWithoutUserInput>
  }

  export type ExpenseProductUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseProductWhereUniqueInput
    data: XOR<ExpenseProductUpdateWithoutUserInput, ExpenseProductUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseProductUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseProductScalarWhereInput
    data: XOR<ExpenseProductUpdateManyMutationInput, ExpenseProductUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseProductScalarWhereInput = {
    AND?: ExpenseProductScalarWhereInput | ExpenseProductScalarWhereInput[]
    OR?: ExpenseProductScalarWhereInput[]
    NOT?: ExpenseProductScalarWhereInput | ExpenseProductScalarWhereInput[]
    id?: IntFilter<"ExpenseProduct"> | number
    uuid?: StringFilter<"ExpenseProduct"> | string
    user_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    name?: StringFilter<"ExpenseProduct"> | string
    brand?: StringNullableFilter<"ExpenseProduct"> | string | null
    unit?: StringNullableFilter<"ExpenseProduct"> | string | null
    size?: DecimalNullableFilter<"ExpenseProduct"> | Decimal | DecimalJsLike | number | string | null
    category_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    subcategory_uuid?: StringNullableFilter<"ExpenseProduct"> | string | null
    created_at?: DateTimeFilter<"ExpenseProduct"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseProduct"> | Date | string
  }

  export type MuscleGroupUpsertWithWhereUniqueWithoutUserInput = {
    where: MuscleGroupWhereUniqueInput
    update: XOR<MuscleGroupUpdateWithoutUserInput, MuscleGroupUncheckedUpdateWithoutUserInput>
    create: XOR<MuscleGroupCreateWithoutUserInput, MuscleGroupUncheckedCreateWithoutUserInput>
  }

  export type MuscleGroupUpdateWithWhereUniqueWithoutUserInput = {
    where: MuscleGroupWhereUniqueInput
    data: XOR<MuscleGroupUpdateWithoutUserInput, MuscleGroupUncheckedUpdateWithoutUserInput>
  }

  export type MuscleGroupUpdateManyWithWhereWithoutUserInput = {
    where: MuscleGroupScalarWhereInput
    data: XOR<MuscleGroupUpdateManyMutationInput, MuscleGroupUncheckedUpdateManyWithoutUserInput>
  }

  export type MuscleGroupScalarWhereInput = {
    AND?: MuscleGroupScalarWhereInput | MuscleGroupScalarWhereInput[]
    OR?: MuscleGroupScalarWhereInput[]
    NOT?: MuscleGroupScalarWhereInput | MuscleGroupScalarWhereInput[]
    id?: IntFilter<"MuscleGroup"> | number
    uuid?: StringFilter<"MuscleGroup"> | string
    user_uuid?: StringNullableFilter<"MuscleGroup"> | string | null
    name?: StringFilter<"MuscleGroup"> | string
    color?: StringNullableFilter<"MuscleGroup"> | string | null
    created_at?: DateTimeFilter<"MuscleGroup"> | Date | string
    updated_at?: DateTimeFilter<"MuscleGroup"> | Date | string
  }

  export type ExerciseUpsertWithWhereUniqueWithoutUserInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutUserInput, ExerciseUncheckedUpdateWithoutUserInput>
    create: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutUserInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutUserInput, ExerciseUncheckedUpdateWithoutUserInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutUserInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutUserInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    OR?: ExerciseScalarWhereInput[]
    NOT?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    id?: IntFilter<"Exercise"> | number
    uuid?: StringFilter<"Exercise"> | string
    user_uuid?: StringNullableFilter<"Exercise"> | string | null
    muscle_group_uuid?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    type?: EnumExerciseTypeFilter<"Exercise"> | $Enums.ExerciseType
    created_at?: DateTimeFilter<"Exercise"> | Date | string
    updated_at?: DateTimeFilter<"Exercise"> | Date | string
  }

  export type WorkoutUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkoutWhereUniqueInput
    update: XOR<WorkoutUpdateWithoutUserInput, WorkoutUncheckedUpdateWithoutUserInput>
    create: XOR<WorkoutCreateWithoutUserInput, WorkoutUncheckedCreateWithoutUserInput>
  }

  export type WorkoutUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkoutWhereUniqueInput
    data: XOR<WorkoutUpdateWithoutUserInput, WorkoutUncheckedUpdateWithoutUserInput>
  }

  export type WorkoutUpdateManyWithWhereWithoutUserInput = {
    where: WorkoutScalarWhereInput
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkoutScalarWhereInput = {
    AND?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
    OR?: WorkoutScalarWhereInput[]
    NOT?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
    id?: IntFilter<"Workout"> | number
    uuid?: StringFilter<"Workout"> | string
    user_uuid?: StringNullableFilter<"Workout"> | string | null
    name?: StringNullableFilter<"Workout"> | string | null
    notes?: StringNullableFilter<"Workout"> | string | null
    started_at?: DateTimeFilter<"Workout"> | Date | string
    finished_at?: DateTimeFilter<"Workout"> | Date | string
    created_at?: DateTimeFilter<"Workout"> | Date | string
    updated_at?: DateTimeFilter<"Workout"> | Date | string
  }

  export type UserCreateWithoutActivitiesInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type ScheduleSlotCreateWithoutActivityInput = {
    uuid?: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutSchedule_slotsInput
  }

  export type ScheduleSlotUncheckedCreateWithoutActivityInput = {
    id?: number
    uuid?: string
    user_uuid: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleSlotCreateOrConnectWithoutActivityInput = {
    where: ScheduleSlotWhereUniqueInput
    create: XOR<ScheduleSlotCreateWithoutActivityInput, ScheduleSlotUncheckedCreateWithoutActivityInput>
  }

  export type ScheduleSlotCreateManyActivityInputEnvelope = {
    data: ScheduleSlotCreateManyActivityInput | ScheduleSlotCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityScheduleCreateWithoutActivityInput = {
    uuid?: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutActivity_schedulesInput
    weekdays?: ActivityScheduleWeekdayCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleUncheckedCreateWithoutActivityInput = {
    id?: number
    uuid?: string
    user_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateUncheckedCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleCreateOrConnectWithoutActivityInput = {
    where: ActivityScheduleWhereUniqueInput
    create: XOR<ActivityScheduleCreateWithoutActivityInput, ActivityScheduleUncheckedCreateWithoutActivityInput>
  }

  export type ActivityScheduleCreateManyActivityInputEnvelope = {
    data: ActivityScheduleCreateManyActivityInput | ActivityScheduleCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutActivityInput = {
    uuid?: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    schedule: ActivityScheduleCreateNestedOneWithoutLogsInput
    occurrence: ActivityOccurrenceCreateNestedOneWithoutLogInput
    user: UserCreateNestedOneWithoutActivity_logsInput
  }

  export type ActivityLogUncheckedCreateWithoutActivityInput = {
    id?: number
    uuid?: string
    user_uuid: string
    schedule_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutActivityInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutActivityInput, ActivityLogUncheckedCreateWithoutActivityInput>
  }

  export type ActivityLogCreateManyActivityInputEnvelope = {
    data: ActivityLogCreateManyActivityInput | ActivityLogCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityOccurrenceCreateWithoutActivityInput = {
    uuid?: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    schedule: ActivityScheduleCreateNestedOneWithoutOccurrencesInput
    user: UserCreateNestedOneWithoutActivity_occurrencesInput
    log?: ActivityLogCreateNestedOneWithoutOccurrenceInput
  }

  export type ActivityOccurrenceUncheckedCreateWithoutActivityInput = {
    id?: number
    uuid?: string
    user_uuid: string
    schedule_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    log?: ActivityLogUncheckedCreateNestedOneWithoutOccurrenceInput
  }

  export type ActivityOccurrenceCreateOrConnectWithoutActivityInput = {
    where: ActivityOccurrenceWhereUniqueInput
    create: XOR<ActivityOccurrenceCreateWithoutActivityInput, ActivityOccurrenceUncheckedCreateWithoutActivityInput>
  }

  export type ActivityOccurrenceCreateManyActivityInputEnvelope = {
    data: ActivityOccurrenceCreateManyActivityInput | ActivityOccurrenceCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScheduleSlotUpsertWithWhereUniqueWithoutActivityInput = {
    where: ScheduleSlotWhereUniqueInput
    update: XOR<ScheduleSlotUpdateWithoutActivityInput, ScheduleSlotUncheckedUpdateWithoutActivityInput>
    create: XOR<ScheduleSlotCreateWithoutActivityInput, ScheduleSlotUncheckedCreateWithoutActivityInput>
  }

  export type ScheduleSlotUpdateWithWhereUniqueWithoutActivityInput = {
    where: ScheduleSlotWhereUniqueInput
    data: XOR<ScheduleSlotUpdateWithoutActivityInput, ScheduleSlotUncheckedUpdateWithoutActivityInput>
  }

  export type ScheduleSlotUpdateManyWithWhereWithoutActivityInput = {
    where: ScheduleSlotScalarWhereInput
    data: XOR<ScheduleSlotUpdateManyMutationInput, ScheduleSlotUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityScheduleUpsertWithWhereUniqueWithoutActivityInput = {
    where: ActivityScheduleWhereUniqueInput
    update: XOR<ActivityScheduleUpdateWithoutActivityInput, ActivityScheduleUncheckedUpdateWithoutActivityInput>
    create: XOR<ActivityScheduleCreateWithoutActivityInput, ActivityScheduleUncheckedCreateWithoutActivityInput>
  }

  export type ActivityScheduleUpdateWithWhereUniqueWithoutActivityInput = {
    where: ActivityScheduleWhereUniqueInput
    data: XOR<ActivityScheduleUpdateWithoutActivityInput, ActivityScheduleUncheckedUpdateWithoutActivityInput>
  }

  export type ActivityScheduleUpdateManyWithWhereWithoutActivityInput = {
    where: ActivityScheduleScalarWhereInput
    data: XOR<ActivityScheduleUpdateManyMutationInput, ActivityScheduleUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutActivityInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutActivityInput, ActivityLogUncheckedUpdateWithoutActivityInput>
    create: XOR<ActivityLogCreateWithoutActivityInput, ActivityLogUncheckedCreateWithoutActivityInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutActivityInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutActivityInput, ActivityLogUncheckedUpdateWithoutActivityInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutActivityInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityOccurrenceUpsertWithWhereUniqueWithoutActivityInput = {
    where: ActivityOccurrenceWhereUniqueInput
    update: XOR<ActivityOccurrenceUpdateWithoutActivityInput, ActivityOccurrenceUncheckedUpdateWithoutActivityInput>
    create: XOR<ActivityOccurrenceCreateWithoutActivityInput, ActivityOccurrenceUncheckedCreateWithoutActivityInput>
  }

  export type ActivityOccurrenceUpdateWithWhereUniqueWithoutActivityInput = {
    where: ActivityOccurrenceWhereUniqueInput
    data: XOR<ActivityOccurrenceUpdateWithoutActivityInput, ActivityOccurrenceUncheckedUpdateWithoutActivityInput>
  }

  export type ActivityOccurrenceUpdateManyWithWhereWithoutActivityInput = {
    where: ActivityOccurrenceScalarWhereInput
    data: XOR<ActivityOccurrenceUpdateManyMutationInput, ActivityOccurrenceUncheckedUpdateManyWithoutActivityInput>
  }

  export type UserCreateWithoutSchedule_slotsInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchedule_slotsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchedule_slotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchedule_slotsInput, UserUncheckedCreateWithoutSchedule_slotsInput>
  }

  export type ActivityCreateWithoutSchedule_slotsInput = {
    uuid?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutSchedule_slotsInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutSchedule_slotsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutSchedule_slotsInput, ActivityUncheckedCreateWithoutSchedule_slotsInput>
  }

  export type UserUpsertWithoutSchedule_slotsInput = {
    update: XOR<UserUpdateWithoutSchedule_slotsInput, UserUncheckedUpdateWithoutSchedule_slotsInput>
    create: XOR<UserCreateWithoutSchedule_slotsInput, UserUncheckedCreateWithoutSchedule_slotsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSchedule_slotsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSchedule_slotsInput, UserUncheckedUpdateWithoutSchedule_slotsInput>
  }

  export type UserUpdateWithoutSchedule_slotsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchedule_slotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityUpsertWithoutSchedule_slotsInput = {
    update: XOR<ActivityUpdateWithoutSchedule_slotsInput, ActivityUncheckedUpdateWithoutSchedule_slotsInput>
    create: XOR<ActivityCreateWithoutSchedule_slotsInput, ActivityUncheckedCreateWithoutSchedule_slotsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutSchedule_slotsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutSchedule_slotsInput, ActivityUncheckedUpdateWithoutSchedule_slotsInput>
  }

  export type ActivityUpdateWithoutSchedule_slotsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutSchedule_slotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateWithoutActivity_schedulesInput = {
    uuid?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutActivity_schedulesInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutActivity_schedulesInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutActivity_schedulesInput, ActivityUncheckedCreateWithoutActivity_schedulesInput>
  }

  export type UserCreateWithoutActivity_schedulesInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivity_schedulesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivity_schedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivity_schedulesInput, UserUncheckedCreateWithoutActivity_schedulesInput>
  }

  export type ActivityScheduleWeekdayCreateWithoutScheduleInput = {
    weekday: number
  }

  export type ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput = {
    id?: number
    weekday: number
  }

  export type ActivityScheduleWeekdayCreateOrConnectWithoutScheduleInput = {
    where: ActivityScheduleWeekdayWhereUniqueInput
    create: XOR<ActivityScheduleWeekdayCreateWithoutScheduleInput, ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput>
  }

  export type ActivityScheduleWeekdayCreateManyScheduleInputEnvelope = {
    data: ActivityScheduleWeekdayCreateManyScheduleInput | ActivityScheduleWeekdayCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ActivityScheduleDateCreateWithoutScheduleInput = {
    date: Date | string
  }

  export type ActivityScheduleDateUncheckedCreateWithoutScheduleInput = {
    id?: number
    date: Date | string
  }

  export type ActivityScheduleDateCreateOrConnectWithoutScheduleInput = {
    where: ActivityScheduleDateWhereUniqueInput
    create: XOR<ActivityScheduleDateCreateWithoutScheduleInput, ActivityScheduleDateUncheckedCreateWithoutScheduleInput>
  }

  export type ActivityScheduleDateCreateManyScheduleInputEnvelope = {
    data: ActivityScheduleDateCreateManyScheduleInput | ActivityScheduleDateCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ActivityOccurrenceCreateWithoutScheduleInput = {
    uuid?: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_occurrencesInput
    user: UserCreateNestedOneWithoutActivity_occurrencesInput
    log?: ActivityLogCreateNestedOneWithoutOccurrenceInput
  }

  export type ActivityOccurrenceUncheckedCreateWithoutScheduleInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    log?: ActivityLogUncheckedCreateNestedOneWithoutOccurrenceInput
  }

  export type ActivityOccurrenceCreateOrConnectWithoutScheduleInput = {
    where: ActivityOccurrenceWhereUniqueInput
    create: XOR<ActivityOccurrenceCreateWithoutScheduleInput, ActivityOccurrenceUncheckedCreateWithoutScheduleInput>
  }

  export type ActivityOccurrenceCreateManyScheduleInputEnvelope = {
    data: ActivityOccurrenceCreateManyScheduleInput | ActivityOccurrenceCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutScheduleInput = {
    uuid?: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_logsInput
    occurrence: ActivityOccurrenceCreateNestedOneWithoutLogInput
    user: UserCreateNestedOneWithoutActivity_logsInput
  }

  export type ActivityLogUncheckedCreateWithoutScheduleInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutScheduleInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutScheduleInput, ActivityLogUncheckedCreateWithoutScheduleInput>
  }

  export type ActivityLogCreateManyScheduleInputEnvelope = {
    data: ActivityLogCreateManyScheduleInput | ActivityLogCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithoutActivity_schedulesInput = {
    update: XOR<ActivityUpdateWithoutActivity_schedulesInput, ActivityUncheckedUpdateWithoutActivity_schedulesInput>
    create: XOR<ActivityCreateWithoutActivity_schedulesInput, ActivityUncheckedCreateWithoutActivity_schedulesInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutActivity_schedulesInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutActivity_schedulesInput, ActivityUncheckedUpdateWithoutActivity_schedulesInput>
  }

  export type ActivityUpdateWithoutActivity_schedulesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutActivity_schedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type UserUpsertWithoutActivity_schedulesInput = {
    update: XOR<UserUpdateWithoutActivity_schedulesInput, UserUncheckedUpdateWithoutActivity_schedulesInput>
    create: XOR<UserCreateWithoutActivity_schedulesInput, UserUncheckedCreateWithoutActivity_schedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivity_schedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivity_schedulesInput, UserUncheckedUpdateWithoutActivity_schedulesInput>
  }

  export type UserUpdateWithoutActivity_schedulesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivity_schedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityScheduleWeekdayUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ActivityScheduleWeekdayWhereUniqueInput
    update: XOR<ActivityScheduleWeekdayUpdateWithoutScheduleInput, ActivityScheduleWeekdayUncheckedUpdateWithoutScheduleInput>
    create: XOR<ActivityScheduleWeekdayCreateWithoutScheduleInput, ActivityScheduleWeekdayUncheckedCreateWithoutScheduleInput>
  }

  export type ActivityScheduleWeekdayUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ActivityScheduleWeekdayWhereUniqueInput
    data: XOR<ActivityScheduleWeekdayUpdateWithoutScheduleInput, ActivityScheduleWeekdayUncheckedUpdateWithoutScheduleInput>
  }

  export type ActivityScheduleWeekdayUpdateManyWithWhereWithoutScheduleInput = {
    where: ActivityScheduleWeekdayScalarWhereInput
    data: XOR<ActivityScheduleWeekdayUpdateManyMutationInput, ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ActivityScheduleWeekdayScalarWhereInput = {
    AND?: ActivityScheduleWeekdayScalarWhereInput | ActivityScheduleWeekdayScalarWhereInput[]
    OR?: ActivityScheduleWeekdayScalarWhereInput[]
    NOT?: ActivityScheduleWeekdayScalarWhereInput | ActivityScheduleWeekdayScalarWhereInput[]
    id?: IntFilter<"ActivityScheduleWeekday"> | number
    schedule_uuid?: StringFilter<"ActivityScheduleWeekday"> | string
    weekday?: IntFilter<"ActivityScheduleWeekday"> | number
  }

  export type ActivityScheduleDateUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ActivityScheduleDateWhereUniqueInput
    update: XOR<ActivityScheduleDateUpdateWithoutScheduleInput, ActivityScheduleDateUncheckedUpdateWithoutScheduleInput>
    create: XOR<ActivityScheduleDateCreateWithoutScheduleInput, ActivityScheduleDateUncheckedCreateWithoutScheduleInput>
  }

  export type ActivityScheduleDateUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ActivityScheduleDateWhereUniqueInput
    data: XOR<ActivityScheduleDateUpdateWithoutScheduleInput, ActivityScheduleDateUncheckedUpdateWithoutScheduleInput>
  }

  export type ActivityScheduleDateUpdateManyWithWhereWithoutScheduleInput = {
    where: ActivityScheduleDateScalarWhereInput
    data: XOR<ActivityScheduleDateUpdateManyMutationInput, ActivityScheduleDateUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ActivityScheduleDateScalarWhereInput = {
    AND?: ActivityScheduleDateScalarWhereInput | ActivityScheduleDateScalarWhereInput[]
    OR?: ActivityScheduleDateScalarWhereInput[]
    NOT?: ActivityScheduleDateScalarWhereInput | ActivityScheduleDateScalarWhereInput[]
    id?: IntFilter<"ActivityScheduleDate"> | number
    schedule_uuid?: StringFilter<"ActivityScheduleDate"> | string
    date?: DateTimeFilter<"ActivityScheduleDate"> | Date | string
  }

  export type ActivityOccurrenceUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ActivityOccurrenceWhereUniqueInput
    update: XOR<ActivityOccurrenceUpdateWithoutScheduleInput, ActivityOccurrenceUncheckedUpdateWithoutScheduleInput>
    create: XOR<ActivityOccurrenceCreateWithoutScheduleInput, ActivityOccurrenceUncheckedCreateWithoutScheduleInput>
  }

  export type ActivityOccurrenceUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ActivityOccurrenceWhereUniqueInput
    data: XOR<ActivityOccurrenceUpdateWithoutScheduleInput, ActivityOccurrenceUncheckedUpdateWithoutScheduleInput>
  }

  export type ActivityOccurrenceUpdateManyWithWhereWithoutScheduleInput = {
    where: ActivityOccurrenceScalarWhereInput
    data: XOR<ActivityOccurrenceUpdateManyMutationInput, ActivityOccurrenceUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutScheduleInput, ActivityLogUncheckedUpdateWithoutScheduleInput>
    create: XOR<ActivityLogCreateWithoutScheduleInput, ActivityLogUncheckedCreateWithoutScheduleInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutScheduleInput, ActivityLogUncheckedUpdateWithoutScheduleInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutScheduleInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ActivityScheduleCreateWithoutWeekdaysInput = {
    uuid?: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_schedulesInput
    user: UserCreateNestedOneWithoutActivity_schedulesInput
    specific_dates?: ActivityScheduleDateCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleUncheckedCreateWithoutWeekdaysInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    specific_dates?: ActivityScheduleDateUncheckedCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleCreateOrConnectWithoutWeekdaysInput = {
    where: ActivityScheduleWhereUniqueInput
    create: XOR<ActivityScheduleCreateWithoutWeekdaysInput, ActivityScheduleUncheckedCreateWithoutWeekdaysInput>
  }

  export type ActivityScheduleUpsertWithoutWeekdaysInput = {
    update: XOR<ActivityScheduleUpdateWithoutWeekdaysInput, ActivityScheduleUncheckedUpdateWithoutWeekdaysInput>
    create: XOR<ActivityScheduleCreateWithoutWeekdaysInput, ActivityScheduleUncheckedCreateWithoutWeekdaysInput>
    where?: ActivityScheduleWhereInput
  }

  export type ActivityScheduleUpdateToOneWithWhereWithoutWeekdaysInput = {
    where?: ActivityScheduleWhereInput
    data: XOR<ActivityScheduleUpdateWithoutWeekdaysInput, ActivityScheduleUncheckedUpdateWithoutWeekdaysInput>
  }

  export type ActivityScheduleUpdateWithoutWeekdaysInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_schedulesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_schedulesNestedInput
    specific_dates?: ActivityScheduleDateUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateWithoutWeekdaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    specific_dates?: ActivityScheduleDateUncheckedUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleCreateWithoutSpecific_datesInput = {
    uuid?: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_schedulesInput
    user: UserCreateNestedOneWithoutActivity_schedulesInput
    weekdays?: ActivityScheduleWeekdayCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleUncheckedCreateWithoutSpecific_datesInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleCreateOrConnectWithoutSpecific_datesInput = {
    where: ActivityScheduleWhereUniqueInput
    create: XOR<ActivityScheduleCreateWithoutSpecific_datesInput, ActivityScheduleUncheckedCreateWithoutSpecific_datesInput>
  }

  export type ActivityScheduleUpsertWithoutSpecific_datesInput = {
    update: XOR<ActivityScheduleUpdateWithoutSpecific_datesInput, ActivityScheduleUncheckedUpdateWithoutSpecific_datesInput>
    create: XOR<ActivityScheduleCreateWithoutSpecific_datesInput, ActivityScheduleUncheckedCreateWithoutSpecific_datesInput>
    where?: ActivityScheduleWhereInput
  }

  export type ActivityScheduleUpdateToOneWithWhereWithoutSpecific_datesInput = {
    where?: ActivityScheduleWhereInput
    data: XOR<ActivityScheduleUpdateWithoutSpecific_datesInput, ActivityScheduleUncheckedUpdateWithoutSpecific_datesInput>
  }

  export type ActivityScheduleUpdateWithoutSpecific_datesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_schedulesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_schedulesNestedInput
    weekdays?: ActivityScheduleWeekdayUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateWithoutSpecific_datesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityCreateWithoutActivity_occurrencesInput = {
    uuid?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutActivityInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutActivity_occurrencesInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutActivityInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutActivityInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutActivity_occurrencesInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutActivity_occurrencesInput, ActivityUncheckedCreateWithoutActivity_occurrencesInput>
  }

  export type ActivityScheduleCreateWithoutOccurrencesInput = {
    uuid?: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_schedulesInput
    user: UserCreateNestedOneWithoutActivity_schedulesInput
    weekdays?: ActivityScheduleWeekdayCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleUncheckedCreateWithoutOccurrencesInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateUncheckedCreateNestedManyWithoutScheduleInput
    logs?: ActivityLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleCreateOrConnectWithoutOccurrencesInput = {
    where: ActivityScheduleWhereUniqueInput
    create: XOR<ActivityScheduleCreateWithoutOccurrencesInput, ActivityScheduleUncheckedCreateWithoutOccurrencesInput>
  }

  export type UserCreateWithoutActivity_occurrencesInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivity_occurrencesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivity_occurrencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivity_occurrencesInput, UserUncheckedCreateWithoutActivity_occurrencesInput>
  }

  export type ActivityLogCreateWithoutOccurrenceInput = {
    uuid?: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_logsInput
    schedule: ActivityScheduleCreateNestedOneWithoutLogsInput
    user: UserCreateNestedOneWithoutActivity_logsInput
  }

  export type ActivityLogUncheckedCreateWithoutOccurrenceInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    schedule_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutOccurrenceInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutOccurrenceInput, ActivityLogUncheckedCreateWithoutOccurrenceInput>
  }

  export type ActivityUpsertWithoutActivity_occurrencesInput = {
    update: XOR<ActivityUpdateWithoutActivity_occurrencesInput, ActivityUncheckedUpdateWithoutActivity_occurrencesInput>
    create: XOR<ActivityCreateWithoutActivity_occurrencesInput, ActivityUncheckedCreateWithoutActivity_occurrencesInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutActivity_occurrencesInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutActivity_occurrencesInput, ActivityUncheckedUpdateWithoutActivity_occurrencesInput>
  }

  export type ActivityUpdateWithoutActivity_occurrencesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutActivityNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutActivity_occurrencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutActivityNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityScheduleUpsertWithoutOccurrencesInput = {
    update: XOR<ActivityScheduleUpdateWithoutOccurrencesInput, ActivityScheduleUncheckedUpdateWithoutOccurrencesInput>
    create: XOR<ActivityScheduleCreateWithoutOccurrencesInput, ActivityScheduleUncheckedCreateWithoutOccurrencesInput>
    where?: ActivityScheduleWhereInput
  }

  export type ActivityScheduleUpdateToOneWithWhereWithoutOccurrencesInput = {
    where?: ActivityScheduleWhereInput
    data: XOR<ActivityScheduleUpdateWithoutOccurrencesInput, ActivityScheduleUncheckedUpdateWithoutOccurrencesInput>
  }

  export type ActivityScheduleUpdateWithoutOccurrencesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_schedulesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_schedulesNestedInput
    weekdays?: ActivityScheduleWeekdayUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateWithoutOccurrencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUncheckedUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type UserUpsertWithoutActivity_occurrencesInput = {
    update: XOR<UserUpdateWithoutActivity_occurrencesInput, UserUncheckedUpdateWithoutActivity_occurrencesInput>
    create: XOR<UserCreateWithoutActivity_occurrencesInput, UserUncheckedCreateWithoutActivity_occurrencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivity_occurrencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivity_occurrencesInput, UserUncheckedUpdateWithoutActivity_occurrencesInput>
  }

  export type UserUpdateWithoutActivity_occurrencesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivity_occurrencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityLogUpsertWithoutOccurrenceInput = {
    update: XOR<ActivityLogUpdateWithoutOccurrenceInput, ActivityLogUncheckedUpdateWithoutOccurrenceInput>
    create: XOR<ActivityLogCreateWithoutOccurrenceInput, ActivityLogUncheckedCreateWithoutOccurrenceInput>
    where?: ActivityLogWhereInput
  }

  export type ActivityLogUpdateToOneWithWhereWithoutOccurrenceInput = {
    where?: ActivityLogWhereInput
    data: XOR<ActivityLogUpdateWithoutOccurrenceInput, ActivityLogUncheckedUpdateWithoutOccurrenceInput>
  }

  export type ActivityLogUpdateWithoutOccurrenceInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_logsNestedInput
    schedule?: ActivityScheduleUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_logsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutOccurrenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateWithoutActivity_logsInput = {
    uuid?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutActivityInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutActivity_logsInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutActivityInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutActivityInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutActivity_logsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutActivity_logsInput, ActivityUncheckedCreateWithoutActivity_logsInput>
  }

  export type ActivityScheduleCreateWithoutLogsInput = {
    uuid?: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_schedulesInput
    user: UserCreateNestedOneWithoutActivity_schedulesInput
    weekdays?: ActivityScheduleWeekdayCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleUncheckedCreateWithoutLogsInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedCreateNestedManyWithoutScheduleInput
    specific_dates?: ActivityScheduleDateUncheckedCreateNestedManyWithoutScheduleInput
    occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ActivityScheduleCreateOrConnectWithoutLogsInput = {
    where: ActivityScheduleWhereUniqueInput
    create: XOR<ActivityScheduleCreateWithoutLogsInput, ActivityScheduleUncheckedCreateWithoutLogsInput>
  }

  export type ActivityOccurrenceCreateWithoutLogInput = {
    uuid?: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
    activity: ActivityCreateNestedOneWithoutActivity_occurrencesInput
    schedule: ActivityScheduleCreateNestedOneWithoutOccurrencesInput
    user: UserCreateNestedOneWithoutActivity_occurrencesInput
  }

  export type ActivityOccurrenceUncheckedCreateWithoutLogInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    schedule_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityOccurrenceCreateOrConnectWithoutLogInput = {
    where: ActivityOccurrenceWhereUniqueInput
    create: XOR<ActivityOccurrenceCreateWithoutLogInput, ActivityOccurrenceUncheckedCreateWithoutLogInput>
  }

  export type UserCreateWithoutActivity_logsInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivity_logsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivity_logsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivity_logsInput, UserUncheckedCreateWithoutActivity_logsInput>
  }

  export type ActivityUpsertWithoutActivity_logsInput = {
    update: XOR<ActivityUpdateWithoutActivity_logsInput, ActivityUncheckedUpdateWithoutActivity_logsInput>
    create: XOR<ActivityCreateWithoutActivity_logsInput, ActivityUncheckedCreateWithoutActivity_logsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutActivity_logsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutActivity_logsInput, ActivityUncheckedUpdateWithoutActivity_logsInput>
  }

  export type ActivityUpdateWithoutActivity_logsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutActivityNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutActivity_logsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutActivityNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityScheduleUpsertWithoutLogsInput = {
    update: XOR<ActivityScheduleUpdateWithoutLogsInput, ActivityScheduleUncheckedUpdateWithoutLogsInput>
    create: XOR<ActivityScheduleCreateWithoutLogsInput, ActivityScheduleUncheckedCreateWithoutLogsInput>
    where?: ActivityScheduleWhereInput
  }

  export type ActivityScheduleUpdateToOneWithWhereWithoutLogsInput = {
    where?: ActivityScheduleWhereInput
    data: XOR<ActivityScheduleUpdateWithoutLogsInput, ActivityScheduleUncheckedUpdateWithoutLogsInput>
  }

  export type ActivityScheduleUpdateWithoutLogsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_schedulesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_schedulesNestedInput
    weekdays?: ActivityScheduleWeekdayUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUncheckedUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityOccurrenceUpsertWithoutLogInput = {
    update: XOR<ActivityOccurrenceUpdateWithoutLogInput, ActivityOccurrenceUncheckedUpdateWithoutLogInput>
    create: XOR<ActivityOccurrenceCreateWithoutLogInput, ActivityOccurrenceUncheckedCreateWithoutLogInput>
    where?: ActivityOccurrenceWhereInput
  }

  export type ActivityOccurrenceUpdateToOneWithWhereWithoutLogInput = {
    where?: ActivityOccurrenceWhereInput
    data: XOR<ActivityOccurrenceUpdateWithoutLogInput, ActivityOccurrenceUncheckedUpdateWithoutLogInput>
  }

  export type ActivityOccurrenceUpdateWithoutLogInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_occurrencesNestedInput
    schedule?: ActivityScheduleUpdateOneRequiredWithoutOccurrencesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_occurrencesNestedInput
  }

  export type ActivityOccurrenceUncheckedUpdateWithoutLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutActivity_logsInput = {
    update: XOR<UserUpdateWithoutActivity_logsInput, UserUncheckedUpdateWithoutActivity_logsInput>
    create: XOR<UserCreateWithoutActivity_logsInput, UserUncheckedCreateWithoutActivity_logsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivity_logsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivity_logsInput, UserUncheckedUpdateWithoutActivity_logsInput>
  }

  export type UserUpdateWithoutActivity_logsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivity_logsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutExpense_accountsInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExpense_accountsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExpense_accountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpense_accountsInput, UserUncheckedCreateWithoutExpense_accountsInput>
  }

  export type ExpenseEntryCreateWithoutFrom_accountInput = {
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_entriesInput
    to_account?: ExpenseAccountCreateNestedOneWithoutEntries_toInput
    category?: ExpenseCategoryCreateNestedOneWithoutEntriesInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutEntriesInput
    expense_receipt?: ExpenseReceiptCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryUncheckedCreateWithoutFrom_accountInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    to_account_uuid?: string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    expense_receipt?: ExpenseReceiptUncheckedCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryCreateOrConnectWithoutFrom_accountInput = {
    where: ExpenseEntryWhereUniqueInput
    create: XOR<ExpenseEntryCreateWithoutFrom_accountInput, ExpenseEntryUncheckedCreateWithoutFrom_accountInput>
  }

  export type ExpenseEntryCreateManyFrom_accountInputEnvelope = {
    data: ExpenseEntryCreateManyFrom_accountInput | ExpenseEntryCreateManyFrom_accountInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseEntryCreateWithoutTo_accountInput = {
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_entriesInput
    from_account: ExpenseAccountCreateNestedOneWithoutEntries_fromInput
    category?: ExpenseCategoryCreateNestedOneWithoutEntriesInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutEntriesInput
    expense_receipt?: ExpenseReceiptCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryUncheckedCreateWithoutTo_accountInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    expense_receipt?: ExpenseReceiptUncheckedCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryCreateOrConnectWithoutTo_accountInput = {
    where: ExpenseEntryWhereUniqueInput
    create: XOR<ExpenseEntryCreateWithoutTo_accountInput, ExpenseEntryUncheckedCreateWithoutTo_accountInput>
  }

  export type ExpenseEntryCreateManyTo_accountInputEnvelope = {
    data: ExpenseEntryCreateManyTo_accountInput | ExpenseEntryCreateManyTo_accountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutExpense_accountsInput = {
    update: XOR<UserUpdateWithoutExpense_accountsInput, UserUncheckedUpdateWithoutExpense_accountsInput>
    create: XOR<UserCreateWithoutExpense_accountsInput, UserUncheckedCreateWithoutExpense_accountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpense_accountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpense_accountsInput, UserUncheckedUpdateWithoutExpense_accountsInput>
  }

  export type UserUpdateWithoutExpense_accountsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExpense_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseEntryUpsertWithWhereUniqueWithoutFrom_accountInput = {
    where: ExpenseEntryWhereUniqueInput
    update: XOR<ExpenseEntryUpdateWithoutFrom_accountInput, ExpenseEntryUncheckedUpdateWithoutFrom_accountInput>
    create: XOR<ExpenseEntryCreateWithoutFrom_accountInput, ExpenseEntryUncheckedCreateWithoutFrom_accountInput>
  }

  export type ExpenseEntryUpdateWithWhereUniqueWithoutFrom_accountInput = {
    where: ExpenseEntryWhereUniqueInput
    data: XOR<ExpenseEntryUpdateWithoutFrom_accountInput, ExpenseEntryUncheckedUpdateWithoutFrom_accountInput>
  }

  export type ExpenseEntryUpdateManyWithWhereWithoutFrom_accountInput = {
    where: ExpenseEntryScalarWhereInput
    data: XOR<ExpenseEntryUpdateManyMutationInput, ExpenseEntryUncheckedUpdateManyWithoutFrom_accountInput>
  }

  export type ExpenseEntryUpsertWithWhereUniqueWithoutTo_accountInput = {
    where: ExpenseEntryWhereUniqueInput
    update: XOR<ExpenseEntryUpdateWithoutTo_accountInput, ExpenseEntryUncheckedUpdateWithoutTo_accountInput>
    create: XOR<ExpenseEntryCreateWithoutTo_accountInput, ExpenseEntryUncheckedCreateWithoutTo_accountInput>
  }

  export type ExpenseEntryUpdateWithWhereUniqueWithoutTo_accountInput = {
    where: ExpenseEntryWhereUniqueInput
    data: XOR<ExpenseEntryUpdateWithoutTo_accountInput, ExpenseEntryUncheckedUpdateWithoutTo_accountInput>
  }

  export type ExpenseEntryUpdateManyWithWhereWithoutTo_accountInput = {
    where: ExpenseEntryScalarWhereInput
    data: XOR<ExpenseEntryUpdateManyMutationInput, ExpenseEntryUncheckedUpdateManyWithoutTo_accountInput>
  }

  export type UserCreateWithoutCategoriesInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCategoriesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
  }

  export type ExpenseSubcategoryCreateWithoutCategoryInput = {
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutSubcategoriesInput
    entries?: ExpenseEntryCreateNestedManyWithoutSubcategoryInput
    products?: ExpenseProductCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entries?: ExpenseEntryUncheckedCreateNestedManyWithoutSubcategoryInput
    products?: ExpenseProductUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryCreateOrConnectWithoutCategoryInput = {
    where: ExpenseSubcategoryWhereUniqueInput
    create: XOR<ExpenseSubcategoryCreateWithoutCategoryInput, ExpenseSubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseSubcategoryCreateManyCategoryInputEnvelope = {
    data: ExpenseSubcategoryCreateManyCategoryInput | ExpenseSubcategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseEntryCreateWithoutCategoryInput = {
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_entriesInput
    from_account: ExpenseAccountCreateNestedOneWithoutEntries_fromInput
    to_account?: ExpenseAccountCreateNestedOneWithoutEntries_toInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutEntriesInput
    expense_receipt?: ExpenseReceiptCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryUncheckedCreateWithoutCategoryInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    expense_receipt?: ExpenseReceiptUncheckedCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryCreateOrConnectWithoutCategoryInput = {
    where: ExpenseEntryWhereUniqueInput
    create: XOR<ExpenseEntryCreateWithoutCategoryInput, ExpenseEntryUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseEntryCreateManyCategoryInputEnvelope = {
    data: ExpenseEntryCreateManyCategoryInput | ExpenseEntryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseProductCreateWithoutCategoryInput = {
    uuid?: string
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExpense_productsInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutProductsInput
    receipt_items?: ExpenseReceiptItemCreateNestedManyWithoutProductInput
  }

  export type ExpenseProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    subcategory_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    receipt_items?: ExpenseReceiptItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ExpenseProductCreateOrConnectWithoutCategoryInput = {
    where: ExpenseProductWhereUniqueInput
    create: XOR<ExpenseProductCreateWithoutCategoryInput, ExpenseProductUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseProductCreateManyCategoryInputEnvelope = {
    data: ExpenseProductCreateManyCategoryInput | ExpenseProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCategoriesInput = {
    update: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type UserUpdateWithoutCategoriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseSubcategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseSubcategoryWhereUniqueInput
    update: XOR<ExpenseSubcategoryUpdateWithoutCategoryInput, ExpenseSubcategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ExpenseSubcategoryCreateWithoutCategoryInput, ExpenseSubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseSubcategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseSubcategoryWhereUniqueInput
    data: XOR<ExpenseSubcategoryUpdateWithoutCategoryInput, ExpenseSubcategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ExpenseSubcategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ExpenseSubcategoryScalarWhereInput
    data: XOR<ExpenseSubcategoryUpdateManyMutationInput, ExpenseSubcategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ExpenseEntryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseEntryWhereUniqueInput
    update: XOR<ExpenseEntryUpdateWithoutCategoryInput, ExpenseEntryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ExpenseEntryCreateWithoutCategoryInput, ExpenseEntryUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseEntryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseEntryWhereUniqueInput
    data: XOR<ExpenseEntryUpdateWithoutCategoryInput, ExpenseEntryUncheckedUpdateWithoutCategoryInput>
  }

  export type ExpenseEntryUpdateManyWithWhereWithoutCategoryInput = {
    where: ExpenseEntryScalarWhereInput
    data: XOR<ExpenseEntryUpdateManyMutationInput, ExpenseEntryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ExpenseProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseProductWhereUniqueInput
    update: XOR<ExpenseProductUpdateWithoutCategoryInput, ExpenseProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ExpenseProductCreateWithoutCategoryInput, ExpenseProductUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseProductWhereUniqueInput
    data: XOR<ExpenseProductUpdateWithoutCategoryInput, ExpenseProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ExpenseProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ExpenseProductScalarWhereInput
    data: XOR<ExpenseProductUpdateManyMutationInput, ExpenseProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutSubcategoriesInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubcategoriesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubcategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubcategoriesInput, UserUncheckedCreateWithoutSubcategoriesInput>
  }

  export type ExpenseCategoryCreateWithoutSubcategoriesInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutCategoriesInput
    entries?: ExpenseEntryCreateNestedManyWithoutCategoryInput
    products?: ExpenseProductCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutSubcategoriesInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    entries?: ExpenseEntryUncheckedCreateNestedManyWithoutCategoryInput
    products?: ExpenseProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutSubcategoriesInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutSubcategoriesInput, ExpenseCategoryUncheckedCreateWithoutSubcategoriesInput>
  }

  export type ExpenseEntryCreateWithoutSubcategoryInput = {
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_entriesInput
    from_account: ExpenseAccountCreateNestedOneWithoutEntries_fromInput
    to_account?: ExpenseAccountCreateNestedOneWithoutEntries_toInput
    category?: ExpenseCategoryCreateNestedOneWithoutEntriesInput
    expense_receipt?: ExpenseReceiptCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryUncheckedCreateWithoutSubcategoryInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    category_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    expense_receipt?: ExpenseReceiptUncheckedCreateNestedOneWithoutExpense_entryInput
  }

  export type ExpenseEntryCreateOrConnectWithoutSubcategoryInput = {
    where: ExpenseEntryWhereUniqueInput
    create: XOR<ExpenseEntryCreateWithoutSubcategoryInput, ExpenseEntryUncheckedCreateWithoutSubcategoryInput>
  }

  export type ExpenseEntryCreateManySubcategoryInputEnvelope = {
    data: ExpenseEntryCreateManySubcategoryInput | ExpenseEntryCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseProductCreateWithoutSubcategoryInput = {
    uuid?: string
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExpense_productsInput
    category?: ExpenseCategoryCreateNestedOneWithoutProductsInput
    receipt_items?: ExpenseReceiptItemCreateNestedManyWithoutProductInput
  }

  export type ExpenseProductUncheckedCreateWithoutSubcategoryInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    category_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    receipt_items?: ExpenseReceiptItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ExpenseProductCreateOrConnectWithoutSubcategoryInput = {
    where: ExpenseProductWhereUniqueInput
    create: XOR<ExpenseProductCreateWithoutSubcategoryInput, ExpenseProductUncheckedCreateWithoutSubcategoryInput>
  }

  export type ExpenseProductCreateManySubcategoryInputEnvelope = {
    data: ExpenseProductCreateManySubcategoryInput | ExpenseProductCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubcategoriesInput = {
    update: XOR<UserUpdateWithoutSubcategoriesInput, UserUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<UserCreateWithoutSubcategoriesInput, UserUncheckedCreateWithoutSubcategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubcategoriesInput, UserUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type UserUpdateWithoutSubcategoriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubcategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseCategoryUpsertWithoutSubcategoriesInput = {
    update: XOR<ExpenseCategoryUpdateWithoutSubcategoriesInput, ExpenseCategoryUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<ExpenseCategoryCreateWithoutSubcategoriesInput, ExpenseCategoryUncheckedCreateWithoutSubcategoriesInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutSubcategoriesInput, ExpenseCategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type ExpenseCategoryUpdateWithoutSubcategoriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCategoriesNestedInput
    entries?: ExpenseEntryUpdateManyWithoutCategoryNestedInput
    products?: ExpenseProductUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutSubcategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ExpenseEntryUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ExpenseProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseEntryUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: ExpenseEntryWhereUniqueInput
    update: XOR<ExpenseEntryUpdateWithoutSubcategoryInput, ExpenseEntryUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<ExpenseEntryCreateWithoutSubcategoryInput, ExpenseEntryUncheckedCreateWithoutSubcategoryInput>
  }

  export type ExpenseEntryUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: ExpenseEntryWhereUniqueInput
    data: XOR<ExpenseEntryUpdateWithoutSubcategoryInput, ExpenseEntryUncheckedUpdateWithoutSubcategoryInput>
  }

  export type ExpenseEntryUpdateManyWithWhereWithoutSubcategoryInput = {
    where: ExpenseEntryScalarWhereInput
    data: XOR<ExpenseEntryUpdateManyMutationInput, ExpenseEntryUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type ExpenseProductUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: ExpenseProductWhereUniqueInput
    update: XOR<ExpenseProductUpdateWithoutSubcategoryInput, ExpenseProductUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<ExpenseProductCreateWithoutSubcategoryInput, ExpenseProductUncheckedCreateWithoutSubcategoryInput>
  }

  export type ExpenseProductUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: ExpenseProductWhereUniqueInput
    data: XOR<ExpenseProductUpdateWithoutSubcategoryInput, ExpenseProductUncheckedUpdateWithoutSubcategoryInput>
  }

  export type ExpenseProductUpdateManyWithWhereWithoutSubcategoryInput = {
    where: ExpenseProductScalarWhereInput
    data: XOR<ExpenseProductUpdateManyMutationInput, ExpenseProductUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type UserCreateWithoutExpense_entriesInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExpense_entriesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExpense_entriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpense_entriesInput, UserUncheckedCreateWithoutExpense_entriesInput>
  }

  export type ExpenseAccountCreateWithoutEntries_fromInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_accountsInput
    entries_to?: ExpenseEntryCreateNestedManyWithoutTo_accountInput
  }

  export type ExpenseAccountUncheckedCreateWithoutEntries_fromInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    entries_to?: ExpenseEntryUncheckedCreateNestedManyWithoutTo_accountInput
  }

  export type ExpenseAccountCreateOrConnectWithoutEntries_fromInput = {
    where: ExpenseAccountWhereUniqueInput
    create: XOR<ExpenseAccountCreateWithoutEntries_fromInput, ExpenseAccountUncheckedCreateWithoutEntries_fromInput>
  }

  export type ExpenseAccountCreateWithoutEntries_toInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_accountsInput
    entries_from?: ExpenseEntryCreateNestedManyWithoutFrom_accountInput
  }

  export type ExpenseAccountUncheckedCreateWithoutEntries_toInput = {
    id?: number
    uuid?: string
    user_uuid: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    entries_from?: ExpenseEntryUncheckedCreateNestedManyWithoutFrom_accountInput
  }

  export type ExpenseAccountCreateOrConnectWithoutEntries_toInput = {
    where: ExpenseAccountWhereUniqueInput
    create: XOR<ExpenseAccountCreateWithoutEntries_toInput, ExpenseAccountUncheckedCreateWithoutEntries_toInput>
  }

  export type ExpenseCategoryCreateWithoutEntriesInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutCategoriesInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutCategoryInput
    products?: ExpenseProductCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutEntriesInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    products?: ExpenseProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutEntriesInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutEntriesInput, ExpenseCategoryUncheckedCreateWithoutEntriesInput>
  }

  export type ExpenseSubcategoryCreateWithoutEntriesInput = {
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutSubcategoriesInput
    category: ExpenseCategoryCreateNestedOneWithoutSubcategoriesInput
    products?: ExpenseProductCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryUncheckedCreateWithoutEntriesInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    category_uuid: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    products?: ExpenseProductUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryCreateOrConnectWithoutEntriesInput = {
    where: ExpenseSubcategoryWhereUniqueInput
    create: XOR<ExpenseSubcategoryCreateWithoutEntriesInput, ExpenseSubcategoryUncheckedCreateWithoutEntriesInput>
  }

  export type ExpenseReceiptCreateWithoutExpense_entryInput = {
    uuid?: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_receiptsInput
    store?: ExpenseStoreCreateNestedOneWithoutReceiptsInput
    items?: ExpenseReceiptItemCreateNestedManyWithoutReceiptInput
  }

  export type ExpenseReceiptUncheckedCreateWithoutExpense_entryInput = {
    id?: number
    uuid?: string
    user_uuid: string
    store_uuid?: string | null
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    items?: ExpenseReceiptItemUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type ExpenseReceiptCreateOrConnectWithoutExpense_entryInput = {
    where: ExpenseReceiptWhereUniqueInput
    create: XOR<ExpenseReceiptCreateWithoutExpense_entryInput, ExpenseReceiptUncheckedCreateWithoutExpense_entryInput>
  }

  export type UserUpsertWithoutExpense_entriesInput = {
    update: XOR<UserUpdateWithoutExpense_entriesInput, UserUncheckedUpdateWithoutExpense_entriesInput>
    create: XOR<UserCreateWithoutExpense_entriesInput, UserUncheckedCreateWithoutExpense_entriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpense_entriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpense_entriesInput, UserUncheckedUpdateWithoutExpense_entriesInput>
  }

  export type UserUpdateWithoutExpense_entriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExpense_entriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseAccountUpsertWithoutEntries_fromInput = {
    update: XOR<ExpenseAccountUpdateWithoutEntries_fromInput, ExpenseAccountUncheckedUpdateWithoutEntries_fromInput>
    create: XOR<ExpenseAccountCreateWithoutEntries_fromInput, ExpenseAccountUncheckedCreateWithoutEntries_fromInput>
    where?: ExpenseAccountWhereInput
  }

  export type ExpenseAccountUpdateToOneWithWhereWithoutEntries_fromInput = {
    where?: ExpenseAccountWhereInput
    data: XOR<ExpenseAccountUpdateWithoutEntries_fromInput, ExpenseAccountUncheckedUpdateWithoutEntries_fromInput>
  }

  export type ExpenseAccountUpdateWithoutEntries_fromInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_accountsNestedInput
    entries_to?: ExpenseEntryUpdateManyWithoutTo_accountNestedInput
  }

  export type ExpenseAccountUncheckedUpdateWithoutEntries_fromInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries_to?: ExpenseEntryUncheckedUpdateManyWithoutTo_accountNestedInput
  }

  export type ExpenseAccountUpsertWithoutEntries_toInput = {
    update: XOR<ExpenseAccountUpdateWithoutEntries_toInput, ExpenseAccountUncheckedUpdateWithoutEntries_toInput>
    create: XOR<ExpenseAccountCreateWithoutEntries_toInput, ExpenseAccountUncheckedCreateWithoutEntries_toInput>
    where?: ExpenseAccountWhereInput
  }

  export type ExpenseAccountUpdateToOneWithWhereWithoutEntries_toInput = {
    where?: ExpenseAccountWhereInput
    data: XOR<ExpenseAccountUpdateWithoutEntries_toInput, ExpenseAccountUncheckedUpdateWithoutEntries_toInput>
  }

  export type ExpenseAccountUpdateWithoutEntries_toInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_accountsNestedInput
    entries_from?: ExpenseEntryUpdateManyWithoutFrom_accountNestedInput
  }

  export type ExpenseAccountUncheckedUpdateWithoutEntries_toInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries_from?: ExpenseEntryUncheckedUpdateManyWithoutFrom_accountNestedInput
  }

  export type ExpenseCategoryUpsertWithoutEntriesInput = {
    update: XOR<ExpenseCategoryUpdateWithoutEntriesInput, ExpenseCategoryUncheckedUpdateWithoutEntriesInput>
    create: XOR<ExpenseCategoryCreateWithoutEntriesInput, ExpenseCategoryUncheckedCreateWithoutEntriesInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutEntriesInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutEntriesInput, ExpenseCategoryUncheckedUpdateWithoutEntriesInput>
  }

  export type ExpenseCategoryUpdateWithoutEntriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCategoriesNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutCategoryNestedInput
    products?: ExpenseProductUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ExpenseProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseSubcategoryUpsertWithoutEntriesInput = {
    update: XOR<ExpenseSubcategoryUpdateWithoutEntriesInput, ExpenseSubcategoryUncheckedUpdateWithoutEntriesInput>
    create: XOR<ExpenseSubcategoryCreateWithoutEntriesInput, ExpenseSubcategoryUncheckedCreateWithoutEntriesInput>
    where?: ExpenseSubcategoryWhereInput
  }

  export type ExpenseSubcategoryUpdateToOneWithWhereWithoutEntriesInput = {
    where?: ExpenseSubcategoryWhereInput
    data: XOR<ExpenseSubcategoryUpdateWithoutEntriesInput, ExpenseSubcategoryUncheckedUpdateWithoutEntriesInput>
  }

  export type ExpenseSubcategoryUpdateWithoutEntriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSubcategoriesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    products?: ExpenseProductUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseSubcategoryUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ExpenseProductUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseReceiptUpsertWithoutExpense_entryInput = {
    update: XOR<ExpenseReceiptUpdateWithoutExpense_entryInput, ExpenseReceiptUncheckedUpdateWithoutExpense_entryInput>
    create: XOR<ExpenseReceiptCreateWithoutExpense_entryInput, ExpenseReceiptUncheckedCreateWithoutExpense_entryInput>
    where?: ExpenseReceiptWhereInput
  }

  export type ExpenseReceiptUpdateToOneWithWhereWithoutExpense_entryInput = {
    where?: ExpenseReceiptWhereInput
    data: XOR<ExpenseReceiptUpdateWithoutExpense_entryInput, ExpenseReceiptUncheckedUpdateWithoutExpense_entryInput>
  }

  export type ExpenseReceiptUpdateWithoutExpense_entryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_receiptsNestedInput
    store?: ExpenseStoreUpdateOneWithoutReceiptsNestedInput
    items?: ExpenseReceiptItemUpdateManyWithoutReceiptNestedInput
  }

  export type ExpenseReceiptUncheckedUpdateWithoutExpense_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    store_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ExpenseReceiptItemUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type UserCreateWithoutExpense_storesInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExpense_storesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExpense_storesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpense_storesInput, UserUncheckedCreateWithoutExpense_storesInput>
  }

  export type ExpenseReceiptCreateWithoutStoreInput = {
    uuid?: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_receiptsInput
    expense_entry: ExpenseEntryCreateNestedOneWithoutExpense_receiptInput
    items?: ExpenseReceiptItemCreateNestedManyWithoutReceiptInput
  }

  export type ExpenseReceiptUncheckedCreateWithoutStoreInput = {
    id?: number
    uuid?: string
    user_uuid: string
    expense_entry_uuid: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    items?: ExpenseReceiptItemUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type ExpenseReceiptCreateOrConnectWithoutStoreInput = {
    where: ExpenseReceiptWhereUniqueInput
    create: XOR<ExpenseReceiptCreateWithoutStoreInput, ExpenseReceiptUncheckedCreateWithoutStoreInput>
  }

  export type ExpenseReceiptCreateManyStoreInputEnvelope = {
    data: ExpenseReceiptCreateManyStoreInput | ExpenseReceiptCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutExpense_storesInput = {
    update: XOR<UserUpdateWithoutExpense_storesInput, UserUncheckedUpdateWithoutExpense_storesInput>
    create: XOR<UserCreateWithoutExpense_storesInput, UserUncheckedCreateWithoutExpense_storesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpense_storesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpense_storesInput, UserUncheckedUpdateWithoutExpense_storesInput>
  }

  export type UserUpdateWithoutExpense_storesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExpense_storesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseReceiptUpsertWithWhereUniqueWithoutStoreInput = {
    where: ExpenseReceiptWhereUniqueInput
    update: XOR<ExpenseReceiptUpdateWithoutStoreInput, ExpenseReceiptUncheckedUpdateWithoutStoreInput>
    create: XOR<ExpenseReceiptCreateWithoutStoreInput, ExpenseReceiptUncheckedCreateWithoutStoreInput>
  }

  export type ExpenseReceiptUpdateWithWhereUniqueWithoutStoreInput = {
    where: ExpenseReceiptWhereUniqueInput
    data: XOR<ExpenseReceiptUpdateWithoutStoreInput, ExpenseReceiptUncheckedUpdateWithoutStoreInput>
  }

  export type ExpenseReceiptUpdateManyWithWhereWithoutStoreInput = {
    where: ExpenseReceiptScalarWhereInput
    data: XOR<ExpenseReceiptUpdateManyMutationInput, ExpenseReceiptUncheckedUpdateManyWithoutStoreInput>
  }

  export type UserCreateWithoutExpense_receiptsInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExpense_receiptsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExpense_receiptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpense_receiptsInput, UserUncheckedCreateWithoutExpense_receiptsInput>
  }

  export type ExpenseStoreCreateWithoutReceiptsInput = {
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExpense_storesInput
  }

  export type ExpenseStoreUncheckedCreateWithoutReceiptsInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseStoreCreateOrConnectWithoutReceiptsInput = {
    where: ExpenseStoreWhereUniqueInput
    create: XOR<ExpenseStoreCreateWithoutReceiptsInput, ExpenseStoreUncheckedCreateWithoutReceiptsInput>
  }

  export type ExpenseEntryCreateWithoutExpense_receiptInput = {
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_entriesInput
    from_account: ExpenseAccountCreateNestedOneWithoutEntries_fromInput
    to_account?: ExpenseAccountCreateNestedOneWithoutEntries_toInput
    category?: ExpenseCategoryCreateNestedOneWithoutEntriesInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutEntriesInput
  }

  export type ExpenseEntryUncheckedCreateWithoutExpense_receiptInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseEntryCreateOrConnectWithoutExpense_receiptInput = {
    where: ExpenseEntryWhereUniqueInput
    create: XOR<ExpenseEntryCreateWithoutExpense_receiptInput, ExpenseEntryUncheckedCreateWithoutExpense_receiptInput>
  }

  export type ExpenseReceiptItemCreateWithoutReceiptInput = {
    uuid?: string
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ExpenseProductCreateNestedOneWithoutReceipt_itemsInput
  }

  export type ExpenseReceiptItemUncheckedCreateWithoutReceiptInput = {
    id?: number
    uuid?: string
    product_uuid?: string | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptItemCreateOrConnectWithoutReceiptInput = {
    where: ExpenseReceiptItemWhereUniqueInput
    create: XOR<ExpenseReceiptItemCreateWithoutReceiptInput, ExpenseReceiptItemUncheckedCreateWithoutReceiptInput>
  }

  export type ExpenseReceiptItemCreateManyReceiptInputEnvelope = {
    data: ExpenseReceiptItemCreateManyReceiptInput | ExpenseReceiptItemCreateManyReceiptInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutExpense_receiptsInput = {
    update: XOR<UserUpdateWithoutExpense_receiptsInput, UserUncheckedUpdateWithoutExpense_receiptsInput>
    create: XOR<UserCreateWithoutExpense_receiptsInput, UserUncheckedCreateWithoutExpense_receiptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpense_receiptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpense_receiptsInput, UserUncheckedUpdateWithoutExpense_receiptsInput>
  }

  export type UserUpdateWithoutExpense_receiptsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExpense_receiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseStoreUpsertWithoutReceiptsInput = {
    update: XOR<ExpenseStoreUpdateWithoutReceiptsInput, ExpenseStoreUncheckedUpdateWithoutReceiptsInput>
    create: XOR<ExpenseStoreCreateWithoutReceiptsInput, ExpenseStoreUncheckedCreateWithoutReceiptsInput>
    where?: ExpenseStoreWhereInput
  }

  export type ExpenseStoreUpdateToOneWithWhereWithoutReceiptsInput = {
    where?: ExpenseStoreWhereInput
    data: XOR<ExpenseStoreUpdateWithoutReceiptsInput, ExpenseStoreUncheckedUpdateWithoutReceiptsInput>
  }

  export type ExpenseStoreUpdateWithoutReceiptsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExpense_storesNestedInput
  }

  export type ExpenseStoreUncheckedUpdateWithoutReceiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseEntryUpsertWithoutExpense_receiptInput = {
    update: XOR<ExpenseEntryUpdateWithoutExpense_receiptInput, ExpenseEntryUncheckedUpdateWithoutExpense_receiptInput>
    create: XOR<ExpenseEntryCreateWithoutExpense_receiptInput, ExpenseEntryUncheckedCreateWithoutExpense_receiptInput>
    where?: ExpenseEntryWhereInput
  }

  export type ExpenseEntryUpdateToOneWithWhereWithoutExpense_receiptInput = {
    where?: ExpenseEntryWhereInput
    data: XOR<ExpenseEntryUpdateWithoutExpense_receiptInput, ExpenseEntryUncheckedUpdateWithoutExpense_receiptInput>
  }

  export type ExpenseEntryUpdateWithoutExpense_receiptInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_entriesNestedInput
    from_account?: ExpenseAccountUpdateOneRequiredWithoutEntries_fromNestedInput
    to_account?: ExpenseAccountUpdateOneWithoutEntries_toNestedInput
    category?: ExpenseCategoryUpdateOneWithoutEntriesNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutEntriesNestedInput
  }

  export type ExpenseEntryUncheckedUpdateWithoutExpense_receiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptItemUpsertWithWhereUniqueWithoutReceiptInput = {
    where: ExpenseReceiptItemWhereUniqueInput
    update: XOR<ExpenseReceiptItemUpdateWithoutReceiptInput, ExpenseReceiptItemUncheckedUpdateWithoutReceiptInput>
    create: XOR<ExpenseReceiptItemCreateWithoutReceiptInput, ExpenseReceiptItemUncheckedCreateWithoutReceiptInput>
  }

  export type ExpenseReceiptItemUpdateWithWhereUniqueWithoutReceiptInput = {
    where: ExpenseReceiptItemWhereUniqueInput
    data: XOR<ExpenseReceiptItemUpdateWithoutReceiptInput, ExpenseReceiptItemUncheckedUpdateWithoutReceiptInput>
  }

  export type ExpenseReceiptItemUpdateManyWithWhereWithoutReceiptInput = {
    where: ExpenseReceiptItemScalarWhereInput
    data: XOR<ExpenseReceiptItemUpdateManyMutationInput, ExpenseReceiptItemUncheckedUpdateManyWithoutReceiptInput>
  }

  export type ExpenseReceiptItemScalarWhereInput = {
    AND?: ExpenseReceiptItemScalarWhereInput | ExpenseReceiptItemScalarWhereInput[]
    OR?: ExpenseReceiptItemScalarWhereInput[]
    NOT?: ExpenseReceiptItemScalarWhereInput | ExpenseReceiptItemScalarWhereInput[]
    id?: IntFilter<"ExpenseReceiptItem"> | number
    uuid?: StringFilter<"ExpenseReceiptItem"> | string
    receipt_uuid?: StringFilter<"ExpenseReceiptItem"> | string
    product_uuid?: StringNullableFilter<"ExpenseReceiptItem"> | string | null
    quantity?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"ExpenseReceiptItem"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"ExpenseReceiptItem"> | Date | string
    updated_at?: DateTimeFilter<"ExpenseReceiptItem"> | Date | string
  }

  export type UserCreateWithoutExpense_productsInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExpense_productsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExpense_productsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpense_productsInput, UserUncheckedCreateWithoutExpense_productsInput>
  }

  export type ExpenseCategoryCreateWithoutProductsInput = {
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutCategoriesInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutCategoryInput
    entries?: ExpenseEntryCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    entries?: ExpenseEntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutProductsInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutProductsInput, ExpenseCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ExpenseSubcategoryCreateWithoutProductsInput = {
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutSubcategoriesInput
    category: ExpenseCategoryCreateNestedOneWithoutSubcategoriesInput
    entries?: ExpenseEntryCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    category_uuid: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    entries?: ExpenseEntryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type ExpenseSubcategoryCreateOrConnectWithoutProductsInput = {
    where: ExpenseSubcategoryWhereUniqueInput
    create: XOR<ExpenseSubcategoryCreateWithoutProductsInput, ExpenseSubcategoryUncheckedCreateWithoutProductsInput>
  }

  export type ExpenseReceiptItemCreateWithoutProductInput = {
    uuid?: string
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    receipt: ExpenseReceiptCreateNestedOneWithoutItemsInput
  }

  export type ExpenseReceiptItemUncheckedCreateWithoutProductInput = {
    id?: number
    uuid?: string
    receipt_uuid: string
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptItemCreateOrConnectWithoutProductInput = {
    where: ExpenseReceiptItemWhereUniqueInput
    create: XOR<ExpenseReceiptItemCreateWithoutProductInput, ExpenseReceiptItemUncheckedCreateWithoutProductInput>
  }

  export type ExpenseReceiptItemCreateManyProductInputEnvelope = {
    data: ExpenseReceiptItemCreateManyProductInput | ExpenseReceiptItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutExpense_productsInput = {
    update: XOR<UserUpdateWithoutExpense_productsInput, UserUncheckedUpdateWithoutExpense_productsInput>
    create: XOR<UserCreateWithoutExpense_productsInput, UserUncheckedCreateWithoutExpense_productsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpense_productsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpense_productsInput, UserUncheckedUpdateWithoutExpense_productsInput>
  }

  export type UserUpdateWithoutExpense_productsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExpense_productsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseCategoryUpsertWithoutProductsInput = {
    update: XOR<ExpenseCategoryUpdateWithoutProductsInput, ExpenseCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ExpenseCategoryCreateWithoutProductsInput, ExpenseCategoryUncheckedCreateWithoutProductsInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutProductsInput, ExpenseCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ExpenseCategoryUpdateWithoutProductsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCategoriesNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutCategoryNestedInput
    entries?: ExpenseEntryUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    entries?: ExpenseEntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseSubcategoryUpsertWithoutProductsInput = {
    update: XOR<ExpenseSubcategoryUpdateWithoutProductsInput, ExpenseSubcategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ExpenseSubcategoryCreateWithoutProductsInput, ExpenseSubcategoryUncheckedCreateWithoutProductsInput>
    where?: ExpenseSubcategoryWhereInput
  }

  export type ExpenseSubcategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ExpenseSubcategoryWhereInput
    data: XOR<ExpenseSubcategoryUpdateWithoutProductsInput, ExpenseSubcategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ExpenseSubcategoryUpdateWithoutProductsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSubcategoriesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    entries?: ExpenseEntryUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseSubcategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ExpenseEntryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseReceiptItemUpsertWithWhereUniqueWithoutProductInput = {
    where: ExpenseReceiptItemWhereUniqueInput
    update: XOR<ExpenseReceiptItemUpdateWithoutProductInput, ExpenseReceiptItemUncheckedUpdateWithoutProductInput>
    create: XOR<ExpenseReceiptItemCreateWithoutProductInput, ExpenseReceiptItemUncheckedCreateWithoutProductInput>
  }

  export type ExpenseReceiptItemUpdateWithWhereUniqueWithoutProductInput = {
    where: ExpenseReceiptItemWhereUniqueInput
    data: XOR<ExpenseReceiptItemUpdateWithoutProductInput, ExpenseReceiptItemUncheckedUpdateWithoutProductInput>
  }

  export type ExpenseReceiptItemUpdateManyWithWhereWithoutProductInput = {
    where: ExpenseReceiptItemScalarWhereInput
    data: XOR<ExpenseReceiptItemUpdateManyMutationInput, ExpenseReceiptItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ExpenseReceiptCreateWithoutItemsInput = {
    uuid?: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutExpense_receiptsInput
    store?: ExpenseStoreCreateNestedOneWithoutReceiptsInput
    expense_entry: ExpenseEntryCreateNestedOneWithoutExpense_receiptInput
  }

  export type ExpenseReceiptUncheckedCreateWithoutItemsInput = {
    id?: number
    uuid?: string
    user_uuid: string
    store_uuid?: string | null
    expense_entry_uuid: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptCreateOrConnectWithoutItemsInput = {
    where: ExpenseReceiptWhereUniqueInput
    create: XOR<ExpenseReceiptCreateWithoutItemsInput, ExpenseReceiptUncheckedCreateWithoutItemsInput>
  }

  export type ExpenseProductCreateWithoutReceipt_itemsInput = {
    uuid?: string
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExpense_productsInput
    category?: ExpenseCategoryCreateNestedOneWithoutProductsInput
    subcategory?: ExpenseSubcategoryCreateNestedOneWithoutProductsInput
  }

  export type ExpenseProductUncheckedCreateWithoutReceipt_itemsInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseProductCreateOrConnectWithoutReceipt_itemsInput = {
    where: ExpenseProductWhereUniqueInput
    create: XOR<ExpenseProductCreateWithoutReceipt_itemsInput, ExpenseProductUncheckedCreateWithoutReceipt_itemsInput>
  }

  export type ExpenseReceiptUpsertWithoutItemsInput = {
    update: XOR<ExpenseReceiptUpdateWithoutItemsInput, ExpenseReceiptUncheckedUpdateWithoutItemsInput>
    create: XOR<ExpenseReceiptCreateWithoutItemsInput, ExpenseReceiptUncheckedCreateWithoutItemsInput>
    where?: ExpenseReceiptWhereInput
  }

  export type ExpenseReceiptUpdateToOneWithWhereWithoutItemsInput = {
    where?: ExpenseReceiptWhereInput
    data: XOR<ExpenseReceiptUpdateWithoutItemsInput, ExpenseReceiptUncheckedUpdateWithoutItemsInput>
  }

  export type ExpenseReceiptUpdateWithoutItemsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_receiptsNestedInput
    store?: ExpenseStoreUpdateOneWithoutReceiptsNestedInput
    expense_entry?: ExpenseEntryUpdateOneRequiredWithoutExpense_receiptNestedInput
  }

  export type ExpenseReceiptUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    store_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    expense_entry_uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseProductUpsertWithoutReceipt_itemsInput = {
    update: XOR<ExpenseProductUpdateWithoutReceipt_itemsInput, ExpenseProductUncheckedUpdateWithoutReceipt_itemsInput>
    create: XOR<ExpenseProductCreateWithoutReceipt_itemsInput, ExpenseProductUncheckedCreateWithoutReceipt_itemsInput>
    where?: ExpenseProductWhereInput
  }

  export type ExpenseProductUpdateToOneWithWhereWithoutReceipt_itemsInput = {
    where?: ExpenseProductWhereInput
    data: XOR<ExpenseProductUpdateWithoutReceipt_itemsInput, ExpenseProductUncheckedUpdateWithoutReceipt_itemsInput>
  }

  export type ExpenseProductUpdateWithoutReceipt_itemsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExpense_productsNestedInput
    category?: ExpenseCategoryUpdateOneWithoutProductsNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutProductsNestedInput
  }

  export type ExpenseProductUncheckedUpdateWithoutReceipt_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutMuscle_groupsInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMuscle_groupsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMuscle_groupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMuscle_groupsInput, UserUncheckedCreateWithoutMuscle_groupsInput>
  }

  export type ExerciseCreateWithoutMuscle_groupInput = {
    uuid?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExercisesInput
    entries?: WorkoutEntryCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutMuscle_groupInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
    entries?: WorkoutEntryUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutMuscle_groupInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutMuscle_groupInput, ExerciseUncheckedCreateWithoutMuscle_groupInput>
  }

  export type ExerciseCreateManyMuscle_groupInputEnvelope = {
    data: ExerciseCreateManyMuscle_groupInput | ExerciseCreateManyMuscle_groupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMuscle_groupsInput = {
    update: XOR<UserUpdateWithoutMuscle_groupsInput, UserUncheckedUpdateWithoutMuscle_groupsInput>
    create: XOR<UserCreateWithoutMuscle_groupsInput, UserUncheckedCreateWithoutMuscle_groupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMuscle_groupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMuscle_groupsInput, UserUncheckedUpdateWithoutMuscle_groupsInput>
  }

  export type UserUpdateWithoutMuscle_groupsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMuscle_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExerciseUpsertWithWhereUniqueWithoutMuscle_groupInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutMuscle_groupInput, ExerciseUncheckedUpdateWithoutMuscle_groupInput>
    create: XOR<ExerciseCreateWithoutMuscle_groupInput, ExerciseUncheckedCreateWithoutMuscle_groupInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutMuscle_groupInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutMuscle_groupInput, ExerciseUncheckedUpdateWithoutMuscle_groupInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutMuscle_groupInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutMuscle_groupInput>
  }

  export type UserCreateWithoutExercisesInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    workouts?: WorkoutCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExercisesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExercisesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
  }

  export type MuscleGroupCreateWithoutExercisesInput = {
    uuid?: string
    name: string
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutMuscle_groupsInput
  }

  export type MuscleGroupUncheckedCreateWithoutExercisesInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MuscleGroupCreateOrConnectWithoutExercisesInput = {
    where: MuscleGroupWhereUniqueInput
    create: XOR<MuscleGroupCreateWithoutExercisesInput, MuscleGroupUncheckedCreateWithoutExercisesInput>
  }

  export type WorkoutEntryCreateWithoutExerciseInput = {
    uuid?: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
    workout: WorkoutCreateNestedOneWithoutEntriesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkout_entryInput
  }

  export type WorkoutEntryUncheckedCreateWithoutExerciseInput = {
    id?: number
    uuid?: string
    workout_uuid: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkout_entryInput
  }

  export type WorkoutEntryCreateOrConnectWithoutExerciseInput = {
    where: WorkoutEntryWhereUniqueInput
    create: XOR<WorkoutEntryCreateWithoutExerciseInput, WorkoutEntryUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutEntryCreateManyExerciseInputEnvelope = {
    data: WorkoutEntryCreateManyExerciseInput | WorkoutEntryCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutExercisesInput = {
    update: XOR<UserUpdateWithoutExercisesInput, UserUncheckedUpdateWithoutExercisesInput>
    create: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExercisesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExercisesInput, UserUncheckedUpdateWithoutExercisesInput>
  }

  export type UserUpdateWithoutExercisesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    workouts?: WorkoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MuscleGroupUpsertWithoutExercisesInput = {
    update: XOR<MuscleGroupUpdateWithoutExercisesInput, MuscleGroupUncheckedUpdateWithoutExercisesInput>
    create: XOR<MuscleGroupCreateWithoutExercisesInput, MuscleGroupUncheckedCreateWithoutExercisesInput>
    where?: MuscleGroupWhereInput
  }

  export type MuscleGroupUpdateToOneWithWhereWithoutExercisesInput = {
    where?: MuscleGroupWhereInput
    data: XOR<MuscleGroupUpdateWithoutExercisesInput, MuscleGroupUncheckedUpdateWithoutExercisesInput>
  }

  export type MuscleGroupUpdateWithoutExercisesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMuscle_groupsNestedInput
  }

  export type MuscleGroupUncheckedUpdateWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutEntryUpsertWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutEntryWhereUniqueInput
    update: XOR<WorkoutEntryUpdateWithoutExerciseInput, WorkoutEntryUncheckedUpdateWithoutExerciseInput>
    create: XOR<WorkoutEntryCreateWithoutExerciseInput, WorkoutEntryUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutEntryUpdateWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutEntryWhereUniqueInput
    data: XOR<WorkoutEntryUpdateWithoutExerciseInput, WorkoutEntryUncheckedUpdateWithoutExerciseInput>
  }

  export type WorkoutEntryUpdateManyWithWhereWithoutExerciseInput = {
    where: WorkoutEntryScalarWhereInput
    data: XOR<WorkoutEntryUpdateManyMutationInput, WorkoutEntryUncheckedUpdateManyWithoutExerciseInput>
  }

  export type WorkoutEntryScalarWhereInput = {
    AND?: WorkoutEntryScalarWhereInput | WorkoutEntryScalarWhereInput[]
    OR?: WorkoutEntryScalarWhereInput[]
    NOT?: WorkoutEntryScalarWhereInput | WorkoutEntryScalarWhereInput[]
    id?: IntFilter<"WorkoutEntry"> | number
    uuid?: StringFilter<"WorkoutEntry"> | string
    workout_uuid?: StringFilter<"WorkoutEntry"> | string
    exercise_uuid?: StringFilter<"WorkoutEntry"> | string
    order?: IntFilter<"WorkoutEntry"> | number
    created_at?: DateTimeFilter<"WorkoutEntry"> | Date | string
    updated_at?: DateTimeFilter<"WorkoutEntry"> | Date | string
  }

  export type UserCreateWithoutWorkoutsInput = {
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkoutsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    password: string
    first_name: string
    last_name: string
    role: $Enums.AuthRole
    created_at?: Date | string
    updated_at?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    schedule_slots?: ScheduleSlotUncheckedCreateNestedManyWithoutUserInput
    activity_schedules?: ActivityScheduleUncheckedCreateNestedManyWithoutUserInput
    activity_logs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    activity_occurrences?: ActivityOccurrenceUncheckedCreateNestedManyWithoutUserInput
    expense_accounts?: ExpenseAccountUncheckedCreateNestedManyWithoutUserInput
    expense_entries?: ExpenseEntryUncheckedCreateNestedManyWithoutUserInput
    categories?: ExpenseCategoryUncheckedCreateNestedManyWithoutUserInput
    subcategories?: ExpenseSubcategoryUncheckedCreateNestedManyWithoutUserInput
    expense_receipts?: ExpenseReceiptUncheckedCreateNestedManyWithoutUserInput
    expense_stores?: ExpenseStoreUncheckedCreateNestedManyWithoutUserInput
    expense_products?: ExpenseProductUncheckedCreateNestedManyWithoutUserInput
    muscle_groups?: MuscleGroupUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkoutsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkoutsInput, UserUncheckedCreateWithoutWorkoutsInput>
  }

  export type WorkoutEntryCreateWithoutWorkoutInput = {
    uuid?: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
    exercise: ExerciseCreateNestedOneWithoutEntriesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkout_entryInput
  }

  export type WorkoutEntryUncheckedCreateWithoutWorkoutInput = {
    id?: number
    uuid?: string
    exercise_uuid: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkout_entryInput
  }

  export type WorkoutEntryCreateOrConnectWithoutWorkoutInput = {
    where: WorkoutEntryWhereUniqueInput
    create: XOR<WorkoutEntryCreateWithoutWorkoutInput, WorkoutEntryUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutEntryCreateManyWorkoutInputEnvelope = {
    data: WorkoutEntryCreateManyWorkoutInput | WorkoutEntryCreateManyWorkoutInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkoutsInput = {
    update: XOR<UserUpdateWithoutWorkoutsInput, UserUncheckedUpdateWithoutWorkoutsInput>
    create: XOR<UserCreateWithoutWorkoutsInput, UserUncheckedCreateWithoutWorkoutsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkoutsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkoutsInput, UserUncheckedUpdateWithoutWorkoutsInput>
  }

  export type UserUpdateWithoutWorkoutsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    role?: EnumAuthRoleFieldUpdateOperationsInput | $Enums.AuthRole
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutUserNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutUserNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutUserNestedInput
    expense_accounts?: ExpenseAccountUncheckedUpdateManyWithoutUserNestedInput
    expense_entries?: ExpenseEntryUncheckedUpdateManyWithoutUserNestedInput
    categories?: ExpenseCategoryUncheckedUpdateManyWithoutUserNestedInput
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutUserNestedInput
    expense_receipts?: ExpenseReceiptUncheckedUpdateManyWithoutUserNestedInput
    expense_stores?: ExpenseStoreUncheckedUpdateManyWithoutUserNestedInput
    expense_products?: ExpenseProductUncheckedUpdateManyWithoutUserNestedInput
    muscle_groups?: MuscleGroupUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkoutEntryUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutEntryWhereUniqueInput
    update: XOR<WorkoutEntryUpdateWithoutWorkoutInput, WorkoutEntryUncheckedUpdateWithoutWorkoutInput>
    create: XOR<WorkoutEntryCreateWithoutWorkoutInput, WorkoutEntryUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutEntryUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutEntryWhereUniqueInput
    data: XOR<WorkoutEntryUpdateWithoutWorkoutInput, WorkoutEntryUncheckedUpdateWithoutWorkoutInput>
  }

  export type WorkoutEntryUpdateManyWithWhereWithoutWorkoutInput = {
    where: WorkoutEntryScalarWhereInput
    data: XOR<WorkoutEntryUpdateManyMutationInput, WorkoutEntryUncheckedUpdateManyWithoutWorkoutInput>
  }

  export type WorkoutCreateWithoutEntriesInput = {
    uuid?: string
    name?: string | null
    notes?: string | null
    started_at?: Date | string
    finished_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutWorkoutsInput
  }

  export type WorkoutUncheckedCreateWithoutEntriesInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name?: string | null
    notes?: string | null
    started_at?: Date | string
    finished_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutCreateOrConnectWithoutEntriesInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutEntriesInput, WorkoutUncheckedCreateWithoutEntriesInput>
  }

  export type ExerciseCreateWithoutEntriesInput = {
    uuid?: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutExercisesInput
    muscle_group: MuscleGroupCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutEntriesInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    muscle_group_uuid: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExerciseCreateOrConnectWithoutEntriesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutEntriesInput, ExerciseUncheckedCreateWithoutEntriesInput>
  }

  export type WorkoutSetCreateWithoutWorkout_entryInput = {
    uuid?: string
    type: $Enums.ExerciseType
    reps?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    duration_seconds?: number | null
    distance_meters?: number | null
    rest_seconds?: number | null
    notes?: string | null
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutSetUncheckedCreateWithoutWorkout_entryInput = {
    id?: number
    uuid?: string
    type: $Enums.ExerciseType
    reps?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    duration_seconds?: number | null
    distance_meters?: number | null
    rest_seconds?: number | null
    notes?: string | null
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutSetCreateOrConnectWithoutWorkout_entryInput = {
    where: WorkoutSetWhereUniqueInput
    create: XOR<WorkoutSetCreateWithoutWorkout_entryInput, WorkoutSetUncheckedCreateWithoutWorkout_entryInput>
  }

  export type WorkoutSetCreateManyWorkout_entryInputEnvelope = {
    data: WorkoutSetCreateManyWorkout_entryInput | WorkoutSetCreateManyWorkout_entryInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutUpsertWithoutEntriesInput = {
    update: XOR<WorkoutUpdateWithoutEntriesInput, WorkoutUncheckedUpdateWithoutEntriesInput>
    create: XOR<WorkoutCreateWithoutEntriesInput, WorkoutUncheckedCreateWithoutEntriesInput>
    where?: WorkoutWhereInput
  }

  export type WorkoutUpdateToOneWithWhereWithoutEntriesInput = {
    where?: WorkoutWhereInput
    data: XOR<WorkoutUpdateWithoutEntriesInput, WorkoutUncheckedUpdateWithoutEntriesInput>
  }

  export type WorkoutUpdateWithoutEntriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWorkoutsNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUpsertWithoutEntriesInput = {
    update: XOR<ExerciseUpdateWithoutEntriesInput, ExerciseUncheckedUpdateWithoutEntriesInput>
    create: XOR<ExerciseCreateWithoutEntriesInput, ExerciseUncheckedCreateWithoutEntriesInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutEntriesInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutEntriesInput, ExerciseUncheckedUpdateWithoutEntriesInput>
  }

  export type ExerciseUpdateWithoutEntriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExercisesNestedInput
    muscle_group?: MuscleGroupUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    muscle_group_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetUpsertWithWhereUniqueWithoutWorkout_entryInput = {
    where: WorkoutSetWhereUniqueInput
    update: XOR<WorkoutSetUpdateWithoutWorkout_entryInput, WorkoutSetUncheckedUpdateWithoutWorkout_entryInput>
    create: XOR<WorkoutSetCreateWithoutWorkout_entryInput, WorkoutSetUncheckedCreateWithoutWorkout_entryInput>
  }

  export type WorkoutSetUpdateWithWhereUniqueWithoutWorkout_entryInput = {
    where: WorkoutSetWhereUniqueInput
    data: XOR<WorkoutSetUpdateWithoutWorkout_entryInput, WorkoutSetUncheckedUpdateWithoutWorkout_entryInput>
  }

  export type WorkoutSetUpdateManyWithWhereWithoutWorkout_entryInput = {
    where: WorkoutSetScalarWhereInput
    data: XOR<WorkoutSetUpdateManyMutationInput, WorkoutSetUncheckedUpdateManyWithoutWorkout_entryInput>
  }

  export type WorkoutSetScalarWhereInput = {
    AND?: WorkoutSetScalarWhereInput | WorkoutSetScalarWhereInput[]
    OR?: WorkoutSetScalarWhereInput[]
    NOT?: WorkoutSetScalarWhereInput | WorkoutSetScalarWhereInput[]
    id?: IntFilter<"WorkoutSet"> | number
    uuid?: StringFilter<"WorkoutSet"> | string
    workout_entry_uuid?: StringFilter<"WorkoutSet"> | string
    type?: EnumExerciseTypeFilter<"WorkoutSet"> | $Enums.ExerciseType
    reps?: IntNullableFilter<"WorkoutSet"> | number | null
    weight?: DecimalNullableFilter<"WorkoutSet"> | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: IntNullableFilter<"WorkoutSet"> | number | null
    distance_meters?: IntNullableFilter<"WorkoutSet"> | number | null
    rest_seconds?: IntNullableFilter<"WorkoutSet"> | number | null
    notes?: StringNullableFilter<"WorkoutSet"> | string | null
    is_dropset?: BoolFilter<"WorkoutSet"> | boolean
    is_amrap?: BoolFilter<"WorkoutSet"> | boolean
    is_rest?: BoolFilter<"WorkoutSet"> | boolean
    is_warmup?: BoolFilter<"WorkoutSet"> | boolean
    is_cooldown?: BoolFilter<"WorkoutSet"> | boolean
    is_super_set?: BoolFilter<"WorkoutSet"> | boolean
    order?: IntFilter<"WorkoutSet"> | number
    created_at?: DateTimeFilter<"WorkoutSet"> | Date | string
    updated_at?: DateTimeFilter<"WorkoutSet"> | Date | string
  }

  export type WorkoutEntryCreateWithoutSetsInput = {
    uuid?: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
    workout: WorkoutCreateNestedOneWithoutEntriesInput
    exercise: ExerciseCreateNestedOneWithoutEntriesInput
  }

  export type WorkoutEntryUncheckedCreateWithoutSetsInput = {
    id?: number
    uuid?: string
    workout_uuid: string
    exercise_uuid: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutEntryCreateOrConnectWithoutSetsInput = {
    where: WorkoutEntryWhereUniqueInput
    create: XOR<WorkoutEntryCreateWithoutSetsInput, WorkoutEntryUncheckedCreateWithoutSetsInput>
  }

  export type WorkoutEntryUpsertWithoutSetsInput = {
    update: XOR<WorkoutEntryUpdateWithoutSetsInput, WorkoutEntryUncheckedUpdateWithoutSetsInput>
    create: XOR<WorkoutEntryCreateWithoutSetsInput, WorkoutEntryUncheckedCreateWithoutSetsInput>
    where?: WorkoutEntryWhereInput
  }

  export type WorkoutEntryUpdateToOneWithWhereWithoutSetsInput = {
    where?: WorkoutEntryWhereInput
    data: XOR<WorkoutEntryUpdateWithoutSetsInput, WorkoutEntryUncheckedUpdateWithoutSetsInput>
  }

  export type WorkoutEntryUpdateWithoutSetsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: WorkoutUpdateOneRequiredWithoutEntriesNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type WorkoutEntryUncheckedUpdateWithoutSetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    workout_uuid?: StringFieldUpdateOperationsInput | string
    exercise_uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: number
    uuid?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    visible?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleSlotCreateManyUserInput = {
    id?: number
    uuid?: string
    activity_uuid: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityScheduleCreateManyUserInput = {
    id?: number
    uuid?: string
    activity_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id?: number
    uuid?: string
    activity_uuid: string
    schedule_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityOccurrenceCreateManyUserInput = {
    id?: number
    uuid?: string
    activity_uuid: string
    schedule_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseAccountCreateManyUserInput = {
    id?: number
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseEntryCreateManyUserInput = {
    id?: number
    uuid?: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseCategoryCreateManyUserInput = {
    id?: number
    uuid?: string
    name: string
    icon?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseSubcategoryCreateManyUserInput = {
    id?: number
    uuid?: string
    category_uuid: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptCreateManyUserInput = {
    id?: number
    uuid?: string
    store_uuid?: string | null
    expense_entry_uuid: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseStoreCreateManyUserInput = {
    id?: number
    uuid?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseProductCreateManyUserInput = {
    id?: number
    uuid?: string
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MuscleGroupCreateManyUserInput = {
    id?: number
    uuid?: string
    name: string
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExerciseCreateManyUserInput = {
    id?: number
    uuid?: string
    muscle_group_uuid: string
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutCreateManyUserInput = {
    id?: number
    uuid?: string
    name?: string | null
    notes?: string | null
    started_at?: Date | string
    finished_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule_slots?: ScheduleSlotUpdateManyWithoutActivityNestedInput
    activity_schedules?: ActivityScheduleUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule_slots?: ScheduleSlotUncheckedUpdateManyWithoutActivityNestedInput
    activity_schedules?: ActivityScheduleUncheckedUpdateManyWithoutActivityNestedInput
    activity_logs?: ActivityLogUncheckedUpdateManyWithoutActivityNestedInput
    activity_occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleSlotUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutSchedule_slotsNestedInput
  }

  export type ScheduleSlotUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleSlotUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_schedulesNestedInput
    weekdays?: ActivityScheduleWeekdayUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUncheckedUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_logsNestedInput
    schedule?: ActivityScheduleUpdateOneRequiredWithoutLogsNestedInput
    occurrence?: ActivityOccurrenceUpdateOneRequiredWithoutLogNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    occurrence_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    occurrence_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityOccurrenceUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_occurrencesNestedInput
    schedule?: ActivityScheduleUpdateOneRequiredWithoutOccurrencesNestedInput
    log?: ActivityLogUpdateOneWithoutOccurrenceNestedInput
  }

  export type ActivityOccurrenceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    log?: ActivityLogUncheckedUpdateOneWithoutOccurrenceNestedInput
  }

  export type ActivityOccurrenceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseAccountUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries_from?: ExpenseEntryUpdateManyWithoutFrom_accountNestedInput
    entries_to?: ExpenseEntryUpdateManyWithoutTo_accountNestedInput
  }

  export type ExpenseAccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries_from?: ExpenseEntryUncheckedUpdateManyWithoutFrom_accountNestedInput
    entries_to?: ExpenseEntryUncheckedUpdateManyWithoutTo_accountNestedInput
  }

  export type ExpenseAccountUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseEntryUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    from_account?: ExpenseAccountUpdateOneRequiredWithoutEntries_fromNestedInput
    to_account?: ExpenseAccountUpdateOneWithoutEntries_toNestedInput
    category?: ExpenseCategoryUpdateOneWithoutEntriesNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutEntriesNestedInput
    expense_receipt?: ExpenseReceiptUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expense_receipt?: ExpenseReceiptUncheckedUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ExpenseSubcategoryUpdateManyWithoutCategoryNestedInput
    entries?: ExpenseEntryUpdateManyWithoutCategoryNestedInput
    products?: ExpenseProductUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: ExpenseSubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    entries?: ExpenseEntryUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ExpenseProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseSubcategoryUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ExpenseCategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    entries?: ExpenseEntryUpdateManyWithoutSubcategoryNestedInput
    products?: ExpenseProductUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseSubcategoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    category_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ExpenseEntryUncheckedUpdateManyWithoutSubcategoryNestedInput
    products?: ExpenseProductUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseSubcategoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    category_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: ExpenseStoreUpdateOneWithoutReceiptsNestedInput
    expense_entry?: ExpenseEntryUpdateOneRequiredWithoutExpense_receiptNestedInput
    items?: ExpenseReceiptItemUpdateManyWithoutReceiptNestedInput
  }

  export type ExpenseReceiptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    store_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    expense_entry_uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ExpenseReceiptItemUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ExpenseReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    store_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    expense_entry_uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseStoreUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipts?: ExpenseReceiptUpdateManyWithoutStoreNestedInput
  }

  export type ExpenseStoreUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipts?: ExpenseReceiptUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ExpenseStoreUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseProductUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ExpenseCategoryUpdateOneWithoutProductsNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutProductsNestedInput
    receipt_items?: ExpenseReceiptItemUpdateManyWithoutProductNestedInput
  }

  export type ExpenseProductUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_items?: ExpenseReceiptItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ExpenseProductUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuscleGroupUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUpdateManyWithoutMuscle_groupNestedInput
  }

  export type MuscleGroupUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUncheckedUpdateManyWithoutMuscle_groupNestedInput
  }

  export type MuscleGroupUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    muscle_group?: MuscleGroupUpdateOneRequiredWithoutExercisesNestedInput
    entries?: WorkoutEntryUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    muscle_group_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: WorkoutEntryUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    muscle_group_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: WorkoutEntryUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: WorkoutEntryUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleSlotCreateManyActivityInput = {
    id?: number
    uuid?: string
    user_uuid: string
    day: $Enums.ScheduleDay
    start_time: string
    end_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityScheduleCreateManyActivityInput = {
    id?: number
    uuid?: string
    user_uuid: string
    valid_from?: Date | string
    valid_until?: Date | string | null
    repeat_type: $Enums.ActivityRepeatType
    interval_days?: number | null
    time_of_day?: string | null
    frequency_value?: number | null
    frequency_period?: $Enums.FrequencyPeriod | null
    target_type: $Enums.ActivityTargetType
    target_value?: number | null
    target_unit?: $Enums.ActivityTargetUnit | null
    target_unit_label?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateManyActivityInput = {
    id?: number
    uuid?: string
    user_uuid: string
    schedule_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityOccurrenceCreateManyActivityInput = {
    id?: number
    uuid?: string
    user_uuid: string
    schedule_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleSlotUpdateWithoutActivityInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchedule_slotsNestedInput
  }

  export type ScheduleSlotUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleSlotUncheckedUpdateManyWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    day?: EnumScheduleDayFieldUpdateOperationsInput | $Enums.ScheduleDay
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleUpdateWithoutActivityInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivity_schedulesNestedInput
    weekdays?: ActivityScheduleWeekdayUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    weekdays?: ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleNestedInput
    specific_dates?: ActivityScheduleDateUncheckedUpdateManyWithoutScheduleNestedInput
    occurrences?: ActivityOccurrenceUncheckedUpdateManyWithoutScheduleNestedInput
    logs?: ActivityLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ActivityScheduleUncheckedUpdateManyWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repeat_type?: EnumActivityRepeatTypeFieldUpdateOperationsInput | $Enums.ActivityRepeatType
    interval_days?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableStringFieldUpdateOperationsInput | string | null
    frequency_value?: NullableIntFieldUpdateOperationsInput | number | null
    frequency_period?: NullableEnumFrequencyPeriodFieldUpdateOperationsInput | $Enums.FrequencyPeriod | null
    target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutActivityInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ActivityScheduleUpdateOneRequiredWithoutLogsNestedInput
    occurrence?: ActivityOccurrenceUpdateOneRequiredWithoutLogNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_logsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    occurrence_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    occurrence_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityOccurrenceUpdateWithoutActivityInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ActivityScheduleUpdateOneRequiredWithoutOccurrencesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_occurrencesNestedInput
    log?: ActivityLogUpdateOneWithoutOccurrenceNestedInput
  }

  export type ActivityOccurrenceUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    log?: ActivityLogUncheckedUpdateOneWithoutOccurrenceNestedInput
  }

  export type ActivityOccurrenceUncheckedUpdateManyWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    schedule_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleWeekdayCreateManyScheduleInput = {
    id?: number
    weekday: number
  }

  export type ActivityScheduleDateCreateManyScheduleInput = {
    id?: number
    date: Date | string
  }

  export type ActivityOccurrenceCreateManyScheduleInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    scheduled_for: Date | string
    status?: $Enums.OccurrenceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateManyScheduleInput = {
    id?: number
    uuid?: string
    user_uuid: string
    activity_uuid: string
    occurrence_uuid: string
    snapshot_target_type: $Enums.ActivityTargetType
    snapshot_target_value?: number | null
    snapshot_target_unit?: $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: string | null
    value?: number | null
    completed?: boolean
    completed_at?: Date | string | null
    skipped?: boolean
    skip_reason?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityScheduleWeekdayUpdateWithoutScheduleInput = {
    weekday?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityScheduleWeekdayUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    weekday?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityScheduleWeekdayUncheckedUpdateManyWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    weekday?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityScheduleDateUpdateWithoutScheduleInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleDateUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityScheduleDateUncheckedUpdateManyWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityOccurrenceUpdateWithoutScheduleInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_occurrencesNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_occurrencesNestedInput
    log?: ActivityLogUpdateOneWithoutOccurrenceNestedInput
  }

  export type ActivityOccurrenceUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    log?: ActivityLogUncheckedUpdateOneWithoutOccurrenceNestedInput
  }

  export type ActivityOccurrenceUncheckedUpdateManyWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    scheduled_for?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutScheduleInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutActivity_logsNestedInput
    occurrence?: ActivityOccurrenceUpdateOneRequiredWithoutLogNestedInput
    user?: UserUpdateOneRequiredWithoutActivity_logsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    occurrence_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    activity_uuid?: StringFieldUpdateOperationsInput | string
    occurrence_uuid?: StringFieldUpdateOperationsInput | string
    snapshot_target_type?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    snapshot_target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    snapshot_target_unit?: NullableEnumActivityTargetUnitFieldUpdateOperationsInput | $Enums.ActivityTargetUnit | null
    snapshot_target_unit_label?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    skip_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseEntryCreateManyFrom_accountInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    to_account_uuid?: string | null
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseEntryCreateManyTo_accountInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    category_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseEntryUpdateWithoutFrom_accountInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_entriesNestedInput
    to_account?: ExpenseAccountUpdateOneWithoutEntries_toNestedInput
    category?: ExpenseCategoryUpdateOneWithoutEntriesNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutEntriesNestedInput
    expense_receipt?: ExpenseReceiptUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateWithoutFrom_accountInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expense_receipt?: ExpenseReceiptUncheckedUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutFrom_accountInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseEntryUpdateWithoutTo_accountInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_entriesNestedInput
    from_account?: ExpenseAccountUpdateOneRequiredWithoutEntries_fromNestedInput
    category?: ExpenseCategoryUpdateOneWithoutEntriesNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutEntriesNestedInput
    expense_receipt?: ExpenseReceiptUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateWithoutTo_accountInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expense_receipt?: ExpenseReceiptUncheckedUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutTo_accountInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseSubcategoryCreateManyCategoryInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseEntryCreateManyCategoryInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    subcategory_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseProductCreateManyCategoryInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    subcategory_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseSubcategoryUpdateWithoutCategoryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSubcategoriesNestedInput
    entries?: ExpenseEntryUpdateManyWithoutSubcategoryNestedInput
    products?: ExpenseProductUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseSubcategoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ExpenseEntryUncheckedUpdateManyWithoutSubcategoryNestedInput
    products?: ExpenseProductUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type ExpenseSubcategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseEntryUpdateWithoutCategoryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_entriesNestedInput
    from_account?: ExpenseAccountUpdateOneRequiredWithoutEntries_fromNestedInput
    to_account?: ExpenseAccountUpdateOneWithoutEntries_toNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutEntriesNestedInput
    expense_receipt?: ExpenseReceiptUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expense_receipt?: ExpenseReceiptUncheckedUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseProductUpdateWithoutCategoryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExpense_productsNestedInput
    subcategory?: ExpenseSubcategoryUpdateOneWithoutProductsNestedInput
    receipt_items?: ExpenseReceiptItemUpdateManyWithoutProductNestedInput
  }

  export type ExpenseProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_items?: ExpenseReceiptItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ExpenseProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subcategory_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseEntryCreateManySubcategoryInput = {
    id?: number
    uuid?: string
    user_uuid: string
    type: $Enums.ExpenseEntryType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    from_account_uuid: string
    to_account_uuid?: string | null
    category_uuid?: string | null
    entry_date?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseProductCreateManySubcategoryInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    brand?: string | null
    unit?: string | null
    size?: Decimal | DecimalJsLike | number | string | null
    category_uuid?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseEntryUpdateWithoutSubcategoryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_entriesNestedInput
    from_account?: ExpenseAccountUpdateOneRequiredWithoutEntries_fromNestedInput
    to_account?: ExpenseAccountUpdateOneWithoutEntries_toNestedInput
    category?: ExpenseCategoryUpdateOneWithoutEntriesNestedInput
    expense_receipt?: ExpenseReceiptUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateWithoutSubcategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expense_receipt?: ExpenseReceiptUncheckedUpdateOneWithoutExpense_entryNestedInput
  }

  export type ExpenseEntryUncheckedUpdateManyWithoutSubcategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseEntryTypeFieldUpdateOperationsInput | $Enums.ExpenseEntryType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    from_account_uuid?: StringFieldUpdateOperationsInput | string
    to_account_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseProductUpdateWithoutSubcategoryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExpense_productsNestedInput
    category?: ExpenseCategoryUpdateOneWithoutProductsNestedInput
    receipt_items?: ExpenseReceiptItemUpdateManyWithoutProductNestedInput
  }

  export type ExpenseProductUncheckedUpdateWithoutSubcategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_items?: ExpenseReceiptItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ExpenseProductUncheckedUpdateManyWithoutSubcategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    category_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptCreateManyStoreInput = {
    id?: number
    uuid?: string
    user_uuid: string
    expense_entry_uuid: string
    receipt_date?: Date | string
    total_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptUpdateWithoutStoreInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpense_receiptsNestedInput
    expense_entry?: ExpenseEntryUpdateOneRequiredWithoutExpense_receiptNestedInput
    items?: ExpenseReceiptItemUpdateManyWithoutReceiptNestedInput
  }

  export type ExpenseReceiptUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    expense_entry_uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ExpenseReceiptItemUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ExpenseReceiptUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    expense_entry_uuid?: StringFieldUpdateOperationsInput | string
    receipt_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptItemCreateManyReceiptInput = {
    id?: number
    uuid?: string
    product_uuid?: string | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptItemUpdateWithoutReceiptInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ExpenseProductUpdateOneWithoutReceipt_itemsNestedInput
  }

  export type ExpenseReceiptItemUncheckedUpdateWithoutReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    product_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptItemUncheckedUpdateManyWithoutReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    product_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptItemCreateManyProductInput = {
    id?: number
    uuid?: string
    receipt_uuid: string
    quantity?: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExpenseReceiptItemUpdateWithoutProductInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt?: ExpenseReceiptUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ExpenseReceiptItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_uuid?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseReceiptItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    receipt_uuid?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateManyMuscle_groupInput = {
    id?: number
    uuid?: string
    user_uuid?: string | null
    name: string
    description?: string | null
    type: $Enums.ExerciseType
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExerciseUpdateWithoutMuscle_groupInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutExercisesNestedInput
    entries?: WorkoutEntryUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutMuscle_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: WorkoutEntryUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutMuscle_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    user_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutEntryCreateManyExerciseInput = {
    id?: number
    uuid?: string
    workout_uuid: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutEntryUpdateWithoutExerciseInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: WorkoutUpdateOneRequiredWithoutEntriesNestedInput
    sets?: WorkoutSetUpdateManyWithoutWorkout_entryNestedInput
  }

  export type WorkoutEntryUncheckedUpdateWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    workout_uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkout_entryNestedInput
  }

  export type WorkoutEntryUncheckedUpdateManyWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    workout_uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutEntryCreateManyWorkoutInput = {
    id?: number
    uuid?: string
    exercise_uuid: string
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutEntryUpdateWithoutWorkoutInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutEntriesNestedInput
    sets?: WorkoutSetUpdateManyWithoutWorkout_entryNestedInput
  }

  export type WorkoutEntryUncheckedUpdateWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    exercise_uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkout_entryNestedInput
  }

  export type WorkoutEntryUncheckedUpdateManyWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    exercise_uuid?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetCreateManyWorkout_entryInput = {
    id?: number
    uuid?: string
    type: $Enums.ExerciseType
    reps?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    duration_seconds?: number | null
    distance_meters?: number | null
    rest_seconds?: number | null
    notes?: string | null
    is_dropset?: boolean
    is_amrap?: boolean
    is_rest?: boolean
    is_warmup?: boolean
    is_cooldown?: boolean
    is_super_set?: boolean
    order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkoutSetUpdateWithoutWorkout_entryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    distance_meters?: NullableIntFieldUpdateOperationsInput | number | null
    rest_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_dropset?: BoolFieldUpdateOperationsInput | boolean
    is_amrap?: BoolFieldUpdateOperationsInput | boolean
    is_rest?: BoolFieldUpdateOperationsInput | boolean
    is_warmup?: BoolFieldUpdateOperationsInput | boolean
    is_cooldown?: BoolFieldUpdateOperationsInput | boolean
    is_super_set?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetUncheckedUpdateWithoutWorkout_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    distance_meters?: NullableIntFieldUpdateOperationsInput | number | null
    rest_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_dropset?: BoolFieldUpdateOperationsInput | boolean
    is_amrap?: BoolFieldUpdateOperationsInput | boolean
    is_rest?: BoolFieldUpdateOperationsInput | boolean
    is_warmup?: BoolFieldUpdateOperationsInput | boolean
    is_cooldown?: BoolFieldUpdateOperationsInput | boolean
    is_super_set?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetUncheckedUpdateManyWithoutWorkout_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeFieldUpdateOperationsInput | $Enums.ExerciseType
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    distance_meters?: NullableIntFieldUpdateOperationsInput | number | null
    rest_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_dropset?: BoolFieldUpdateOperationsInput | boolean
    is_amrap?: BoolFieldUpdateOperationsInput | boolean
    is_rest?: BoolFieldUpdateOperationsInput | boolean
    is_warmup?: BoolFieldUpdateOperationsInput | boolean
    is_cooldown?: BoolFieldUpdateOperationsInput | boolean
    is_super_set?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}